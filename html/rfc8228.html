<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8228 - Guidance on Designing Label Generation Rulesets (LGRs) Supporting Variant Labels 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8228</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <a href="https://tools.ietf.org/html/rfc8228">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8228 - Guidance on Designing Label Generation Rulesets (LGRs) Supporting Variant Labels 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8228">
              https://tools.ietf.org/html/rfc8228
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8228 - バリアントラベルをサポートするラベル生成ルールセット（LGR）の設計に関するガイダンス</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        A. Freytag
Request for Comments: 8228                                   August 2017
Category: Informational
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Guidance on Designing Label Generation Rulesets (LGRs) Supporting Variant Labels
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベルをサポートするラベル生成ルールセット（LGR）の設計に関するガイダンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rules for validating identifier labels and alternate representations of those labels (variants) are known as Label Generation Rulesets (LGRs); they are used for the implementation of identifier systems such as Internationalized Domain Names (IDNs). This document describes ways to design LGRs to support variant labels. In designing LGRs, it is important to ensure that the label generation rules are consistent and well behaved in the presence of variants. The design decisions can then be expressed using the XML representation of LGRs that is defined in RFC 7940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子ラベルとそれらのラベル（バリアント）の代替表現を検証するためのルールは、ラベル生成ルールセット（LGR）として知られています。これらは、国際化ドメイン名（IDN）などの識別子システムの実装に使用されます。このドキュメントでは、バリアントラベルをサポートするLGRを設計する方法について説明します。 LGRの設計では、ラベル生成ルールが一貫しており、バリアントが存在する場合でも適切に動作することを確認することが重要です。次に、RFC 7940で定義されているLGRのXML表現を使用して、設計の決定を表現できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF（Internet Engineering Task Force）の製品です。 Internet Engineering Steering Group（IESG）による公開が承認されています。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補になるわけではありません。 RFC 7841のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8228.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8228で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2017 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Variant Relations . . . . . . . . . . . . . . . . . . . . . .   4
   3.  Symmetry and Transitivity . . . . . . . . . . . . . . . . . .   5
   4.  A Word on Notation  . . . . . . . . . . . . . . . . . . . . .   5
   5.  Variant Mappings  . . . . . . . . . . . . . . . . . . . . . .   6
   6.  Variant Labels  . . . . . . . . . . . . . . . . . . . . . . .   7
   7.  Variant Types and Label Dispositions  . . . . . . . . . . . .   7
   8.  Allocatable Variants  . . . . . . . . . . . . . . . . . . . .   8
   9.  Blocked Variants  . . . . . . . . . . . . . . . . . . . . . .   9
   10. Pure Variant Labels . . . . . . . . . . . . . . . . . . . . .  10
   11. Reflexive Variants  . . . . . . . . . . . . . . . . . . . . .  11
   12. Limiting Allocatable Variants by Subtyping  . . . . . . . . .  12
   13. Allowing Mixed Originals  . . . . . . . . . . . . . . . . . .  14
   14. Handling Out-of-Repertoire Variants . . . . . . . . . . . . .  15
   15. Conditional Variants  . . . . . . . . . . . . . . . . . . . .  16
   16. Making Conditional Variants Well Behaved  . . . . . . . . . .  18
   17. Variants for Sequences  . . . . . . . . . . . . . . . . . . .  19
   18. Corresponding XML Notation  . . . . . . . . . . . . . . . . .  21
   19. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  22
   20. Security Considerations . . . . . . . . . . . . . . . . . . .  23
   21. References  . . . . . . . . . . . . . . . . . . . . . . . . .  23
     21.1.  Normative References . . . . . . . . . . . . . . . . . .  23
     21.2.  Informative References . . . . . . . . . . . . . . . . .  23
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  24
   Author&#39;s Address  . . . . . . . . . . . . . . . . . . . . . . . .  24
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Label Generation Rulesets (LGRs) that define the set of permissible labels may be applied to identifier systems that rely on labels, such as the Domain Name System (DNS) [RFC1034] [RFC1035]. To date, LGRs have mostly been used to define policies for implementing Internationalized Domain Names (IDNs) using IDNA2008 [RFC5890] [RFC5891] [RFC5892] [RFC5893] [RFC5894] in the DNS. This document aims to discuss the generation of LGRs for such circumstances, but the techniques and considerations here are almost certainly applicable to a wider range of internationalized identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
許可されるラベルのセットを定義するラベル生成ルールセット（LGR）は、ドメインネームシステム（DNS）[RFC1034] [RFC1035]などのラベルに依存する識別子システムに適用できます。現在まで、LGRは主に、DNSでIDNA2008 [RFC5890] [RFC5891] [RFC5892] [RFC5893] [RFC5894]を使用して国際化ドメイン名（IDN）を実装するためのポリシーを定義するために使用されています。このドキュメントは、このような状況でのLGRの生成について説明することを目的としていますが、ここでの技法と考慮事項は、ほぼ確実に、より広範な国際化識別子に適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to determining whether a given label is eligible, LGRs may also define the condition under which alternate representations of these labels, so-called &#34;variant labels&#34;, may exist and their status (disposition). In the most general sense, variant labels are typically labels that are either visually or semantically indistinguishable from another label in the context of the writing system or script supported by the LGR. Unlike merely similar labels, where there may be a measurable degree of similarity, variant labels considered here represent a form of equivalence in meaning or appearance. What constitutes an appropriate variant in any writing system or given context, particularly in the DNS, is assumed to have been determined ahead of time and therefore is not a subject of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRは、特定のラベルが適格かどうかを判断するだけでなく、これらのラベルの代替表現、いわゆる「バリアントラベル」が存在する条件とそのステータス（性質）も定義します。最も一般的な意味では、バリアントラベルは通常、LGRでサポートされている書記体系またはスクリプトのコンテキストでは、視覚的または意味的に別のラベルと区別できないラベルです。測定可能な程度の類似性が存在する可能性のある単なる類似のラベルとは異なり、ここで考慮されるバリアントラベルは、意味または外観における同等の形式を表します。書記法や特定のコンテキスト、特にDNSで適切なバリアントを構成するものは、事前に決定されていると想定されるため、このドキュメントの主題ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once identified, variant labels are typically delegated to some entity together with the applied-for label, or permanently reserved, based on the disposition derived from the LGR. Correctly defined, variant labels can improve the security of an LGR, yet successfully defining variant rules for an LGR so that the result is well behaved is not always trivial. This document describes the basic considerations and constraints that must be taken into account and gives examples of what might be use cases for different types of variant specifications in an LGR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別されると、バリアントラベルは通常、LGRから導出された後処理に基づいて、適用されるラベルと一緒に一部のエンティティに委任されるか、永続的に予約されます。正しく定義されたバリアントラベルは、LGRのセキュリティを向上させることができますが、LGRのバリアントルールを正常に定義できるため、結果が適切に動作します。このドキュメントでは、考慮しなければならない基本的な考慮事項と制約について説明し、LGRのさまざまなタイプのバリアント仕様のユースケースの例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not address whether variants are an appropriate means to solve any given issue or the basis on which they should be defined. It is intended to explain in more detail the effects of various declarations and the trade-offs in making design choices. It implicitly assumes that any LGR will be expressed using the XML representation defined in [RFC7940] and therefore conforms to any requirements stated therein. Purely for clarity of exposition, examples in this document use a more compact notation than the XML syntax defined in [RFC7940]. However, the reader is expected to have some familiarity with the concepts described in that RFC (see Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、バリアントが特定の問題を解決するための適切な手段であるかどうか、またはそれらを定義する必要がある根拠については触れていません。設計の選択を行う際のさまざまな宣言とトレードオフの影響をより詳細に説明することを目的としています。 LGRは[RFC7940]で定義されたXML表現を使用して表現されるため、そこに記載されている要件に準拠していると暗黙的に想定しています。説明を明確にするために、このドキュメントの例では、[RFC7940]で定義されているXML構文よりも簡潔な表記法を使用しています。ただし、読者はそのRFCで説明されている概念にある程度の知識があることが期待されます（セクション4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user of any identifier system, such as the DNS, interacts with it in the context of labels; variants are experienced as variant labels, i.e., two (or more) labels that are functionally &#34;same as&#34; under the conventions of the writing system used, even though their code point sequences are different. An LGR specification, on the other hand, defines variant mappings between code points and, only in a secondary step, derives the variant labels from these mappings. For a discussion of this process, see [RFC7940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DNSなどの識別子システムのユーザーは、ラベルのコンテキストでそれと対話します。バリアントは、バリアントラベルとして使用されます。つまり、コードポイントシーケンスが異なっていても、使用されている書記体系の規則に従って機能的に「同じ」である2つ（またはそれ以上）のラベルです。一方、LGR仕様は、コードポイント間のバリアントマッピングを定義し、2次ステップでのみ、これらのマッピングからバリアントラベルを導出します。このプロセスの説明については、[RFC7940]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The designer of an LGR can control whether some or all of the variant labels created from an original label should be allocatable, i.e., available for allocation (to the original applicant), or whether some or all of these labels should be blocked instead, i.e., remain not allocatable (to anyone). This document describes how this choice of label disposition is accomplished (see Section 7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRの設計者は、元のラベルから作成されたバリアントラベルの一部またはすべてを割り当て可能にする（つまり、元の申請者に割り当てる）か、またはこれらのラベルの一部またはすべてを代わりにブロックするかを制御できます。 、（誰にでも）割り当て可能ではありません。このドキュメントでは、このラベル配置の選択方法について説明します（セクション7を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of desired label disposition would be based on the expectations of the users of the particular zone; it is not the subject of this document. Likewise, this document does not address the possibility of an LGR defining custom label dispositions. Instead, this document suggests ways of designing an LGR to achieve the selected design choice for handling variants in the context of the two standard label dispositions: &#34;allocatable&#34; and &#34;blocked&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
希望するラベルの配置の選択は、特定のゾーンのユーザーの期待に基づいています。このドキュメントの主題ではありません。同様に、このドキュメントでは、LGRがカスタムラベルの処理を定義する可能性については触れていません。代わりに、このドキュメントでは、「割り当て可能」と「ブロック」の2つの標準ラベル配置のコンテキストでバリアントを処理するために選択された設計選択を実現するLGRの設計方法を提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information in this document is based on operational experience gained in developing LGRs for a wide number of languages and scripts using RFC 7940. This information is provided here as a benefit to the wider community. It does not alter or change the specification found in RFC 7940 in any way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの情報は、RFC 7940を使用してさまざまな言語とスクリプトのLGRを開発する際に得られた運用経験に基づいています。この情報は、より広いコミュニティへのメリットとしてここに提供されています。 RFC 7940にある仕様を変更または変更することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Variant Relations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. バリアント関係
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variant relation is fundamentally a &#34;same as&#34; relation; in other words, it is an equivalence relation. Now, the strictest sense of &#34;same as&#34; would be equality, and for any equality, we have both symmetry
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントリレーションは、基本的に「同じ」リレーションです。つまり、同値関係です。今、「と同じ」の最も厳密な意味は平等であり、どんな平等でも、私たちは両方の対称性を持っています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     A = B =&gt; B = A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and transitivity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
と推移性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     A = B and B = C =&gt; A = C
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variant relation with its functional sense of &#34;same as&#34; must really satisfy the same constraint. Once we say A is the &#34;same as&#34; B, we also assert that B is the &#34;same as&#34; A. In this document, the symbol &#34;~&#34; means &#34;has a variant relation with&#34;. Thus, we get
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「同じ」という機能的意味を持つバリアント関係は、実際に同じ制約を満たす必要があります。 Aが「同じ」Bであると言うと、Bも「同じ」Aであると断言します。このドキュメントでは、記号「〜」は「とバリアント関係がある」ことを意味します。したがって、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     A ~ B =&gt; B ~ A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Likewise, if we make the same claim for B and C (B ~ C), then we get A ~ C, because if B is the &#34;same as&#34; both A and C, then A must be the &#34;same as&#34; C:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、BとC（B〜C）について同じ主張をすると、A〜Cが得られます。これは、BがAとCの両方と「同じ」である場合、Aは「同じ」Cでなければならないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     A ~ B and B ~ C =&gt; A ~ C
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Symmetry and Transitivity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 対称性と推移性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not all potential relations between labels constitute equivalence, and those that do not are not transitive and may not be symmetric. For example, the degree to which labels are confusable is not transitive: two labels can be confusingly similar to a third without necessarily being confusable with each other, such as when the third one has a shape that is &#34;in between&#34; the other two. In contrast, a relation based on identical or effectively identical appearance would meet the criterion of transitivity, and we would consider it a variant relation. Examples of variant relations include other forms of equivalence, such as semantic equivalence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベル間のすべての潜在的な関係が同値を構成するわけではありません。また、ラベルの関係は推移的ではなく、対称的ではない場合があります。たとえば、ラベルが混乱しやすい程度は推移的ではありません。2番目のラベルが他の2つのラベルの「間にある」形状を持っている場合など、2つのラベルは必ずしも互いに混乱していなくても、3番目のラベルと紛らわしく似ている場合があります。対照的に、同一または実質的に同一の外観に基づく関係は推移性の基準を満たし、バリアント関係と見なします。バリアント関係の例には、意味的同値などの他の形式の同値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using [RFC7940], a set of mappings could be defined that is neither symmetric nor transitive; such a specification would be formally valid. However, a symmetric and transitive set of mappings is strongly preferred as a basis for an LGR, not least because of the benefits from an implementation point of view; for example, if all mappings are symmetric and transitive, it greatly simplifies the check for collisions between labels with variants. For this reason, we will limit the discussion in this document to those relations that are symmetric and transitive. Incidentally, it is often straightforward to verify mechanically whether an LGR is symmetric and/or transitive and to compute any mappings required to make it so (but see Section 15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]を使用すると、対称的でも推移的でもない一連のマッピングを定義できます。このような仕様は正式に有効になります。ただし、対称で推移的なマッピングのセットは、特に実装の観点からの利点があるため、LGRの基礎として強く推奨されます。たとえば、すべてのマッピングが対称的で推移的である場合、バリアントを持つラベル間の衝突のチェックが大幅に簡略化されます。このため、このドキュメントでの説明は、対称的で推移的な関係に限定します。ちなみに、LGRが対称的または推移的であるかどうかを機械的に確認し、それを行うために必要なマッピングを計算することは簡単です（ただし、セクション15を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. A Word on Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 表記について
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 [RFC7940] defines an XML schema for Label Generation Rulesets in general and variant code points and sequences in particular (see Section 18). That notation is rather verbose and can easily obscure salient features to anyone not trained to read XML. For this reason, this document uses a symbolic shorthand notation in presenting the examples for discussion. This shorthand is merely a didactic tool for presentation and is not intended as an alternative to or replacement for the XML syntax that is used in formally specifying an LGR under [RFC7940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
[RFC7940]は、一般的なラベル生成ルールセット、特にバリアントコードポイントとシーケンスのXMLスキーマを定義しています（セクション18を参照）。この表記はかなり冗長であり、XMLを読み取るように訓練されていない人には、目立つ機能を簡単に不明瞭にする可能性があります。このため、このドキュメントでは、ディスカッションの例を示す際に記号による簡略表記を使用しています。この略記は単に提示のための教訓的なツールであり、[RFC7940]の下でLGRを正式に指定する際に使用されるXML構文の代替または代替として意図されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When it comes time to capture the LGR in a formal definition, the notation used for any of the examples in this document can be converted to the XML format as described in Section 18.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRを正式な定義で取り込むときが来たら、このドキュメントの例で使用されている表記法を、セクション18で説明されているXML形式に変換できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Variant Mappings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. バリアントマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, we have treated variant relations as simple &#34;same as&#34; relations, ignoring that each relation representing equivalence would consist of a symmetric pair of reciprocal mappings. In this document, the symbol &#34;--&gt;&#34; means &#34;maps to&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまで、等価関係を表す各関係が対称マッピングの相互マッピングで構成されることを無視して、バリアント関係を単純な「同じ」関係として扱いました。このドキュメントでは、記号「-&gt;」は「マップ先」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A ~ B =&gt; A --&gt; B, B --&gt; A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an LGR, these mappings are not defined directly between labels but between code points (or code point sequences; see Section 17). In the transitive case, given
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRでは、これらのマッピングはラベル間ではなくコードポイント（またはコードポイントシーケンス、セクション17を参照）間で直接定義されていません。推移的なケースでは、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A ~ B =&gt; A --&gt; B, B --&gt; A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A ~ C =&gt; A --&gt; C, C --&gt; A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
we also get
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちも得る
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   B ~ C =&gt; B --&gt; C, C --&gt; B
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for a total of six possible mappings. Conventionally, these are listed in tables in order of the source code point, like so:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
合計6つの可能なマッピング。従来、次のように、これらはソースコードポイントの順にテーブルにリストされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     A --&gt; B
     A --&gt; C
     B --&gt; A
     B --&gt; C
     C --&gt; A
     C --&gt; B
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we can see, A, B, and C can each be mapped two ways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ご覧のとおり、A、B、Cはそれぞれ2つの方法でマッピングできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Variant Labels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. バリアントラベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To create a variant label, each code point in the original label is successively replaced by all variant code points defined by a mapping from the original code point. For a label AAA (the letter &#34;A&#34; three times), the variant labels (given the mappings from the transitive example above) would be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベルを作成するには、元のラベルの各コードポイントを、元のコードポイントからのマッピングで定義されたすべてのバリアントコードポイントに順次置き換えます。ラベルAAA（文字 &#34;A&#34;が3回）の場合、バリアントラベル（上記の推移的な例のマッピングがある場合）は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAB ABA ABB BAA BAB BBA BBB AAC ... CCC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
お父さんまたはお父さん... CCC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, we have merely defined what the variant labels are, but we have not considered their possible dispositions. In the next section, we discuss how to set up the variant mappings so that some variant labels are mutually exclusive (blocked), but some may be allocated to the same applicant as the original label (allocatable).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、バリアントラベルとは何かを定義しただけですが、考えられる性質を考慮していません。次のセクションでは、バリアントマッピングを設定して、一部のバリアントラベルを相互に排他的（ブロック）にする方法について説明しますが、一部は元のラベルと同じ申請者に割り当てることができます（割り当て可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Variant Types and Label Dispositions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. バリアントタイプとラベルの配置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume we wanted to allow a variant relation between code points O and A, and perhaps between O and B or O and C as well. Assuming transitivity, this would give us:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードポイントOとAの間、およびおそらくOとBまたはOとCの間のバリアント関係を許可したいと仮定します。推移性を仮定すると、これにより次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     O ~ A ~ B ~ C
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, further assume that we would like to distinguish the case where someone applies for OOO from the case where someone applies for the label ABC. In this case, we would like to allocate only the applied-for label OOO, but in the latter case, we would like to also allow the allocation of either the label OOO or the variant label ABC, or both, but not of any of the other possible variant labels, like OAO, BCO, or the like. (A real-world example might be the case where O represents an unaccented letter, while A, B, and C might represent various accented forms of the same letter. Because unaccented letters are a common fallback, there might be a desire to allocate an unaccented label as a variant, but not the other way around.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、さらに、誰かがOOOを申請する場合と、誰かがラベルABCを申請する場合とを区別したいとします。この場合、適用されたラベルOOOのみを割り当てますが、後者の場合は、ラベルOOOまたはバリアントラベルABC、あるいはその両方の割り当ても許可しますが、いずれの割り当ても許可しません。 OAO、BCOなどの他の可能なバリアントラベル。 （実際の例では、Oがアクセントなしの文字を表し、A、B、およびCが同じ文字のさまざまなアクセント付き形式を表す場合があります。アクセントなしの文字は一般的なフォールバックであるため、アクセント記号のないラベルをバリアントとして使用しますが、その逆はできません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 How would we specify such a distinction? The answer lies in labeling the mappings A --&gt; O, B --&gt; O, and C --&gt; O with the type &#34;allocatable&#34; and the mappings O --&gt; A, O --&gt; B, and O --&gt; C with the type &#34;blocked&#34;. In this document, the symbol &#34;x--&gt;&#34; means &#34;maps with type blocked&#34;, and the symbol &#34;a--&gt;&#34; means &#34;maps with type allocatable&#34;. Thus:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
そのような区別をどのように指定しますか？答えは、マッピングA-&gt; O、B-&gt; O、C-&gt; Oにタイプ「割り当て可能」とマッピングO-&gt; A、O-&gt; B、O-をラベル付けすることです。 &gt;「ブロック」タイプのC。このドキュメントでは、記号「x-&gt;」は「タイプがブロックされたマップ」を意味し、記号「a-&gt;」は「タイプが割り当て可能なマップ」を意味します。したがって：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
O x--&gt; A O x--&gt; B O x--&gt; C A a--&gt; O B a--&gt; O C a--&gt; O
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
お ｘーー＞ あ お ｘーー＞ Ｂ お ｘーー＞ Ｃ あ あーー＞ お Ｂ あーー＞ お Ｃ あーー＞ お
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When we generate all permutations of labels, we use mappings with different types depending on which code points we start from. The set of all permuted variant labels would be the same, but the disposition of the variant label depends on which label we start from (we call that label the &#34;original&#34; or &#34;applied-for&#34; label).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベルのすべての順列を生成するとき、開始するコードポイントに応じて、異なるタイプのマッピングを使用します。並べ替えられたすべてのバリアントラベルのセットは同じですが、バリアントラベルの処理は、開始するラベルによって異なります（そのラベルを「オリジナル」または「適用された」ラベルと呼びます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In creating an LGR with variants, all variant mappings should always be labeled with a type ([RFC7940] does not formally require a type, but any well-behaved LGR would be fully typed). By default, these types correspond directly to the dispositions for variant labels, with the most restrictive type determining the disposition of the variant label. However, as we shall see later, it is sometimes useful to assign types from a wider array of values than the final dispositions for the labels and then define explicitly how to derive label dispositions from them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントを含むLGRを作成する場合、すべてのバリアントマッピングは常にタイプでラベル付けする必要があります（[RFC7940]は正式にタイプを必要としませんが、正常に動作するLGRは完全にタイプされます）。デフォルトでは、これらのタイプはバリアントラベルの後処理に直接対応し、最も限定的なタイプがバリアントラベルの後処理を決定します。ただし、後で説明するように、ラベルの最終的な配置よりも広い値の配列から型を割り当て、それらからラベルの配置を導き出す方法を明示的に定義することが役立つ場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Allocatable Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 割り当て可能なバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we start with AAA and use the mappings from Section 7, the permutation OOO will be the result of applying the mapping A a--&gt; O at each code point. That is, only mappings with type &#34;a&#34; (allocatable) were used. To know whether we can allocate both the label OOO and the original label AAA, we track the types of the mappings used in generating the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AAAから始めて、セクション7のマッピングを使用する場合、順列OOOは、各コードポイントでマッピングA a-&gt; Oを適用した結果になります。つまり、タイプ &#34;a&#34;（割り当て可能）のマッピングのみが使用されました。ラベルOOOと元のラベルAAAの両方を割り当てることができるかどうかを知るために、ラベルの生成に使用されるマッピングのタイプを追跡します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We record the variant types for each of the variant mappings used in creating the permutation in an ordered list. Such an ordered list of variant types is called a &#34;variant type list&#34;. In running text, we often show it enclosed in square brackets. For example, [a x -] means the variant label was derived from a variant mapping with the &#34;a&#34; variant type in the first code point position, &#34;x&#34; in the second code point position, and the original code point in the third position (&#34;-&#34; means &#34;no variant mapping&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
順列を作成する際に使用されたバリアントマッピングごとに、バリアントタイプを順序付きリストに記録します。このようなバリアント型の順序付きリストは、「バリアント型リスト」と呼ばれます。実行中のテキストでは、角括弧で囲まれて表示されることがよくあります。たとえば、[ax-]は、バリアントラベルが最初のコードポイント位置に「a」バリアントタイプ、2番目のコードポイント位置に「x」、3番目の位置に元のコードポイントを含むバリアントマッピングから派生したことを意味します。 （「-」は「バリアントマッピングなし」を意味します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For our example permutation, we get the following variant type list (brackets dropped):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この順列の例では、次のバリアント型リスト（角括弧は削除されます）を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     AAA --&gt; OOO : a a a
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the variant type list, we derive a &#34;variant type set&#34;, denoted by curly braces, that contains an unordered set of unique variant types in the variant type list. For the variant type list for the given permutation, [a a a], the variant type set is { a }, which has a single element &#34;a&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントタイプリストから、中括弧で示される「バリアントタイプセット」を導出します。これには、バリアントタイプリスト内の一意のバリアントタイプの順序付けされていないセットが含まれます。指定された順列[a a a]のバリアントタイプリストの場合、バリアントタイプセットは{a}であり、単一の要素 &#34;a&#34;を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deciding whether to allow the allocation of a variant label then amounts to deriving a disposition for the variant label from the variant type set created from the variant mappings that were used to create the label. For example, the derivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベルの割り当てを許可するかどうかの決定は、ラベルの作成に使用されたバリアントマッピングから作成されたバリアントタイプセットからバリアントラベルの後処理を導出することになります。たとえば、導出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;all variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;allocatable&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would allow OOO to be allocated, because the types of all variant mappings used to create that variant label from AAA are &#34;a&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AAAからバリアントラベルを作成するために使用されるすべてのバリアントマッピングのタイプは「a」であるため、OOOを割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;all-variants&#34; condition is tolerant of an extra &#34;-&#34; in the variant set (unlike the &#34;only-variants&#34; condition described in Section 10). So, had we started with AOA, OAA, or AAO, the variant set for the permuted variant OOO would have been { a - } because in each case one of the code points remains the same code point as the original. The &#34;-&#34; means that because of the absence of a mapping O --&gt; O, there is no variant type for the O in each of these labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「すべてのバリアント」条件は、バリアントセットの余分な「-」を許容します（セクション10で説明されている「唯一のバリアント」条件とは異なります）。したがって、AOA、OAA、またはAAOから始めた場合、置換されたバリアントOOOのバリアントセットは{a-}になります。どちらの場合も、コードポイントの1つが元のコードポイントと同じままであるためです。 「-」は、マッピングO-&gt; Oがないため、これらの各ラベルにOのバリアントタイプがないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;all-variants&#34; = &#34;a&#34; condition ignores the &#34;-&#34;, so using the derivation from above, we find that OOO is an allocatable variant for each of the labels AOA, OAA, or AAO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;all-variants&#34; = &#34;a&#34;条件は &#34;-&#34;を無視するため、上記の派生を使用して、OOAはラベルAOA、OAA、またはAAOのそれぞれに割り当て可能なバリアントであることがわかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allocatable variant labels, especially large numbers of allocatable variants per label, incur a certain cost to users of the LGR. A well-behaved LGR will minimize the number of allocatable variants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
割り当て可能なバリアントラベル、特にラベルごとに多数の割り当て可能なバリアントは、LGRのユーザーに一定のコストをもたらします。適切に動作するLGRは、割り当て可能なバリアントの数を最小限に抑えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Blocked Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. ブロックされたバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Blocked variants are not available to another registrant. They therefore protect the applicant of the original label from someone else registering a label that is the &#34;same as&#34; under some user-perceived metric. Blocked variants can be a useful tool even for scripts for which no allocatable labels are ever defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックされたバリアントは、別の登録者は利用できません。したがって、それらは、ユーザーが認識しているメトリックの下で「同じ」であるラベルを登録している誰かから元のラベルの申請者を保護します。ブロックされたバリアントは、割り当て可能なラベルが定義されていないスクリプトの場合でも便利なツールです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we start with OOO and use the mappings from Section 7, the permutation AAA will have been the result of applying only mappings with type &#34;blocked&#34;, and we cannot allocate the label AAA, only the original label OOO. This corresponds to the following derivation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OOOから始めて、セクション7のマッピングを使用する場合、置換AAAはタイプ「blocked」のマッピングのみを適用した結果であり、ラベルAAAを割り当てることはできず、元のラベルOOOのみを割り当てます。これは次の派生に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;any variants&#34; = &#34;x&#34; =&gt; set label disposition to &#34;blocked&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, to prevent allocating ABO as a variant label for AAA, we need to make sure that the mapping A --&gt; B has been defined with type &#34;blocked&#34;, as in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、ABOをAAAのバリアントラベルとして割り当てないようにするには、次のように、マッピングA-&gt; Bがタイプ「blocked」で定義されていることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A x--&gt; B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A x-&gt; B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
so that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのため
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA --&gt; ABO: - x a.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AAA-&gt; ABO：-x a。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the set {x a} contains at least one &#34;x&#34; and satisfies the derivation of a blocked disposition for ABO when AAA is applied for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、セット{x a}は少なくとも1つの「x」を含み、AAAが適用されたときにABOのブロックされた処理の導出を満たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an LGR results in a symmetric and transitive set of variant labels, then the task of determining whether a label or its variants collide with another label or its variants can be implemented very efficiently. Symmetry and transitivity imply that sets of labels that are mutual variants of each other are disjoint from all other such sets. Only labels within the same set can be variants of each other. Identifying the variant set can be an O(1) operation, and enumerating all variants is not necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LGRが対称的で推移的なバリアントラベルのセットをもたらす場合、ラベルまたはそのバリアントが別のラベルまたはそのバリアントと衝突するかどうかを決定するタスクは、非常に効率的に実装できます。対称性と推移性は、相互の相互変形であるラベルのセットが、他のすべてのそのようなセットから切り離されていることを意味します。同じセット内のラベルのみが相互のバリアントになることができます。バリアントセットの識別はO（1）操作である可能性があり、すべてのバリアントを列挙する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Pure Variant Labels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 純粋なバリアントラベル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, if we wanted to prevent allocation of AOA when we start from AAA, we would need a rule disallowing a mix of original code points and variant code points; this is easily accomplished by use of the &#34;only-variants&#34; qualifier, which requires that the label consist entirely of variants and that all the variants are from the same set of types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、AAAから開始するときにAOAの割り当てを防止したい場合は、元のコードポイントとバリアントコードポイントの混在を許可しないルールが必要になります。これは、 &#34;only-variants&#34;修飾子を使用して簡単に実行できます。これには、ラベルが完全にバリアントで構成され、すべてのバリアントが同じタイプのセットからのものである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;only-variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;allocatable&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two code points A in AOA are not arrived at by variant mappings, because the code points are unchanged and no variant mappings are defined for A --&gt; A. So, in our example, the set of variant mapping types is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AOAの2つのコードポイントAは、バリアントマッピングでは到達しません。コードポイントは変更されておらず、A-&gt; Aのバリアントマッピングが定義されていないため、この例では、バリアントマッピングタイプのセットは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     AAA --&gt; AOA:  - a -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
but unlike the &#34;all-variants&#34; condition, &#34;only-variants&#34; requires a variant type set { a } corresponding to a variant type list [a a a] (no - allowed). By adding a final derivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、「all-variants」条件とは異なり、「only-variants」には、バリアントタイプリスト[a a a]に対応するバリアントタイプセット{a}が必要です（許可されていません）。最終派生を追加することにより
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     else if &#34;any-variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;blocked&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and executing that derivation only on any remaining labels, we disallow AOA when starting from AAA but still allow OOO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのラベルでのみその派生を実行すると、AAAからの開始時にAOAは許可されませんが、OOOは許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Derivation conditions are always applied in order, with later derivations only applying to labels that did not match any earlier conditions, as indicated by the use of &#34;else&#34; in the last example. In other words, they form a cascade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後の例で「else」を使用して示されているように、派生条件は常に順番に適用され、後の派生は以前の条件に一致しなかったラベルにのみ適用されます。つまり、カスケードを形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Reflexive Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 再帰バリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But what if we started from AOA? We would expect the original label OOO to be allocatable, but, using the mappings from Section 7, the variant type set would be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、AOAから始めた場合はどうでしょうか。元のラベルOOOは割り当て可能であると予想しますが、セクション7のマッピングを使用すると、バリアントタイプセットは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     AOA --&gt; OOO:  a - a
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
because the middle O is unchanged from the original code point. Here is where we use a reflexive mapping. Realizing that O is the &#34;same as&#34; O, we can map it to itself. This is normally redundant, but adding an explicit reflexive mapping allows us to specify a disposition on that mapping:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中央のOは元のコードポイントから変更されていないためです。ここで、再帰マッピングを使用します。 Oは「同じ」Oであることを認識し、それをそれ自体にマッピングできます。これは通常冗長ですが、明示的な再帰マッピングを追加すると、そのマッピングの性質を指定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
O a--&gt; O
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
お あーー＞ お
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With that, the variant type list for AOA --&gt; OOO becomes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、AOA-&gt; OOOのバリアントタイプリストは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     AOA --&gt; OOO: a a a
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and the label OOO again passes the derivation condition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベルOOOは再び派生条件を渡します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;only-variants&#34; = &#34;a&#34; =&gt; set label disposition to &#34;allocatable&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
as desired. This use of reflexive variants is typical whenever derivations with the &#34;only-variants&#34; qualifier are used. If any code point uses a reflexive variant, a well-behaved LGR would specify an appropriate reflexive variant for all code points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
望んだ通りに。この &#34;再帰バリアント&#34;の使用は、 &#34;only-variants&#34;修飾子を使用した派生が使用される場合は常に一般的です。コードポイントが再帰バリアントを使用する場合、正常に動作するLGRは、すべてのコードポイントに適切な再帰バリアントを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Limiting Allocatable Variants by Subtyping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. サブタイプによる割り当て可能なバリアントの制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we have seen, the number of variant labels can potentially be large, due to combinatorics. Sometimes it is possible to divide variants into categories and to stipulate that only variant labels with variants from the same category should be allocatable. For some LGRs, this constraint can be implemented by a rule that disallows code points from different categories to occur in the same allocatable label. For other LGRs, the appropriate mechanism may be dividing the allocatable variants into subtypes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまで見てきたように、組み合わせ論のため、バリアントラベルの数は潜在的に大きくなる可能性があります。バリアントをカテゴリに分割し、同じカテゴリのバリアントを持つバリアントラベルのみを割り当て可能にするように規定することが可能な場合があります。一部のLGRでは、この制約は、異なるカテゴリのコードポイントが同じ割り当て可能なラベルで発生することを禁止するルールによって実装できます。他のLGRの場合、適切なメカニズムは、割り当て可能なバリアントをサブタイプに分割することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To recap, in the standard case, a code point C can have (up to) two types of variant mappings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、標準的なケースでは、コードポイントCは（最大で）2種類のバリアントマッピングを持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X C a--&gt; A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x-&gt; X C a-&gt; A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where a--&gt; means a variant mapping with type &#34;allocatable&#34; and x--&gt; means &#34;blocked&#34;. For the purpose of the following discussion, we name the target code point with the corresponding uppercase letter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、a-&gt;は「割り当て可能」タイプのバリアントマッピングを意味し、x-&gt;は「ブロック」を意味します。以下の説明のために、ターゲットコードポイントに対応する大文字の名前を付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subtyping allows us to distinguish among different types of allocatable variants. For example, we can define three new types: &#34;s&#34;, &#34;t&#34;, and &#34;b&#34;. Of these, &#34;s&#34; and &#34;t&#34; are mutually incompatible, but &#34;b&#34; is compatible with either &#34;s&#34; or &#34;t&#34; (in this case, &#34;b&#34; stands for &#34;both&#34;). A real-world example for this might be variant mappings appropriate for &#34;simplified&#34; or &#34;traditional&#34; Chinese variants, or appropriate for both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイピングにより、割り当て可能なバリアントのさまざまなタイプを区別できます。たとえば、「s」、「t」、「b」の3つの新しいタイプを定義できます。これらのうち、「s」と「t」は相互に互換性がありませんが、「b」は「s」または「t」と互換性があります（この場合、「b」は「両方」を表します）。これの実際の例は、「簡体字」または「伝統的」な中国の変種、または両方に適した変種のマッピングです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With subtypes defined as above, a code point C might have (up to) four types of variant mappings
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のようにサブタイプが定義されている場合、コードポイントCには、最大4つのタイプのバリアントマッピングが含まれる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X C s--&gt; S C t--&gt; T C b--&gt; B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x-&gt; X C s-&gt; S C t-&gt; T C b-&gt; B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and explicit reflexive mappings of one of these types
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのタイプの1つの明示的再帰マッピング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C s--&gt; C C t--&gt; C C b--&gt; C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C s-&gt; C C t-&gt; C C b-&gt; C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As before, all mappings must have one and only one type, but each code point may map to any number of other code points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前と同様に、すべてのマッピングは1つのタイプのみを持つ必要がありますが、各コードポイントは他の任意の数のコードポイントにマッピングできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define the compatibility of &#34;b&#34; with &#34;t&#34; or &#34;s&#34; by our choice of derivation conditions as follows
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「b」と「t」または「s」の互換性は、派生条件の選択によって次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;any-variants&#34; = &#34;x&#34; =&gt;  blocked
     else if &#34;only-variants&#34; = &#34;s&#34; or &#34;b&#34; =&gt;  allocatable
     else if &#34;only-variants&#34; = &#34;t&#34; or &#34;b&#34; =&gt;  allocatable
     else if &#34;any-variants&#34; = &#34;s&#34; or &#34;t&#34; or &#34;b&#34; =&gt;  blocked
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An original label of four code points
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4つのコードポイントのオリジナルラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CCCC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
may have many variant labels, such as this example listed with its corresponding variant type list:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例のように、対応するバリアントタイプリストとともにリストされた多くのバリアントラベルがある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     CCCC --&gt; XSTB : x s t b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This variant label is blocked because to get from C to B required x--&gt;. (Because variant mappings are defined for specific source code points, we need to show the starting label for each of these examples, not merely the code points in the variant label.) The variant label
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CからBに移動するにはx-&gt;が必要なため、このバリアントラベルはブロックされます。 （バリアントマッピングは特定のソースコードポイントに対して定義されているため、バリアントラベルのコードポイントだけでなく、これらの各例の開始ラベルを表示する必要があります。）バリアントラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     CCCC --&gt; SSBB : s s b b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is allocatable, because the variant type list contains only allocatable mappings of subtype &#34;s&#34; or &#34;b&#34;, which we have defined as being compatible by our choice of derivations. The actual set of variant types {s, b} has only two members, but the examples are easier to follow if we list each type. The label
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント型リストにはサブタイプ「s」または「b」の割り当て可能なマッピングのみが含まれるため、割り当て可能です。これは、派生の選択によって互換性があると定義されています。バリアント型の実際のセット{s、b}には2つのメンバーしかありませんが、各型をリストすると、例を理解しやすくなります。ラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     CCCC --&gt; TTBB : t t b b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is again allocatable, because the variant type set {t, b} contains only allocatable mappings of the mutually compatible allocatable subtypes &#34;t&#34; or &#34;b&#34;. In contrast,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアント型セット{t、b}には相互に互換性のある割り当て可能なサブタイプ &#34;t&#34;または &#34;b&#34;の割り当て可能なマッピングのみが含まれているため、これも割り当て可能です。対照的に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     CCCC --&gt; SSTT : s s t t
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is not allocatable, because the type set contains incompatible subtypes &#34;t&#34; and &#34;s&#34; and thus would be blocked by the final derivation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプセットには互換性のないサブタイプ &#34;t&#34;と &#34;s&#34;が含まれているため、最終的な派生によってブロックされるため、は割り当て可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The variant labels
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     CCCC --&gt; CSBB : c s b b
     CCCC --&gt; CTBB : c t b b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
are only allocatable based on the subtype for the C --&gt; C mapping, which is denoted here by &#34;c&#34; and (depending on what was chosen for the type of the reflexive mapping) could correspond to &#34;s&#34;, &#34;t&#34;, or &#34;b&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C-&gt; Cマッピングのサブタイプに基づいてのみ割り当て可能であり、ここでは「c」で示され、（再帰マッピングのタイプに選択されたものに応じて）「s」、「t」、または「b」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the subtype is &#34;s&#34;, the first of these two labels is allocatable; if it is &#34;t&#34;, the second of these two labels is allocatable; if it is &#34;b&#34;, both labels are allocatable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプが「s」の場合、これら2つのラベルの最初のラベルは割り当て可能です。 「t」の場合、これら2つのラベルの2番目は割り当て可能です。 「b」の場合、両方のラベルを割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So far, the scheme does not seem to have brought any huge reduction in allocatable variant labels, but that is because we tacitly assumed that C could have all three types of allocatable variants &#34;s&#34;, &#34;t&#34;, and &#34;b&#34; at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これまでのところ、このスキームでは割り当て可能なバリアントラベルが大幅に削減されたようには見えませんが、これは、Cが3つのタイプの割り当て可能なバリアント「s」、「t」、および「b」をすべて同時。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a real-world example, the types &#34;s&#34;, &#34;t&#34;, and &#34;b&#34; are assigned so that each code point C normally has, at most, one non-reflexive variant mapping labeled with one of these subtypes, and all other mappings would be assigned type &#34;x&#34; (blocked). This holds true for most code points in existing tables (such as those used in current IDN Top-Level Domains (TLDs)), although certain code points have exceptionally complex variant relations and may have an extra mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際の例では、タイプ &#34;s&#34;、 &#34;t&#34;、および &#34;b&#34;が割り当てられているため、各コードポイントCには通常、最大でこれらのサブタイプの1つでラベル付けされた1つの非再帰バリアントマッピングがあり、すべての他のマッピングにはタイプ &#34;x&#34;（ブロック）が割り当てられます。これは、既存のテーブルのほとんどのコードポイント（現在のIDNトップレベルドメイン（TLD）で使用されているものなど）にも当てはまりますが、特定のコードポイントには非常に複雑なバリアント関係があり、追加のマッピングがある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Allowing Mixed Originals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 混合オリジナルを許可する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the desire is to allow original labels (but not variant labels) that are s/t mixed, then the scheme needs to be slightly refined to distinguish between reflexive and non-reflexive variants. In this document, the symbol &#34;r-n&#34; means &#34;a reflexive (identity) mapping of type &#39;n&#39;&#34;. The reflexive mappings of the preceding section thus become:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
元のラベル（バリアントラベルではなく）をs / t混合することを許可する場合は、スキーマを少し洗練して、再帰的バリアントと非再帰的バリアントを区別する必要があります。このドキュメントでは、記号「r-n」は「タイプ「n」の再帰的（アイデンティティ）マッピング」を意味します。したがって、前のセクションの再帰マッピングは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C r-s--&gt; C C r-t--&gt; C C r-b--&gt; C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C r-s-&gt; C C r-t-&gt; C C r-b-&gt; C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With this convention, and redefining the derivations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この規則を使用して、派生を再定義します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 if &#34;any-variants&#34; = &#34;x&#34; =&gt; blocked else if &#34;only-variants&#34; = &#34;s&#34; or &#34;r-s&#34; or &#34;b&#34; or &#34;r-b&#34; =&gt; allocatable else if &#34;only-variants&#34; = &#34;t&#34; or &#34;r-t&#34; or &#34;b&#34; or &#34;r-b&#34; =&gt; allocatable else if &#34;any-variants&#34; = &#34;s&#34; or &#34;t&#34; or &#34;b&#34; =&gt; blocked else =&gt; allocatable any labels that contain only reflexive mappings of otherwise mixed type (in other words, any mixed original label) now fall through, and their disposition is set to &#34;allocatable&#34; in the final derivation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
if &#34;any-variants&#34; = &#34;x&#34; =&gt;ブロックされているelse if &#34;only-variants&#34; = &#34;s&#34;または &#34;rs&#34;または &#34;b&#34;または &#34;rb&#34; =&gt;割り当て可能else if &#34;only-variants&#34; = &#34;t&#34;または &#34;rt&#34;または &#34;b&#34;または &#34;rb&#34; =&gt; &#34;any-variants&#34; = &#34;s&#34;または &#34;t&#34;または &#34;b&#34;の場合に割り当て可能else =&gt;ブロックされたelse =&gt;他の再帰マッピングのみを含むラベルを割り当て可能混合タイプ（つまり、混合された元のラベル）が失敗し、最終的な派生でその配置が「割り当て可能」に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a well-behaved LGR, it is preferable to explicitly define the derivation for allocatable labels instead of using a fall through. In the derivation above, code points without any variant mappings fall through and become allocatable by default if they are part of an original label. Especially in a large repertoire, it can be difficult to identify which code points are affected. Instead, it is preferable to mark them with their own reflexive mapping type &#34;neither&#34; or &#34;r-n&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切に動作するLGRでは、フォールスルーを使用するのではなく、割り当て可能なラベルの派生を明示的に定義することをお勧めします。上記の派生では、バリアントマッピングのないコードポイントは、元のラベルの一部である場合、デフォルトで通過し、割り当て可能になります。特に大きなレパートリーでは、影響を受けるコードポイントを特定するのが難しい場合があります。代わりに、独自の再帰マッピングタイプ「どちらでもない」または「r-n」でそれらをマークすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C r-n--&gt; C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C e-n-&gt; C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With that, we can change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それで、私たちは変えることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
else =&gt; allocatable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
else =&gt;割り当て可能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
と
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     else if &#34;only-variants&#34; = &#34;r-s&#34; or &#34;r-t&#34; or &#34;r-b&#34; or &#34;r-n&#34;
          =&gt;  allocatable
     else =&gt; invalid
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This makes the intent more explicit, and by ensuring that all code points in the LGR have a reflexive mapping of some kind, it is easier to verify the correct assignment of their types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、意図がより明確になり、LGR内のすべてのコードポイントに何らかの再帰的マッピングがあることを確認することで、型の正しい割り当てを確認しやすくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Handling Out-of-Repertoire Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. レパートリー外のバリアントの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At first, it may seem counterintuitive to define variants that map to code points that are not part of the repertoire. However, for zones for which multiple LGRs are defined, there may be situations where labels valid under one LGR should be blocked if a label under another LGR is already delegated. This situation can arise whether or not the repertoires of the affected LGRs overlap and, where repertoires overlap, whether or not the labels are both restricted to the common subset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初は、レパートリーの一部ではないコードポイントにマップするバリアントを定義するのは直観に反するように思えるかもしれません。ただし、複数のLGRが定義されているゾーンでは、別のLGRの下のラベルがすでに委任されている場合、1つのLGRの下で有効なラベルをブロックする必要がある状況があります。この状況は、影響を受けるLGRのレパートリーが重複しているかどうか、およびレパートリーが重複している場合に、ラベルが両方とも共通のサブセットに制限されているかどうかに関係なく発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to handle this exclusion relation through definition of variants, it is necessary to be able to specify variant mappings to some code point X that is outside an LGR&#39;s repertoire, R:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントの定義を通じてこの除外関係を処理するには、LGRのレパートリーRの外にあるコードポイントXへのバリアントマッピングを指定できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     C  x--&gt; X : where C = elementOf(R) and X != elementOf(R)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of symmetry, it is necessary to also specify the inverse mapping in the LGR:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称性のため、LGRで逆マッピングも指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     X  x--&gt; C : where X != elementOf(R) and C = elementOf(R)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This makes X a source of variant mappings, and it becomes necessary to identify X as being outside the repertoire, so that any attempt to apply for a label containing X will lead to a disposition of &#34;invalid&#34;, just as if X had never been listed in the LGR. The mechanism to do this uses reflexive variants but with a new type of reflexive mapping of &#34;out-of-repertoire-var&#34;, shown as &#34;r-o--&gt;&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これにより、Xはバリアントマッピングのソースになり、Xをレパートリーの外にあるものとして識別することが必要になるため、Xを含むラベルを適用しようとすると、まるでXがこれまでになかったかのように、「無効」という性質が生じますLGRに記載されています。これを行うメカニズムは、再帰バリアントを使用しますが、「r-o-&gt;」として示される「out-of-repertoire-var」の新しいタイプの再帰マッピングを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X r-o--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Ｘ ｒーおーー＞ Ｘ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This indicates X != elementOf(R), as long as the LGR is provided with a suitable derivation, so that any label containing &#34;r-o--&gt;&#34; is assigned a disposition of &#34;invalid&#34;, just as if X was any other code point not part of the repertoire. The derivation used is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、X！= elementOf（R）を示します。ただし、LGRに適切な派生が提供されている限り、「ro-&gt;」を含むラベルには、「X」が他のコードと同じように「無効」の後処理が割り当てられます。ポイントはレパートリーの一部ではありません。使用される派生は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;any-variant&#34; = &#34;out-of-repertoire-var&#34; =&gt; invalid
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is inserted ahead of any other derivation of the &#34;any-variant&#34; kind in the chain of derivations. As a result, instead of the minimum two symmetric variants, for any out-of-repertoire variants, there are a minimum of three variant mappings defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、派生のチェーン内で「任意のバリアント」の種類の他の派生の前に挿入されます。その結果、レパートリー外のバリアントの場合、最小2つの対称バリアントの代わりに、最低3つのバリアントマッピングが定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X X x--&gt; C X r-o--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x-&gt; X X x-&gt; C X r-o-&gt; X
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where C = elementOf(R) and X != elementOf(R).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、C = elementOf（R）およびX！= elementOf（R）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because no variant label with any code point outside the repertoire could ever be allocated, the only logical choice for the non-reflexive mappings to out-of-repertoire code points is &#34;blocked&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レパートリー外のコードポイントを持つバリアントラベルを割り当てることはできないため、レパートリー外のコードポイントへの非再帰的マッピングの唯一の論理的な選択肢は「ブロック」されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Conditional Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 条件付きバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant mappings are based on whether code points are &#34;same as&#34; to the user. In some writing systems, code points change shape based on where they occur in the word (positional forms). Some code points have matching shapes in some positions but not in others. In such cases, the variant mapping exists only for some possible positions or, more generally, only for some contexts. For other contexts, the variant mapping does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントマッピングは、コードポイントがユーザーと「同じ」かどうかに基づいています。一部の書記体系では、コードポイントは、単語内の出現位置（位置形式）に基づいて形状が変化します。一部のコードポイントは、一部の位置に一致する形状を持っていますが、他の位置にはありません。このような場合、バリアントマッピングは、一部の可能な位置に対してのみ存在します。より一般的には、一部のコンテキストに対してのみ存在します。他のコンテキストでは、バリアントマッピングは存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, take two code points that have the same shape at the end of a label (or in final position) but not in any other position. In that case, they are variants only when they occur in the final position, something we indicate like this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、ラベルの最後（または最終位置）で同じ形状を持ち、他の位置ではない2つのコードポイントを考えます。その場合、それらは最終位置にある場合にのみバリアントであり、次のように示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     final: C --&gt; D
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cursively connected scripts, like Arabic, a code point may take its final form when next to any following code point that interrupts the cursive connection, not just at the end of a label. (We ignore the isolated form to keep the discussion simple; if included, &#34;final&#34; might be &#34;final-or-isolate&#34;, for example).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アラビア語のように筆記体で接続されたスクリプトでは、ラベルの末尾だけでなく、筆記体の接続を中断する後続のコードポイントの横にある場合、コードポイントは最終的な形をとることがあります。 （議論を単純にするために、分離されたフォームは無視します。たとえば、「final」は「final-or-isolate」になる場合があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From symmetry, we expect that the mapping D --&gt; C should also exist only when the code point D is in final position. (Similar considerations apply to transitivity.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称性から、コードポイントDが最終位置にある場合にのみ、マッピングD-&gt; Cも存在するはずです。 （同様の考慮事項が推移性に適用されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sometimes a code point has a final form that is practically the same as that of some other code point while sharing initial and medial forms with another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードポイントの最終的なフォームは、他のコードポイントと実質的に同じで、初期フォームと中間フォームを別のコードポイントと共有する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     final: C --&gt; D
     !final: C --&gt; E
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, the case where the condition is the opposite of final is shown as &#34;!final&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、finalと逆の場合を「！final」と表示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because shapes differ by position, when a context is applied to a variant mapping, it is treated independently from the same mapping in other contexts. This extends to the assignment of types. For example, the mapping C --&gt; F may be &#34;allocatable&#34; in final position but &#34;blocked&#34; in any other context:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
形状は位置によって異なるため、コンテキストがバリアントマッピングに適用されると、他のコンテキストの同じマッピングとは独立して扱われます。これは、型の割り当てにまで及びます。たとえば、マッピングC-&gt; Fは最終位置では「割り当て可能」であるが、他のコンテキストでは「ブロック」される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     final:  C  a--&gt; F
     !final: C  x--&gt; F
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, the type assigned to the forward mapping is independent of the reverse symmetric mapping or any transitive mappings. Imagine a situation where the symmetric mapping is defined as F a--&gt; C, that is, all mappings from F to C are &#34;allocatable&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これで、順方向マッピングに割り当てられたタイプは、逆対称マッピングや推移的マッピングから独立しています。対称マッピングがF a-&gt; Cとして定義されている状況を想像してください。つまり、FからCへのすべてのマッピングは「割り当て可能」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     final: F  a--&gt; C
     !final: F  a--&gt;C
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Why not simply write F a--&gt; C? Because the forward mapping is divided by context. Adding a context makes the two forward variant mappings distinct, and that needs to be accounted for explicitly in the reverse mappings so that human and machine readers can easily verify symmetry and transitivity of the variant mappings in the LGR. (This is true even though the two opposite contexts of &#34;final&#34; and &#34;!final&#34; should together cover all possible cases.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
単にF a-&gt; Cと書いてみませんか？フォワードマッピングはコンテキストによって分割されるためです。コンテキストを追加すると、2つのフォワードバリアントマッピングが区別され、人間と機械の読者がLGRのバリアントマッピングの対称性と推移性を簡単に確認できるように、リバースマッピングで明示的に考慮する必要があります。 （ &#34;final&#34;と &#34;！final&#34;の2つの反対のコンテキストがすべての可能なケースをカバーする必要がある場合でも、これは当てはまります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Making Conditional Variants Well Behaved
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. 条件付きバリアントを適切に動作させる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure that LGR with contextual variants is well behaved, it is best to always use &#34;fully qualified&#34; variant mappings that always agree in the names of the context rules for forward and reverse mappings. It is also necessary to ensure that no label can match more than one context for the same mapping. Using mutually exclusive contexts, such as &#34;final&#34; and &#34;!final&#34;, is an easy way to ensure that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストバリアントを含むLGRが適切に動作するようにするには、フォワードマッピングとリバースマッピングのコンテキストルールの名前が常に一致する「完全修飾」バリアントマッピングを常に使用することをお勧めします。また、同じマッピングのラベルが複数のコンテキストに一致しないようにする必要もあります。 &#34;final&#34;や &#34;！final&#34;などの相互に排他的なコンテキストを使用すると、簡単に確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, it is not always necessary to define dual or multiple contexts that together cover all possible cases. For example, here are two contexts that do not cover all possible positional contexts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、すべての可能なケースをカバーするデュアルまたはマルチコンテキストを定義する必要は必ずしもありません。たとえば、考えられるすべての位置コンテキストを網羅していない2つのコンテキストを次に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
final: C --&gt; D initial: C --&gt; D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
最終：C-&gt; D初期：C-&gt; D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A well-behaved LGR using these two contexts would define all symmetric and transitive mappings involving C, D, and their variants consistently in terms of the two conditions &#34;final&#34; and &#34;initial&#34; and ensure that both cannot be satisfied at the same time by some label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの2つのコンテキストを使用する適切に動作するLGRは、C、D、およびそれらのバリアントを含むすべての対称および推移的マッピングを、「最終」および「初期」という2つの条件に関して一貫して定義し、両方が同時に満たすことができないようにします。いくつかのラベル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to never defining the same mapping with two contexts that may be satisfied by the same label, a well-behaved LGR never combines a variant mapping with a context with the same variant mapping without a context:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じラベルで満たされる可能性がある2つのコンテキストで同じマッピングを決して定義しないことに加えて、行儀の良いLGRは、バリアントマッピングとコンテキストのない同じバリアントマッピングのコンテキストを決して組み合わせません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     context: C --&gt; D
     C --&gt; D
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inadvertent mixing of conditional and unconditional variants can be detected and flagged by a parser, but verifying that two formally distinct contexts are never satisfied by the same label would depend on the interaction between labels and context rules, which means that it will be up to the LGR designer to ensure that the LGR is well behaved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
条件付きバリアントと無条件バリアントの不注意による混合は、パーサーによって検出およびフラグ付けできますが、2つの形式的に異なるコンテキストが同じラベルで満たされないことの確認は、ラベルとコンテキストルールの間の相互作用に依存します。つまり、 LGRデザイナーが、LGRが適切に動作することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A well-behaved LGR never assigns conditions on a reflexive variant, as that is effectively no different from having a context on the code point itself; the latter is preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に動作するLGRは、コードポイント自体にコンテキストを持つことと実質的に違いがないため、再帰バリアントに条件を割り当てません。後者が好ましい。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, for symmetry to work as expected, the context must be defined such that it is satisfied for both the original code point in the context of the original label and for the variant code point in the variant label. In other words, the context should be &#34;stable under variant substitution&#34; anywhere in the label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、対称性が期待どおりに機能するためには、元のラベルのコンテキストの元のコードポイントとバリアントラベルのバリアントコードポイントの両方が満たされるようにコンテキストを定義する必要があります。言い換えると、コンテキストはラベルのどこでも「バリアント置換の下で安定」である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Positional contexts usually satisfy this last condition; for example, a code point that interrupts a cursive connection would likely share this property with any of its variants. However, as it is possible in principle to define other kinds of contexts, it is necessary to make sure that the LGR is well behaved in this aspect at the time the LGR is designed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、定位置コンテキストはこの最後の条件を満たします。たとえば、筆記体接続を中断するコードポイントは、このプロパティをそのバリアントと共有する可能性があります。ただし、他の種類のコンテキストを定義することは原則として可能であるため、LGRの設計時に、この側面でLGRが適切に動作することを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to the difficulty in verifying these constraints mechanically, it is essential that an LGR designer document the reasons why the LGR can be expected to meet them and the details of the techniques used to ensure that outcome. This information should be found in the description element of the LGR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの制約を機械的に検証することは困難であるため、LGRがLGRに適合することが期待できる理由とその結果を確実にするために使用される手法の詳細をLGR設計者が文書化することが不可欠です。この情報は、LGRのdescription要素にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, conditional contexts can be useful for some cases, but additional care must be taken to ensure that an LGR containing conditional contexts is well behaved. LGR designers would be well advised to avoid using conditional contexts and to prefer unconditional rules whenever practical, even though it will doubtlessly reduce the number of labels practically available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要約すると、条件付きコンテキストはいくつかの場合に役立ちますが、条件付きコンテキストを含むLGRが適切に動作するように、さらに注意が必要です。 LGRの設計者は、実際に使用できるラベルの数が確実に減少する場合でも、条件付きコンテキストの使用を避け、実用的な場合は常に無条件ルールを優先することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Variants for Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. シーケンスのバリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant mappings can be defined between sequences or between a code point and a sequence. For example, one might define a &#34;blocked&#34; variant between the sequence &#34;rn&#34; and the code point &#34;m&#34; because they are practically indistinguishable in common UI fonts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントマッピングは、シーケンス間またはコードポイントとシーケンス間で定義できます。たとえば、シーケンス「rn」とコードポイント「m」の間に「ブロックされた」バリアントを定義する場合があります。それらは一般的なUIフォントでは事実上区別できないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such variants are no different from variants defined between single code points, except if a sequence is defined such that there is a code point or shorter sequence that is a prefix (initial subsequence) and both it and the remainder are also part of the repertoire. In that case, it is possible to create duplicate variants with conflicting dispositions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなバリアントは、単一のコードポイント間で定義されたバリアントと同じです。ただし、シーケンスがコードポイントまたは接頭辞（最初のサブシーケンス）である短いシーケンスが存在するように定義され、それと残りの両方もレパートリーの一部である場合を除きます。その場合、処理が競合するバリアントが重複して作成される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following shows such an example resulting in conflicting reflexive variants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、競合する再帰バリアントが発生するそのような例を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A a--&gt; C AB x--&gt; CD
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
あ あーー＞ Ｃ あＢ ｘーー＞ ＣＤ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where AB is a sequence with an initial subsequence of A. For example, B might be a combining code point used in sequence AB. If B only occurs in the sequence, there is no issue, but if B also occurs by itself, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、ABは最初のサブシーケンスがAのシーケンスです。たとえば、BはシーケンスABで使用される結合コードポイントです。 Bがシーケンスでのみ発生する場合、問題はありませんが、Bが単独で発生する場合は、たとえば次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
B a--&gt; D
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
B a-&gt; D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
then a label &#34;AB&#34; might correspond to either {A}{B}, that is, the two code points, or {AB}, the sequence, where the curly braces show the sequence boundaries as they would be applied during label validation and variant mapping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、ラベル「AB」は、{A} {B}、つまり2つのコードポイント、または{AB}のシーケンスに対応します。中括弧は、ラベルの検証中に適用されるシーケンスの境界を示します。バリアントマッピング。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A label AB would then generate the &#34;allocatable&#34; variant label {C}{D} and the &#34;blocked&#34; variant label {CD}, thus creating two variant labels with conflicting dispositions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、ラベルABは「割り当て可能な」バリアントラベル{C} {D}と「ブロックされた」バリアントラベル{CD}を生成し、処理が競合する2つのバリアントラベルを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the example of a blocked variant between &#34;m&#34; and &#34;rn&#34; (and vice versa), there is no issue as long as &#34;r&#34; and &#34;n&#34; do not have variant mappings of their own, so that there cannot be multiple variant labels for the same input. However, it is preferable to avoid ambiguities altogether where possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;m&#34;と &#34;rn&#34;の間（およびその逆）のブロックされたバリアントの例では、 &#34;r&#34;と &#34;n&#34;が独自のバリアントマッピングを持たない限り問題はありません。同じ入力のバリアントラベル。ただし、可能な場合はあいまいさを完全に回避することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The easiest way to avoid an ambiguous segmentation into sequences is by never allowing both a sequence and all of its constituent parts simultaneously as independent parts of the repertoire, for example, by not defining B by itself as a member of the repertoire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスへのあいまいなセグメンテーションを回避する最も簡単な方法は、シーケンスとそのすべての構成部分の両方をレパートリーの独立した部分として同時に許可しないことです。たとえば、B自体をレパートリーのメンバーとして定義しないことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sequences are often used for combining sequences that consist of a base character B followed by one or more combining marks C. By enumerating all sequences in which a certain combining mark is expected and by not listing the combining mark by itself in the LGR, the mark cannot occur outside of these specifically enumerated contexts. In cases where enumeration is not possible or practicable, other techniques can be used to prevent ambiguous segmentation, for example, a context rule on code points that disallows B preceding C in any label except as part of a predefined sequence or class of sequences. The details of such techniques are outside the scope of this document (see [RFC7940] for information on context rules for code points).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンスは、ベース文字Bとそれに続く1つ以上の結合マークCで構成されるシーケンスの結合によく使用されます。特定の結合マークが期待されるすべてのシーケンスを列挙し、LGRに結合マークを単独でリストしないことにより、マークこれらの具体的に列挙されたコンテキストの外では発生できません。列挙が不可能または実用的でない場合は、他の手法を使用して、あいまいなセグメンテーションを防ぐことができます。たとえば、事前定義されたシーケンスまたはシーケンスのクラスの一部として以外のラベルでBの前のCを許可しないコードポイントのコンテキストルール。このような手法の詳細は、このドキュメントの範囲外です（コードポイントのコンテキストルールについては、[RFC7940]を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Corresponding XML Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. 対応するXML表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The XML format defined in [RFC7940] corresponds fairly directly to the notation used for variant mappings in this document. (There is no notation in the RFC for variant type sets). In an LGR document, a simple member of a repertoire that does not have any variants is listed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]で定義されているXML形式は、このドキュメントのバリアントマッピングに使用される表記法にかなり直接対応しています。 （RFCには、バリアントタイプセットの表記はありません）。 LGRドキュメントでは、バリアントを持たないレパートリーの単純なメンバーは次のようにリストされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   &lt;char cp=&#34;nnnn&#34; /&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where nnnn is the [UNICODE] code point value in the standard uppercase hexadecimal notation padded to at least 4 digits and without leading &#34;U+&#34;. For a code point sequence of length 2, the XML notation becomes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、nnnnは、標準の大文字の16進表記の[UNICODE]コードポイント値で、先頭に「U +」を付けずに4桁以上埋め込まれています。長さが2のコードポイントシーケンスの場合、XML表記は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   &lt;char cp=&#34;uuuu vvvvv&#34; /&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Variant mappings are defined by nesting &lt;var&gt; elements inside the
   &lt;char&gt; element.  For example, a variant relation of type &#34;blocked&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
C x-&gt; X
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
として表現されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;char cp=&#34;nnnn&#34;&gt;
       &lt;var cp=&#34;mmmm&#34; type=&#34;blocked&#34; /&gt;
     &lt;/char&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;x--&gt;&#34; identifies a &#34;blocked&#34; type. (Other types include &#34;a--&gt;&#34; for &#34;allocatable&#34;, for example. Here, nnnn and mmmm are the [UNICODE] code point values for C and X, respectively. Either C or X could be a code point sequence or a single code point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「x-&gt;」は「ブロックされた」タイプを示します。 （たとえば、他のタイプには、「割り当て可能」の「a-&gt;」が含まれます。ここで、nnnnおよびmmmmは、それぞれCおよびXの[UNICODE]コードポイント値です。CまたはXは、コードポイントシーケンスまたは単一のコードポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reflexive mapping is specified the same way, except that it always uses the same code point value for both the &lt;char&gt; and &lt;var&gt; element, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再帰マッピングは、&lt;char&gt;要素と&lt;var&gt;要素の両方に常に同じコードポイント値を使用することを除いて、同じ方法で指定されます。次に例を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
X r-o--&gt; X
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Ｘ ｒーおーー＞ Ｘ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would correspond to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
に対応する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   &lt;char cp=&#34;nnnn&#34;&gt;&lt;var cp=&#34;nnnn&#34; type=&#34;out-of-repertoire-var&#34; /&gt;&lt;/char&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple &lt;var&gt; elements may be nested inside a single &lt;char&gt; element, but their &#34;cp&#34; values must be distinct (unless attributes for context rules are present and the combination of &#34;cp&#34; value and context attributes are distinct).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の&lt;var&gt;要素を単一の&lt;char&gt;要素内にネストできますが、それらの「cp」値は異なる必要があります（コンテキストルールの属性が存在し、「cp」値とコンテキスト属性の組み合わせが異なる場合を除く）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;char cp=&#34;nnnn&#34;&gt;
       &lt;var cp=&#34;kkkk&#34; type=&#34;allocatable&#34; /&gt;
       &lt;var cp=&#34;mmmm&#34; type=&#34;blocked&#34; /&gt;
     &lt;/char&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A set of conditional variants like
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
のような条件付きバリアントのセット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     final: C  a--&gt; K
     !final: C  x--&gt; K
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
would correspond to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
に対応する
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;var cp=&#34;kkkk&#34; when=&#34;final&#34; type=&#34;allocatable&#34; /&gt;
     &lt;var cp=&#34;kkkk&#34; not-when=&#34;final&#34; type=&#34;blocked&#34; /&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where the string &#34;final&#34; references a name of a context rule. Context rules are defined in [RFC7940]; they conceptually correspond to regular expressions. The details of how to create and define these rules are outside the scope of this document. If the label matches the context defined in the rule, the variant mapping is valid and takes part in further processing. Otherwise, it is invalid and ignored. Using the &#34;not-when&#34; attribute inverts the sense of the match. The two attributes are mutually exclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文字列「final」は、コンテキストルールの名前を参照します。コンテキストルールは[RFC7940]で定義されています。概念的には正規表現に対応しています。これらのルールを作成および定義する方法の詳細は、このドキュメントの範囲外です。ラベルがルールで定義されたコンテキストと一致する場合、バリアントマッピングは有効であり、以降の処理に参加します。それ以外の場合は、無効で無視されます。 「not-when」属性を使用すると、一致の意味が逆になります。 2つの属性は相互に排他的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A derivation of a variant label disposition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントラベルディスポジションの派生
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     if &#34;only-variants&#34; = &#34;s&#34; or &#34;b&#34; =&gt; allocatable
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
として表現されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     &lt;action disp=&#34;allocatable&#34; only-variants= &#34;s b&#34; /&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of using &#34;if&#34; and &#34;else if&#34;, the &lt;action&gt; elements implicitly form a cascade, where the first action triggered defines the disposition of the label. The order of action elements is thus significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「if」と「else if」を使用する代わりに、&lt;action&gt;要素は暗黙的にカスケードを形成し、最初にトリガーされるアクションがラベルの配置を定義します。したがって、アクション要素の順序は重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the full specification of the XML format, see [RFC7940].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML形式の完全な仕様については、[RFC7940]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not require any IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、IANAアクションは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in [RFC7940], variants may be used as a tool to reduce certain avenues of attack in security-relevant identifiers by allowing certain labels to be &#34;mutually exclusive or registered only to the same user&#34;. However, if indiscriminately designed, variants may themselves contribute to risks to the security or usability of the identifiers, whether resulting from an ambiguous definition or from allowing too many allocatable variants per label.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940]で説明されているように、バリアントは、特定のラベルを「相互に排他的または同じユーザーのみに登録」できるようにすることで、セキュリティ関連の識別子における攻撃の特定の手段を減らすツールとして使用できます。ただし、無差別に設計した場合、あいまいな定義に起因する場合でも、ラベルごとに割り当て可能なバリアントが多すぎる場合でも、バリアント自体が識別子のセキュリティや使いやすさのリスクにつながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The information in this document is intended to allow the reader to design a specification of an LGR that is &#34;well behaved&#34; with respect to variants; as used here, this term refers to an LGR that is predictable in its effects to the LGR author (and reviewer) and more reliable in its implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの情報は、読者がバリアントに関して「適切に動作する」LGRの仕様を設計できるようにすることを目的としています。ここで使用されているように、この用語はLGRの作成者（およびレビューアー）への影響が予測可能であり、その実装がより信頼できるLGRを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A well-behaved LGR is not merely one that can be expressed in [RFC7940], but, in addition, it actively avoids certain edge cases not prevented by the schema, such as those that would result in ambiguities in the specification of the intended disposition for some variant labels. By applying the additional considerations introduced in this document, including adding certain declarations that are optional under the schema and may not alter the results of processing a label, such an LGR becomes easier to review and its implementations easier to verify.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常に動作するLGRは、[RFC7940]で表現できるものだけではなく、意図された処理の仕様にあいまいさをもたらすような、スキーマによって防止されない特定のエッジケースを積極的に回避します。一部のバリアントラベル。このドキュメントで紹介されている追加の考慮事項を適用することにより、スキーマの下でオプションであり、ラベルの処理結果を変更しない可能性がある特定の宣言を追加することにより、そのようなLGRを確認しやすくなり、その実装を検証しやすくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that variants are an important part, but only a part, of an LGR design. There are many other features of an LGR that this document does not touch upon. Also, the question of whether to define variants at all, or what labels are to be considered variants of each other, is not addressed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バリアントはLGR設計の重要な部分ですが、一部にすぎないことに注意してください。 LGRには、このドキュメントでは触れない他の多くの機能があります。また、バリアントを定義するかどうか、またはどのラベルが互いのバリアントと見なされるかについての質問は、ここでは扱いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940] Davies, K. and A. Freytag, &#34;Representing Label Generation Rulesets Using XML&#34;, RFC 7940, DOI 10.17487/RFC7940, August 2016, &lt;https://www.rfc-editor.org/info/rfc7940&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7940] Davies、K.およびA. Freytag、「Representing Label Generation Rulesets Using XML」、RFC 7940、DOI 10.17487 / RFC7940、2016年8月、&lt;https://www.rfc-editor.org/info/rfc7940&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris, P., &#34;Domain names - concepts and facilities&#34;, STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987, &lt;https://www.rfc-editor.org/info/rfc1034&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、DOI 10.17487 / RFC1034、1987年11月、&lt;https://www.rfc-editor.org/info/rfc1034&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris, P., &#34;Domain names - implementation and specification&#34;, STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, &lt;https://www.rfc-editor.org/info/rfc1035&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris、P。、「ドメイン名-実装および仕様」、STD 13、RFC 1035、DOI 10.17487 / RFC1035、1987年11月、&lt;https://www.rfc-editor.org/info/rfc1035&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5890] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework&#34;, RFC 5890, DOI 10.17487/RFC5890, August 2010, &lt;https://www.rfc-editor.org/info/rfc5890&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5890] Klensin、J。、「Internationalized Domain Names for Applications（IDNA）：Definitions and Document Framework」、RFC 5890、DOI 10.17487 / RFC5890、2010年8月、&lt;https://www.rfc-editor.org/info/ rfc5890&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5891] Klensin, J., &#34;Internationalized Domain Names in Applications (IDNA): Protocol&#34;, RFC 5891, DOI 10.17487/RFC5891, August 2010, &lt;https://www.rfc-editor.org/info/rfc5891&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5891] Klensin、J。、「Internationalized Domain Names in Applications（IDNA）：Protocol」、RFC 5891、DOI 10.17487 / RFC5891、2010年8月、&lt;https://www.rfc-editor.org/info/rfc5891&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5892] Faltstrom, P., Ed., &#34;The Unicode Code Points and Internationalized Domain Names for Applications (IDNA)&#34;, RFC 5892, DOI 10.17487/RFC5892, August 2010, &lt;https://www.rfc-editor.org/info/rfc5892&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5892] Faltstrom、P。、編、「アプリケーションのUnicodeコードポイントと国際化ドメイン名（IDNA）」、RFC 5892、DOI 10.17487 / RFC5892、2010年8月、&lt;https://www.rfc-editor.org / info / rfc5892&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5893] Alvestrand, H., Ed. and C. Karp, &#34;Right-to-Left Scripts for Internationalized Domain Names for Applications (IDNA)&#34;, RFC 5893, DOI 10.17487/RFC5893, August 2010, &lt;https://www.rfc-editor.org/info/rfc5893&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5893]アルベストランド、H。、エド。およびC. Karp、「Right-to-Left Scripts for Internationalized Domain Names for Applications（IDNA）」、RFC 5893、DOI 10.17487 / RFC5893、2010年8月、&lt;https://www.rfc-editor.org/info/rfc5893 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5894] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Background, Explanation, and Rationale&#34;, RFC 5894, DOI 10.17487/RFC5894, August 2010, &lt;https://www.rfc-editor.org/info/rfc5894&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5894] Klensin、J。、「アプリケーションの国際化ドメイン名（IDNA）：背景、説明、および理論的根拠」、RFC 5894、DOI 10.17487 / RFC5894、2010年8月、&lt;https://www.rfc-editor.org/ info / rfc5894&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard&#34;, &lt;http://www.unicode.org/versions/latest/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] Unicodeコンソーシアム、「The Unicode Standard」、&lt;http://www.unicode.org/versions/latest/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contributions that have shaped this document have been provided by Marc Blanchet, Ben Campbell, Patrik Faltstrom, Scott Hollenbeck, Mirja Kuehlewind, Sarmad Hussain, John Klensin, Alexey Melnikov, Nicholas Ostler, Michel Suignard, Andrew Sullivan, Wil Tan, and Suzanne Woolf.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントを形作る寄稿は、マークブランシェ、ベンキャンベル、パトリックファルストレム、スコットホレンベック、ミルジャキュールウィンド、サーマドフセイン、ジョンクレンシン、アレクセイメリニコフ、ニコラスオストラー、ミシェルスィナード、アンドリューサリバン、ウィルタン、スザンヌウルフによって提供されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Asmus Freytag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アスムス・フレイタグ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: asmus@unicode.org
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
