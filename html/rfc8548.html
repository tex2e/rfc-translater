<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8548 - Cryptographic Protection of TCP Streams (tcpcrypt) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8548</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8548">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 8548 - Cryptographic Protection of TCP Streams (tcpcrypt) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc8548">
            https://datatracker.ietf.org/doc/html/rfc8548
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 8548 - TCPストリームの暗号化保護（tcpcrypt）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <h6 class="card-title">要約（自動生成）</h6>
            <p class="card-text">RFC 8548は、TCPストリームの暗号化保護を目的とした「tcpcrypt」というプロトコルに関する文書です。このプロトコルは、アプリケーション層に変更を加えることなく、透過的にTCP接続を暗号化することを目的としています。これにより、ユーザーのデータプライバシーを強化し、中間者攻撃に対する保護を提供します。tcpcryptは、特にTLS/SSLが適用されない場合の通信のセキュリティを向上させるために利用されます。関連するRFCには、TCPの拡張やセキュリティに関するRFC 793 (TCPの仕様) やRFC 5925 (TCPの暗号化オプション) などがあります。</p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         A. Bittau
Request for Comments: 8548                                        Google
Category: Experimental                                         D. Giffin
ISSN: 2070-1721                                      Stanford University
                                                              M. Handley
                                               University College London
                                                             D. Mazieres
                                                     Stanford University
                                                                Q. Slack
                                                             Sourcegraph
                                                                E. Smith
                                                       Kestrel Institute
                                                                May 2019
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Cryptographic Protection of TCP Streams (tcpcrypt)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
TCPストリームの暗号化保護（tcpcrypt）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies &#34;tcpcrypt&#34;, a TCP encryption protocol designed for use in conjunction with the TCP Encryption Negotiation Option (TCP-ENO). Tcpcrypt coexists with middleboxes by tolerating resegmentation, NATs, and other manipulations of the TCP header. The protocol is self-contained and specifically tailored to TCP implementations, which often reside in kernels or other environments in which large external software dependencies can be undesirable. Because the size of TCP options is limited, the protocol requires one additional one-way message latency to perform key exchange before application data can be transmitted. However, the extra latency can be avoided between two hosts that have recently established a previous tcpcrypt connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、TCP暗号化ネゴシエーションオプション（TCP-ENO）と組み合わせて使用​​するために設計されたTCP暗号化プロトコルである「tcpcrypt」を指定しています。 Tcpcryptは、再分割、NAT、およびTCPヘッダーの他の操作を許容することにより、ミドルボックスと共存します。プロトコルは自己完結型であり、TCP実装に合わせて特別に調整されています。TCP実装は、カーネルまたは他の環境に常駐しており、外部のソフトウェアへの依存が大きくなると望ましくない場合があります。 TCPオプションのサイズは限られているため、プロトコルでは、アプリケーションデータを送信する前に、キー交換を実行するために、さらに1方向のメッセージレイテンシが必要です。ただし、以前にtcpcrypt接続を最近確立した2つのホスト間の余分な遅延を回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。試験、実験、評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、インターネットコミュニティの実験プロトコルを定義します。このドキュメントは、IETF（Internet Engineering Task Force）の製品です。これは、IETFコミュニティのコンセンサスを表しています。公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補であるとは限りません。 RFC 7841のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8548.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8548で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2019 IETF Trustおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   4
   3.  Encryption Protocol . . . . . . . . . . . . . . . . . . . . .   4
     3.1.  Cryptographic Algorithms  . . . . . . . . . . . . . . . .   4
     3.2.  Protocol Negotiation  . . . . . . . . . . . . . . . . . .   6
     3.3.  Key Exchange  . . . . . . . . . . . . . . . . . . . . . .   7
     3.4.  Session ID  . . . . . . . . . . . . . . . . . . . . . . .  10
     3.5.  Session Resumption  . . . . . . . . . . . . . . . . . . .  10
     3.6.  Data Encryption and Authentication  . . . . . . . . . . .  14
     3.7.  TCP Header Protection . . . . . . . . . . . . . . . . . .  16
     3.8.  Rekeying  . . . . . . . . . . . . . . . . . . . . . . . .  16
     3.9.  Keep-Alive  . . . . . . . . . . . . . . . . . . . . . . .  17
   4.  Encodings . . . . . . . . . . . . . . . . . . . . . . . . . .  18
     4.1.  Key-Exchange Messages . . . . . . . . . . . . . . . . . .  18
     4.2.  Encryption Frames . . . . . . . . . . . . . . . . . . . .  20
       4.2.1.  Plaintext . . . . . . . . . . . . . . . . . . . . . .  20
       4.2.2.  Associated Data . . . . . . . . . . . . . . . . . . .  21
       4.2.3.  Frame ID  . . . . . . . . . . . . . . . . . . . . . .  21
     4.3.  Constant Values . . . . . . . . . . . . . . . . . . . . .  22
   5.  Key-Agreement Schemes . . . . . . . . . . . . . . . . . . . .  22
   6.  AEAD Algorithms . . . . . . . . . . . . . . . . . . . . . . .  24
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25
     8.1.  Asymmetric Roles  . . . . . . . . . . . . . . . . . . . .  27
     8.2.  Verified Liveness . . . . . . . . . . . . . . . . . . . .  27
     8.3.  Mandatory Key-Agreement Schemes . . . . . . . . . . . . .  27
   9.  Experiments . . . . . . . . . . . . . . . . . . . . . . . . .  28
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  29
     10.2.  Informative References . . . . . . . . . . . . . . . . .  30
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  31
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes tcpcrypt, an extension to TCP for cryptographic protection of session data. Tcpcrypt was designed to meet the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、セッションデータの暗号化保護のためのTCPの拡張機能であるtcpcryptについて説明します。 Tcpcryptは、次の目標を満たすように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Meet the requirements of the TCP Encryption Negotiation Option (TCP-ENO) [RFC8547] for protecting connection data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接続データを保護するためのTCP暗号化ネゴシエーションオプション（TCP-ENO）[RFC8547]の要件を満たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Be amenable to small, self-contained implementations inside TCP stacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCPスタック内の小さな自己完結型の実装に対応できる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Minimize additional latency at connection startup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接続開始時の追加の遅延を最小限に抑えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As much as possible, prevent connection failure in the presence of NATs and other middleboxes that might normalize traffic or otherwise manipulate TCP segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o トラフィックを正常化したり、TCPセグメントを操作したりする可能性のあるNATやその他のミドルボックスが存在する場合は、接続障害をできるだけ防止してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Operate independently of IP addresses, making it possible to authenticate resumed sessions efficiently even when either end changes IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o IPアドレスとは独立して動作するため、どちらかの端でIPアドレスが変更された場合でも、再開されたセッションを効率的に認証できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A companion document [TCPINC-API] describes recommended interfaces for configuring certain parameters of this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連ドキュメント[TCPINC-API]には、このプロトコルの特定のパラメーターを構成するための推奨インターフェースが記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Requirements-Language">
2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Encryption-Protocol">
3. Encryption Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 暗号化プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the operation of the tcpcrypt protocol. The wire format of all messages is specified in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、tcpcryptプロトコルの操作について説明します。すべてのメッセージのワイヤ形式は、セクション4で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Cryptographic-Algorithms">
3.1. Cryptographic Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 暗号アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Setting up a tcpcrypt connection employs three types of cryptographic algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcrypt接続の設定には、3種類の暗号化アルゴリズムが採用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A key agreement scheme is used with a short-lived public key to agree upon a shared secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 鍵合意方式は、有効期間が短い公開鍵とともに使用され、共有秘密を合意します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An extract function is used to generate a pseudo-random key (PRK) from some initial keying material produced by the key agreement scheme. The notation Extract(S, IKM) denotes the output of the extract function with salt S and initial keying material IKM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 抽出関数を使用して、鍵合意スキームによって生成されたいくつかの初期鍵材料から疑似ランダム鍵（PRK）を生成します。表記Extract（S、IKM）は、ソルトSと初期キーイングマテリアルIKMを使用した抽出関数の出力を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A collision-resistant pseudo-random function (CPRF) is used to generate multiple cryptographic keys from a pseudo-random key, typically the output of the extract function. The CPRF produces an arbitrary amount of Output Keying Material (OKM), and we use the notation CPRF(K, CONST, L) to designate the first L bytes of the OKM produced by the CPRF when parameterized by key K and the constant CONST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 耐衝突性疑似ランダム関数（CPRF）は、疑似ランダムキー（通常は抽出関数の出力）から複数の暗号化キーを生成するために使用されます。 CPRFは任意の量の出力キーイングマテリアル（OKM）を生成します。CPRF（K、CONST、L）という表記を使用して、キーKおよび定数CONSTでパラメーター化されたときに、CPRFによって生成されるOKMの最初のLバイトを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Extract and CPRF functions used by the tcpcrypt variants defined in this document are the Extract and Expand functions of the HMAC-based Key Derivation Function (HKDF) [RFC5869], which is built on Keyed-Hashing for Message Authentication (HMAC) [RFC2104]. These are defined as follows in terms of the function HMAC-Hash(key, value) for a negotiated Hash function such as SHA-256; the symbol &#34;|&#34; denotes concatenation, and the counter concatenated to the right of CONST occupies a single octet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで定義されているtcpcryptバリアントで使用されるExtract関数とCPRF関数は、HMACベースの鍵導出関数（HKDF）[RFC5869]のExtract関数とExpand関数であり、メッセージ認証用のキー付きハッシュ（HMAC）[RFC2104 ]。これらは、SHA-256などのネゴシエートされたハッシュ関数の関数HMAC-Hash（key、value）に関して、次のように定義されます。記号「|」連結を示し、CONSTの右側に連結されたカウンターは1オクテットを占めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           HKDF-Extract(salt, IKM) -&gt; PRK
              PRK = HMAC-Hash(salt, IKM)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
HKDF-Expand(PRK, CONST, L) -&gt; OKM T(0) = empty string (zero length) T(1) = HMAC-Hash(PRK, T(0) | CONST | 0x01) T(2) = HMAC-Hash(PRK, T(1) | CONST | 0x02) T(3) = HMAC-Hash(PRK, T(2) | CONST | 0x03) ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
HKDF-Expand（PRK、CONST、L）-&gt; OKM T（0）=空の文字列（ゼロ長）T（1）= HMAC-Hash（PRK、T（0）| CONST | 0x01）T（2）= HMAC -Hash（PRK、T（1）| CONST | 0x02）T（3）= HMAC-Hash（PRK、T（2）| CONST | 0x03）...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              OKM  = first L octets of T(1) | T(2) | T(3) | ...
              where L &lt;= 255*OutputLength(Hash)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 1: HKDF Functions Used for Key Derivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図1：キーの導出に使用されるHKDF関数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, once tcpcrypt has been successfully set up and encryption keys have been derived, an algorithm for Authenticated Encryption with Associated Data (AEAD) is used to protect the confidentiality and integrity of all transmitted application data. AEAD algorithms use a single key to encrypt their input data and also to generate a cryptographic tag to accompany the resulting ciphertext; when decryption is performed, the tag allows authentication of the encrypted data and of optional associated plaintext data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、tcpcryptが正常にセットアップされ、暗号化キーが導出されたら、関連データを使用した認証暗号化（AEAD）のアルゴリズムを使用して、送信されるすべてのアプリケーションデータの機密性と整合性を保護します。 AEADアルゴリズムは、単一のキーを使用して入力データを暗号化し、暗号化タグを生成して結果の暗号文に添付します。復号化が実行されると、タグにより、暗号化されたデータとオプションの関連プレーンテキストデータの認証が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Protocol-Negotiation">
3.2. Protocol Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. プロトコル交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt depends on TCP-ENO [RFC8547] to negotiate whether encryption will be enabled for a connection as well as which key-agreement scheme to use. TCP-ENO negotiates the use of a particular TCP encryption protocol (TEP) by including protocol identifiers in ENO suboptions. This document associates four TEP identifiers with the tcpcrypt protocol as listed in Table 4 of Section 7. Each identifier indicates the use of a particular key-agreement scheme, with an associated CPRF and length parameter. Future standards can associate additional TEP identifiers with tcpcrypt following the assignment policy specified by TCP-ENO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcryptは、TCP-ENO [RFC8547]に依存して、接続で暗号化を有効にするかどうか、および使用する鍵合意方式をネゴシエートします。 TCP-ENOは、ENOサブオプションにプロトコル識別子を含めることにより、特定のTCP暗号化プロトコル（TEP）の使用をネゴシエートします。このドキュメントでは、セクション7の表4にリストされているように、4つのTEP識別子をtcpcryptプロトコルに関連付けます。各識別子は、特定の鍵合意方式の使用と、関連するCPRFおよび長さのパラメーターを示します。将来の標準では、TCP-ENOで指定された割り当てポリシーに従って、追加のTEP識別子をtcpcryptに関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An active opener that wishes to negotiate the use of tcpcrypt includes an ENO option in its SYN segment. That option includes suboptions with tcpcrypt TEP identifiers indicating the key-agreement schemes it is willing to enable. The active opener MAY additionally include suboptions indicating support for encryption protocols other than tcpcrypt, as well as global suboptions as specified by TCP-ENO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcryptの使用について交渉したいアクティブなオープナーは、SYNセグメントにENOオプションを含みます。このオプションには、有効にしたい鍵合意方式を示すtcpcrypt TEP識別子を持つサブオプションが含まれます。アクティブなオープナーには、tcpcrypt以外の暗号化プロトコルのサポートを示すサブオプションと、TCP-ENOで指定されているグローバルサブオプションが含まれる場合があります（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener receives an ENO option including tcpcrypt TEPs that it supports, it MAY then attach an ENO option to its SYN-ACK segment, including solely the TEP it wishes to enable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッシブオープナーが、サポートするtcpcrypt TEPを含むENOオプションを受信した場合、有効にするTEPのみを含むENOオプションをそのSYN-ACKセグメントに添付してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To establish distinct roles for the two hosts in each connection, tcpcrypt depends on the role-negotiation mechanism of TCP-ENO. As one result of the negotiation process, TCP-ENO assigns hosts unique roles abstractly called &#34;A&#34; at one end of the connection and &#34;B&#34; at the other. Generally, an active opener plays the &#34;A&#34; role and a passive opener plays the &#34;B&#34; role, but in the case of simultaneous open, an additional mechanism breaks the symmetry and assigns a distinct role to each host. TCP-ENO uses the terms &#34;host A&#34; and &#34;host B&#34; to identify each end of a connection uniquely; this document employs those terms in the same way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各接続で2つのホストに異なる役割を確立するために、tcpcryptはTCP-ENOの役割交渉メカニズムに依存しています。ネゴシエーションプロセスの結果として、TCP-ENOは、接続の一方の端で「A」と抽象的に呼ばれ、もう一方の端で「B」と呼ばれる一意の役割をホストに割り当てます。一般に、アクティブオープナーは「A」の役割を果たし、パッシブオープナーは「B」の役割を果たしますが、同時オープンの場合、追加のメカニズムにより対称性が失われ、各ホストに異なる役割が割り当てられます。 TCP-ENOでは、「ホストA」と「ホストB」という用語を使用して、接続の両端を一意に識別します。このドキュメントでは、これらの用語を同じ方法で使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An ENO suboption includes a flag &#34;v&#34; which indicates the presence of associated variable-length data. In order to propose fresh key agreement with a particular tcpcrypt TEP, a host sends a one-byte suboption containing the TEP identifier and v = 0. In order to propose session resumption (described further below) with a particular TEP, a host sends a variable-length suboption containing the TEP identifier, the flag v = 1, an identifier derived from a session secret previously negotiated with the same host and the same TEP, and a nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENOサブオプションには、関連する可変長データの存在を示すフラグ「v」が含まれています。特定のtcpcrypt TEPとの新しい鍵合意を提案するために、ホストはTEP識別子とv = 0を含む1バイトのサブオプションを送信します。特定のTEPとのセッション再開（以下でさらに説明）を提案するために、ホストはTEP識別子、フラグv = 1、以前に同じホストおよび同じTEPとネゴシエートされたセッションシークレットから派生した識別子、およびナンスを含む可変長サブオプション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once two hosts have exchanged SYN segments, TCP-ENO defines the negotiated TEP to be the last valid TEP identifier in the SYN segment of host B (that is, the passive opener in the absence of simultaneous open) that also occurs in that of host A. If there is no such TEP, hosts MUST disable TCP-ENO and tcpcrypt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのホストがSYNセグメントを交換すると、TCP-ENOは、ネゴシエートされたTEPを、ホストBのSYNセグメント（つまり、同時オープンがない場合のパッシブオープナー）の最後の有効なTEP識別子として定義します。 A.そのようなTEPがない場合、ホストはTCP-ENOおよびtcpcryptを無効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the negotiated TEP was sent by host B with v = 0, it means that fresh key agreement will be performed as described in Section 3.3. If, on the other hand, host B sent the TEP with v = 1 and both hosts sent appropriate resumption identifiers in their suboption data, then the key-exchange messages will be omitted in favor of determining keys via session resumption as described in Section 3.5. With session resumption, protected application data MAY be sent immediately as detailed in Section 3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネゴシエートされたTEPがv = 0でホストBから送信された場合、セクション3.3で説明されているように、新しい鍵合意が実行されます。一方、ホストBがv = 1でTEPを送信し、両方のホストがサブオプションデータで適切な再開識別子を送信した場合、セクション3.5で説明されているように、セッション再開によるキーの決定を優先して、キー交換メッセージは省略されます。 。セッションの再開により、保護されたアプリケーションデータは、セクション3.6で詳述されているようにすぐに送信される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the negotiated TEP is determined without reference to the &#34;v&#34; bits in ENO suboptions, so if host A offers resumption with a particular TEP and host B replies with a non-resumption suboption with the same TEP, that could become the negotiated TEP, in which case fresh key agreement will be performed. That is, sending a resumption suboption also implies willingness to perform fresh key agreement with the indicated TEP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネゴシエートされたTEPはENOサブオプションの「v」ビットを参照せずに決定されるため、ホストAが特定のTEPで再開を提供し、ホストBが同じTEPの非再開サブオプションで応答した場合、ネゴシエートされたTEPになる可能性があることに注意してください。 、その場合、新しい鍵合意が実行されます。つまり、再開サブオプションを送信することは、示されたTEPとの新たな鍵合意を実行する意思があることも意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As REQUIRED by TCP-ENO, once a host has both sent and received an ACK segment containing a valid ENO option, encryption MUST be enabled and plaintext application data MUST NOT ever be exchanged on the connection. If the negotiated TEP is among those listed in Table 4, a host MUST follow the protocol described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENOで要求されるように、ホストが有効なENOオプションを含むACKセグメントを送受信した後は、暗号化を有効にして（MUST）、プレーンテキストのアプリケーションデータを接続で交換してはなりません（MUST）。ネゴシエートされたTEPが表4にリストされているものである場合、ホストはこのドキュメントで説明されているプロトコルに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-3--Key-Exchange">
3.3. Key Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 鍵交換
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following successful negotiation of a tcpcrypt TEP, all further signaling is performed in the Data portion of TCP segments. Except when resumption was negotiated (described in Section 3.5), the two hosts perform key exchange through two messages, Init1 and Init2, at the start of the data streams of host A and host B, respectively. These messages MAY span multiple TCP segments and need not end at a segment boundary. However, the segment containing the last byte of an Init1 or Init2 message MUST have TCP&#39;s push flag (PSH) set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcrypt TEPのネゴシエーションが成功すると、それ以降のすべてのシグナリングはTCPセグメントのデータ部分で実行されます。再開がネゴシエートされた場合（セクション3.5で説明）を除き、2つのホストは、それぞれホストAとホストBのデータストリームの開始時に、2つのメッセージInit1とInit2を介してキー交換を実行します。これらのメッセージは複数のTCPセグメントにまたがる場合があり、セグメント境界で終了する必要はありません。ただし、Init1またはInit2メッセージの最後のバイトを含むセグメントには、TCPのプッシュフラグ（PSH）が設定されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key exchange protocol, in abstract, proceeds as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵交換プロトコルは、要約すると、次のように進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       A -&gt; B:  Init1 = { INIT1_MAGIC, sym_cipher_list, N_A, Pub_A }
       B -&gt; A:  Init2 = { INIT2_MAGIC, sym_cipher, N_B, Pub_B }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concrete format of these messages is specified in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのメッセージの具体的な形式は、セクション4.1で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameters are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメータは次のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o INIT1_MAGIC, INIT2_MAGIC: Constants defined in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o INIT1_MAGIC、INIT2_MAGIC：セクション4.3で定義されている定数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher_list: A list of identifiers of symmetric ciphers (AEAD algorithms) acceptable to host A. These are specified in Table 5 of Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher_list：ホストAが受け入れることができる対称暗号（AEADアルゴリズム）の識別子のリスト。これらは、セクション7の表5で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher: The symmetric cipher selected by host B from the sym_cipher_list sent by host A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher：ホストAが送信したsym_cipher_listからホストBが選択した対称暗号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N_A, N_B: Nonces chosen at random by hosts A and B, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N_A、N_B：ホストAおよびBによってそれぞれランダムに選択されたノンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Pub_A, Pub_B: Ephemeral public keys for hosts A and B, respectively. These, as well as their corresponding private keys, are short-lived values that MUST be refreshed frequently. The private keys SHOULD NOT ever be written to persistent storage. The security risks associated with the storage of these keys are discussed in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Pub_A、Pub_B：ホストAとホストBのエフェメラル公開鍵。これらは、対応する秘密鍵と同様に、頻繁に更新する必要がある存続期間の短い値です。秘密鍵は永続ストレージに書き込まないでください。これらのキーの保存に関連するセキュリティリスクについては、セクション8で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a host receives an ephemeral public key from its peer and a key-validation step fails (see Section 5), it MUST abort the connection and raise an error condition distinct from the end-of-file condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストがピアから一時的な公開キーを受信し、キー検証ステップが失敗した場合（セクション5を参照）、接続を中止し、ファイルの終わりの状態とは異なるエラー状態を発生させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ephemeral secret ES is the result of the key-agreement algorithm (see Section 5) indicated by the negotiated TEP. The inputs to the algorithm are the local host&#39;s ephemeral private key and the remote host&#39;s ephemeral public key. For example, host A would compute ES using its own private key (not transmitted) and host B&#39;s public key, Pub_B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エフェメラルシークレットESは、ネゴシエートされたTEPによって示されるキー合意アルゴリズム（セクション5を参照）の結果です。アルゴリズムへの入力は、ローカルホストの一時的な秘密鍵とリモートホストの一時的な公開鍵です。たとえば、ホストAは独自の秘密鍵（送信されない）とホストBの公開鍵Pub_Bを使用してESを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two sides then compute a pseudo-random key, PRK, from which all session secrets are derived, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、2つのサイドが、次のようにすべてのセッションシークレットが導出される疑似ランダムキーPRKを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
PRK = Extract(N_A, eno_transcript | Init1 | Init2 | ES)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
PRK = Extract（N_A、eno_transcript | Init1 | Init2 | ES）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Above, &#34;|&#34; denotes concatenation, eno_transcript is the protocol-negotiation transcript defined in Section 4.8 of [RFC8547], and Init1 and Init2 are the transmitted encodings of the messages described in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記、「|」は連結を示し、eno_transcriptは[RFC8547]のセクション4.8で定義されたプロトコルネゴシエーショントランスクリプトであり、Init1およびInit2はセクション4.1で説明されているメッセージの送信エンコーディングです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A series of session secrets are computed from PRK as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一連のセッションシークレットは、PRKから次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
ss[0] = PRK ss[i] = CPRF(ss[i-1], CONST_NEXTK, K_LEN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
ss [0] = PRK ss [i] = CPRF（ss [i-1]、CONST_NEXTK、K_LEN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value ss[0] is used to generate all key material for the current connection. The values ss[i] for i &gt; 0 are used by session resumption to avoid public key cryptography when establishing subsequent connections between the same two hosts as described in Section 3.5. The CONST_* values are constants defined in Section 4.3. The length K_LEN depends on the tcpcrypt TEP in use, and is specified in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値ss [0]は、現在の接続のすべてのキーマテリアルを生成するために使用されます。セクション3.5で説明されているように、同じ2つのホスト間で後続の接続を確立するときに公開鍵暗号を回避するために、セッション再開でss [i]の値&gt; 0が使用されます。 CONST_ *値は、セクション4.3で定義されている定数です。長さK_LENは、使用中のtcpcrypt TEPに依存し、セクション5で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a session secret ss[i], the two sides compute a series of master keys as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションシークレットss [i]が与えられると、双方は一連のマスターキーを次のように計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              mk[0] = CPRF(ss[i], CONST_REKEY | sn[i], K_LEN)
              mk[j] = CPRF(mk[j-1], CONST_REKEY, K_LEN)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process of advancing through the series of master keys is described in Section 3.8. The values represented by sn[i] are session nonces. For the initial session with i = 0, the session nonce is zero bytes long. The values for subsequent sessions are derived from fresh connection data as described in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一連のマスターキーを進めるプロセスについては、セクション3.8で説明します。 sn [i]で表される値は、セッションナンスです。 i = 0の初期セッションの場合、セッションnonceの長さは0バイトです。セクション3.5で説明されているように、後続のセッションの値は新しい接続データから導出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, each master key mk[j] is used to generate traffic keys for protecting application data using authenticated encryption:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、各マスターキーmk [j]は、認証された暗号化を使用してアプリケーションデータを保護するためのトラフィックキーを生成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       k_ab[j] = CPRF(mk[j], CONST_KEY_A, ae_key_len + ae_nonce_len)
       k_ba[j] = CPRF(mk[j], CONST_KEY_B, ae_key_len + ae_nonce_len)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first session derived from fresh key agreement, traffic keys k_ab[j] are used by host A to encrypt and host B to decrypt, while keys k_ba[j] are used by host B to encrypt and host A to decrypt. In a resumed session, as described more thoroughly in Section 3.5, each host uses the keys in the same way as it did in the original session, regardless of its role in the current session; for example, if a host played role &#34;A&#34; in the first session, it will use keys k_ab[j] to encrypt in each derived session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい鍵合意から導出された最初のセッションでは、ホストAがトラフィック鍵k_ab [j]を使用して暗号化し、ホストBが復号化します。一方、鍵k_ba [j]はホストBが暗号化し、ホストAが復号化します。再開されたセッションでは、セクション3.5でより詳細に説明されているように、各ホストは、現在のセッションでの役割に関係なく、元のセッションと同じ方法でキーを使用します。たとえば、ホストが最初のセッションで「A」の役割を果たした場合、ホストは鍵k_ab [j]を使用して各派生セッションで暗号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values ae_key_len and ae_nonce_len depend on the authenticated-encryption algorithm selected and are given in Table 3 of Section 6. The algorithm uses the first ae_key_len bytes of each traffic key as an authenticated-encryption key, and it uses the following ae_nonce_len bytes as a nonce randomizer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値ae_key_lenおよびae_nonce_lenは、選択された認証済み暗号化アルゴリズムによって異なり、セクション6の表3に示されています。アルゴリズムは、各トラフィックキーの最初のae_key_lenバイトを認証済み暗号化キーとして使用し、次のae_nonce_lenバイトをaとして使用します。ナンスランダマイザー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD provide an interface allowing the user to specify, for a particular connection, the set of AEAD algorithms to advertise in sym_cipher_list (when playing role &#34;A&#34;) and also the order of preference to use when selecting an algorithm from those offered (when playing role &#34;B&#34;). A companion document [TCPINC-API] describes recommended interfaces for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、ユーザーが特定の接続について、sym_cipher_listで通知するAEADアルゴリズムのセット（ロール &#34;A&#34;を実行する場合）と、提供されたアルゴリズムからアルゴリズムを選択するときに使用する優先順位を指定できるインターフェースを提供する必要があります（SHOULD）。役割「B」）。関連ドキュメント[TCPINC-API]には、この目的で推奨されるインターフェースが記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After host B sends Init2 or host A receives it, that host MAY immediately begin transmitting protected application data as described in Section 3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストBがInit2を送信した後、またはホストAがそれを受信した後、セクション3.6で説明されているように、そのホストはすぐに保護されたアプリケーションデータの送信を開始できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If host A receives Init2 with a sym_cipher value that was not present in the sym_cipher_list it previously transmitted in Init1, it MUST abort the connection and raise an error condition distinct from the end-of-file condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストAが以前にInit1で送信したsym_cipher_listに存在しなかったsym_cipher値を持つInit2を受信した場合、ホストAは接続を中止し、ファイル終了条件とは異なるエラー条件を発生させる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this document, to &#34;abort the connection&#34; means to issue the &#34;Abort&#34; command as described in Section 3.8 of [RFC793]. That is, the TCP connection is destroyed, RESET is transmitted, and the local user is alerted to the abort event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント全体を通して、「接続を中止する」とは、[RFC793]のセクション3.8で説明されている「中止」コマンドを発行することを意味します。つまり、TCP接続が破棄され、RESETが送信されて、ローカルユーザーに中止イベントが通知されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-4--Session-ID">
3.4. Session ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. セッションID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENO requires each TEP to define a session ID value that uniquely identifies each encrypted connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENOでは、各TEPが、暗号化された各接続を一意に識別するセッションID値を定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A tcpcrypt session ID begins with the byte transmitted by host B that contains the negotiated TEP identifier along with the &#34;v&#34; bit. The remainder of the ID is derived from the session secret and session nonce, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcryptセッションIDは、ホストBによって送信されたバイトで始まります。このバイトには、ネゴシエートされたTEP識別子と「v」ビットが含まれています。 IDの残りの部分は、次のように、セッションシークレットとセッションナンスから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
session_id[i] = TEP-byte | CPRF(ss[i], CONST_SESSID | sn[i], K_LEN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
session_id [i] = TEPバイト| CPRF（ss [i]、CONST_SESSID | sn [i]、K_LEN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Again, the length K_LEN depends on the TEP and is specified in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合も、長さK_LENはTEPに依存し、セクション5で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-5--Session-Resumption">
3.5. Session Resumption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. セッション再開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two hosts have previously negotiated a session with secret ss[i-1], they can establish a new connection without public-key operations using ss[i], the next session secret in the sequence derived from the original PRK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのホストが以前に秘密のss [i-1]を使用してセッションをネゴシエートしている場合、元のPRKから派生したシーケンスの次のセッション秘密であるss [i]を使用して、公開鍵操作なしで新しい接続を確立できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host signals its willingness to resume with a particular session secret by sending a SYN segment with a resumption suboption, i.e., an ENO suboption containing the negotiated TEP identifier of the previous session, half of the resumption identifier for the new session, and a resumption nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストは、再開サブオプション、つまり、前のセッションのネゴシエートされたTEP識別子、新しいセッションの再開識別子の半分、および再開を含むENOサブオプションを含むSYNセグメントを送信することにより、特定のセッションシークレットで再開する意思を示します。ナンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The resumption nonce MUST have a minimum length of zero bytes and maximum length of eight bytes. The value MUST be chosen randomly or using a mechanism that guarantees uniqueness even in the face of virtual-machine cloning or other re-execution of the same session. An attacker who can force either side of a connection to reuse a session secret with the same nonce will completely break the security of tcpcrypt. Reuse of session secrets is possible in the event of virtual-machine cloning or reuse of system-level hibernation state. Implementations SHOULD provide an API through which to set the resumption nonce length and MUST default to eight bytes if they cannot prohibit the reuse of session secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
再開ノンスは、最小長が0バイト、最大長が8バイトでなければなりません。値は、ランダムに選択するか、仮想マシンのクローン作成や同じセッションの他の再実行に直面しても一意性を保証するメカニズムを使用して選択する必要があります。攻撃者が接続のいずれかの側に同じノンスでセッションシークレットを再利用するように強制できる場合、tcpcryptのセキュリティが完全に破られます。仮想マシンのクローンまたはシステムレベルの休止状態の再利用の場合、セッションシークレットの再利用が可能です。実装は、再開ノンス長を設定するためのAPIを提供する必要があり、セッションシークレットの再利用を禁止できない場合は、デフォルトで8バイトに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resumption identifier is calculated from a session secret ss[i] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再開識別子は、セッションシークレットss [i]から次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
resume[i] = CPRF(ss[i], CONST_RESUME, 18)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
resume [i] = CPRF（ss [i]、CONST_RESUME、18）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To name a session for resumption, a host sends either the first or second half of the resumption identifier according to the role it played in the original session with secret ss[0].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再開するセッションに名前を付けるには、ホストは、秘密のss [0]を使用して元のセッションで果たした役割に従って再開識別子の前半または後半を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host that originally played role &#34;A&#34; and wishes to resume from a cached session sends a suboption with the first half of the resumption identifier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初に役割「A」を果たし、キャッシュされたセッションから再開したいホストは、再開識別子の前半を含むサブオプションを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         byte     0      1             9      10
              +------+------+--...--+------+------+--...--+------+
              | TEP- |   resume[i]{0..8}   |       nonce_a       |
              | byte |                     |                     |
              +------+------+--...--+------+------+--...--+------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 2: Resumption suboption sent when original role was &#34;A&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図2：元の役割が &#34;A&#34;のときに送信された再開サブオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEP-byte contains a tcpcrypt TEP identifier and v = 1. The nonce value MUST have length between 0 and 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEPバイトには、tcpcrypt TEP識別子とv = 1が含まれます。ナンス値の長さは0〜8バイトでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a host that originally played role &#34;B&#34; sends a suboption with the second half of the resumption identifier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、最初に役割「B」を果たしたホストは、再開識別子の後半を持つサブオプションを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         byte     0      1             9      10
              +------+------+--...--+------+------+--...--+------+
              | TEP- |   resume[i]{9..17}  |       nonce_b       |
              | byte |                     |                     |
              +------+------+--...--+------+------+--...--+------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 3: Resumption suboption sent when original role was &#34;B&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図3：元の役割が「B」のときに送信された再開サブオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEP-byte contains a tcpcrypt TEP identifier and v = 1. The nonce value MUST have length between 0 and 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEPバイトには、tcpcrypt TEP識別子とv = 1が含まれます。ナンス値の長さは0〜8バイトでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 If a passive opener receives a resumption suboption containing an identifier-half that names a session secret that it has cached, and the subobtion&#39;s TEP matches the TEP used in the previous session, it SHOULD (with exceptions specified below) agree to resume from the cached session by sending its own resumption suboption, which will contain the other half of the identifier. Otherwise, it MUST NOT agree to resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
パッシブオープナーが、キャッシュしたセッションシークレットを指定する識別子の半分を含む再開サブオプションを受信し、サブスクリプションのTEPが前のセッションで使用したTEPと一致する場合、（以下に指定されている例外を除いて）キャッシュから再開することに同意する必要があります（SHOULD）識別子の残りの半分を含む独自の再開サブオプションを送信することにより、セッション。それ以外の場合は、再開に同意してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener does not agree to resumption with a particular TEP, it MAY either request fresh key exchange by responding with a non-resumption suboption using the same TEP or else respond to any other received TEP suboption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッシブオープナーが特定のTEPでの再開に同意しない場合は、同じTEPを使用して非再開サブオプションで応答することにより、新しい鍵交換を要求するか、受信した他のTEPサブオプションに応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener receives an ENO suboption with a TEP identifier and v = 1, but the suboption data is less than 9 bytes in length, it MUST behave as if the same TEP had been sent with v = 0. That is, the suboption MUST be interpreted as an offer to negotiate fresh key exchange with that TEP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パッシブオープナーがTEP識別子とv = 1のENOサブオプションを受信したが、サブオプションデータの長さが9バイト未満の場合、同じTEPがv = 0で送信されたかのように動作する必要があります。つまり、サブオプションそのTEPとの新しい鍵交換を交渉する申し出として解釈されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an active opener sends a resumption suboption with a particular TEP and the appropriate half of a resumption identifier, and then, in the same TCP handshake, it receives a resumption suboption with the same TEP and an identifier-half that does not match that resumption identifier, it MUST ignore that suboption. In the typical case that this was the only ENO suboption received, this means the host MUST disable TCP-ENO and tcpcrypt; it MUST NOT send any more ENO options and MUST NOT encrypt the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクティブなオープナーが特定のTEPと再開識別子の適切な半分を持つ再開サブオプションを送信し、同じTCPハンドシェイクで、同じTEPと再開に一致しない識別子半分を持つ再開サブオプションを受信した場合識別子、それはそのサブオプションを無視しなければなりません。これが唯一の受信されたENOサブオプションである典型的なケースでは、これはホストがTCP-ENOとtcpcryptを無効にしなければならないことを意味します。それ以上のENOオプションを送信してはならず、接続を暗号化してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a host concludes that TCP-ENO negotiation has succeeded for some TEP that was received in a resumption suboption, it MUST then enable encryption with that TEP using the cached session secret. To do this, it first constructs sn[i] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストが、再開サブオプションで受信された一部のTEPに対してTCP-ENOネゴシエーションが成功したと結論付けた場合、キャッシュされたセッションシークレットを使用して、そのTEPでの暗号化を有効にする必要があります。これを行うには、最初に次のようにsn [i]を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
sn[i] = nonce_a | nonce_b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
sn [i] = nonce_a | nonce_b
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Master keys are then computed from s[i] and sn[i] as described in Section 3.3 as well as from application data encrypted as described in Section 3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、セクション3.3で説明されているようにs [i]とsn [i]から、およびセクション3.6で説明されているように暗号化されたアプリケーションデータからマスターキーが計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The session ID (Section 3.4) is constructed in the same way for resumed sessions as it is for fresh ones. In this case, the first byte will always have v = 1. The remainder of the ID is derived from the cached session secret and the session nonce that was generated during resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションID（セクション3.4）は、再開されたセッションの場合と同じ方法で作成されます。この場合、最初のバイトは常にv = 1になります。IDの残りの部分は、キャッシュされたセッションシークレットと、再開中に生成されたセッションナンスから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of simultaneous open where TCP-ENO is able to establish asymmetric roles, two hosts that simultaneously send SYN segments with compatible resumption suboptions MAY resume the associated session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENOが非対称の役割を確立できる同時オープンの場合、互換性のある再開サブオプションでSYNセグメントを同時に送信する2つのホストは、関連付けられたセッションを再開できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In a particular SYN segment, a host SHOULD NOT send more than one resumption suboption (because this consumes TCP option space and is unlikely to be a useful practice), and it MUST NOT send more than one resumption suboption with the same TEP identifier. But in addition to any resumption suboptions, an active opener MAY include non-resumption suboptions describing other TEPs it supports (in addition to the TEP in the resumption suboption).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
特定のSYNセグメントでは、ホストは複数の再開サブオプションを送信してはいけません（これはTCPオプションスペースを消費し、実用的ではないため）。同じTEP識別子で複数の再開サブオプションを送信してはなりません（MUST NOT）。ただし、再開サブオプションに加えて、アクティブなオープナーには、それがサポートする他のTEPを記述する非再開サブオプションが含まれる場合があります（再開サブオプションのTEPに加えて）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After using the session secret ss[i] to compute mk[0], implementations SHOULD compute and cache ss[i+1] for possible use by a later session and then erase ss[i] from memory. Hosts MAY retain ss[i+1] until it is used or the memory needs to be reclaimed. Hosts SHOULD NOT write any session secrets to non-volatile storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションシークレットss [i]を使用してmk [0]を計算した後、実装は、後のセッションで使用できるようにss [i + 1]を計算してキャッシュし、メモリからss [i]を消去する必要があります。ホストは、ss [i + 1]を使用するか、メモリを解放する必要があるまで保持する場合があります。ホストは、セッションシークレットを不揮発性ストレージに書き込まないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When proposing resumption, the active opener MUST use the lowest value of &#34;i&#34; that has not already been used (successfully or not) to negotiate resumption with the same host and for the same original session secret ss[0].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再開を提案する場合、アクティブなオープナーは、同じホストと同じ元のセッションシークレットss [0]で再開をネゴシエートするために（成功したかどうかにかかわらず）まだ使用されていない「i」の最小値を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A given session secret ss[i] MUST NOT be used to secure more than one TCP connection. To prevent this, a host MUST NOT resume with a session secret if it has ever enabled encryption in the past with the same secret, in either role. In the event that two hosts simultaneously send SYN segments to each other that propose resumption with the same session secret but with both segments not part of a simultaneous open, both connections would need to revert to fresh key exchange. To avoid this limitation, implementations MAY choose to implement session resumption such that all session secrets derived from a given ss[0] are used for either passive or active opens at the same host, not both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のセッションシークレットss [i]を使用して、複数のTCP接続を保護することはできません。これを防ぐために、いずれかの役割で同じシークレットを使用して過去に暗号化を有効にしたことがあるホストは、セッションシークレットで再開してはなりません。 2つのホストが同じセッションシークレットを使用して再開を提案するSYNセグメントを相互に同時に送信するが、両方のセグメントが同時オープンの一部ではない場合、両方の接続を新しいキー交換に戻す必要があります。この制限を回避するために、実装は、特定のss [0]から派生したすべてのセッションシークレットが同じホストの両方ではなくパッシブまたはアクティブオープンに使用されるように、セッション再開を実装することを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two hosts have previously negotiated a tcpcrypt session, either host MAY later initiate session resumption regardless of which host was the active opener or played the &#34;A&#34; role in the previous session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのホストが以前にtcpcryptセッションをネゴシエートした場合、どちらのホストも、アクティブなオープナーであるか、前のセッションで「A」の役割を果たしたかに関係なく、後でセッションの再開を開始できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, a given host MUST either encrypt with keys k_ab[j] for all sessions derived from the same original session secret ss[0], or with keys k_ba[j]. Thus, which keys a host uses to send segments is not affected by the role it plays in the current connection: it depends only on whether the host played the &#34;A&#34; or &#34;B&#34; role in the initial session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、特定のホストは、同じ元のセッションシークレットss [0]から派生したすべてのセッションのキーk_ab [j]で暗号化するか、キーk_ba [j]で暗号化する必要があります。したがって、ホストがセグメントの送信に使用するキーは、現在の接続で果たす役割の影響を受けません。これは、ホストが初期セッションで「A」または「B」のどちらの役割を果たしたかにのみ依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Implementations that cache session secrets MUST provide a means for applications to control that caching. In particular, when an application requests a new TCP connection, it MUST have a way to specify two policies for the duration of the connection: 1) that resumption requests will be ignored, and thus fresh key exchange will be necessary; and 2) that no session secrets will be cached. (These policies can be specified independently or as a unit.) And for an established connection, an application MUST have a means to cause any cache state that was used in or resulted from establishing the connection to be flushed. A companion document [TCPINC-API] describes recommended interfaces for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
セッションシークレットをキャッシュする実装は、アプリケーションがそのキャッシングを制御する手段を提供する必要があります。特に、アプリケーションが新しいTCP接続を要求する場合、接続の持続時間に対して2つのポリシーを指定する方法が必要です。1）再開要求が無視されるため、新しい鍵交換が必要になります。 2）セッションシークレットはキャッシュされません。 （これらのポリシーは独立して、またはユニットとして指定できます。）また、確立された接続の場合、アプリケーションは、接続の確立で使用された、または接続の確立から生じたキャッシュ状態をフラッシュする手段を備えている必要があります。関連ドキュメント[TCPINC-API]には、この目的で推奨されるインターフェースが記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-6--Data-Encryption-and-Authentication">
3.6. Data Encryption and Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. データの暗号化と認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following key exchange (or its omission via session resumption), all further communication in a tcpcrypt-enabled connection is carried out within delimited encryption frames that are encrypted and authenticated using the agreed-upon keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵交換（またはセッション再開による省略）に続いて、tcpcrypt対応接続での以降のすべての通信は、合意された鍵を使用して暗号化および認証される区切られた暗号化フレーム内で実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protection is provided via algorithms for Authenticated Encryption with Associated Data (AEAD). The permitted algorithms are listed in Table 5 of Section 7. Additional algorithms can be specified in the future according to the policy in that section. One algorithm is selected during the negotiation described in Section 3.3. The lengths ae_key_len and ae_nonce_len associated with each algorithm are found in Table 3 of Section 6 along with requirements for which algorithms MUST be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この保護は、関連データを伴う認証済み暗号化（AEAD）のアルゴリズムを介して提供されます。許可されるアルゴリズムは、セクション7の表5にリストされています。追加のアルゴリズムは、そのセクションのポリシーに従って将来指定できます。セクション3.3で説明されているネゴシエーション中に1つのアルゴリズムが選択されます。各アルゴリズムに関連付けられている長さae_key_lenおよびae_nonce_lenは、アルゴリズムを実装する必要がある要件とともに、セクション6の表3にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The format of an encryption frame is specified in Section 4.2. A sending host breaks its stream of application data into a series of chunks. Each chunk is placed in the data field of a plaintext value, which is then encrypted to yield a frame&#39;s ciphertext field. Chunks MUST be small enough that the ciphertext (whose length depends on the AEAD cipher used, and is generally slightly longer than the plaintext) has length less than 2^16 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化フレームのフォーマットはセクション4.2で指定されています。送信ホストは、アプリケーションデータのストリームを一連のチャンクに分割します。各チャンクは、プレーンテキスト値のデータフィールドに配置されます。次に、それが暗号化されて、フレームの暗号テキストフィールドが生成されます。チャンクは、暗号文の長さ（使用するAEAD暗号に依存し、通常は平文よりも少し長い）の長さが2 ^ 16バイト未満である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;associated data&#34; value (see Section 4.2.2) is constructed for the frame. It contains the frame&#39;s control field and the length of the ciphertext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「関連データ」値（セクション4.2.2を参照）は、フレームに対して構成されます。フレームの制御フィールドと暗号文の長さが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A &#34;frame ID&#34; value (see Section 4.2.3) is also constructed for the frame, but not explicitly transmitted. It contains a 64-bit offset field whose integer value is the zero-indexed byte offset of the beginning of the current encryption frame in the underlying TCP datastream. (That is, the offset in the framing stream, not the plaintext application stream.) The offset is then left-padded with zero-valued bytes to form a value of length ae_nonce_len. Because it is strictly necessary for the security of the AEAD algorithms specified in this document, an implementation MUST NOT ever transmit distinct frames with the same frame ID value under the same encryption key. In particular, a retransmitted TCP segment MUST contain the same payload bytes for the same TCP sequence numbers, and a host MUST NOT transmit more than 2^64 bytes in the underlying TCP datastream (which would cause the offset field to wrap) before rekeying as described in Section 3.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「フレームID」値（セクション4.2.3を参照）もフレームに対して作成されますが、明示的に送信されるわけではありません。これには64ビットのオフセットフィールドが含まれており、その整数値は、基になるTCPデータストリーム内の現在の暗号化フレームの先頭のゼロから始まるバイトオフセットです。 （つまり、プレーンテキストアプリケーションストリームではなく、フレーミングストリーム内のオフセットです。）次に、オフセットにゼロ値のバイトが左側に埋め込まれ、長さae_nonce_lenの値が形成されます。このドキュメントで指定されているAEADアルゴリズムのセキュリティのために厳密に必要であるため、実装は、同じ暗号化キーの下で同じフレームID値を持つ個別のフレームを送信してはなりません。特に、再送信されたTCPセグメントには、同じTCPシーケンス番号に対して同じペイロードバイトが含まれている必要があり、ホストは、基になるTCPデータストリームで2 ^ 64バイトを超えて送信してはなりません（これにより、オフセットフィールドがラップされます）。セクション3.8で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keys for AEAD encryption are taken from the traffic key k_ab[j] or k_ba[j] for some &#34;j&#34;, according to the host&#39;s role as described in Section 3.3. First, the appropriate traffic key is divided into two parts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD暗号化のキーは、セクション3.3で説明されているホストの役割に従って、一部の「j」のトラフィックキーk_ab [j]またはk_ba [j]から取得されます。まず、適切なトラフィックキーは2つの部分に分かれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                      ae_key_len + ae_nonce_len - 1
                                                       |
        byte  0                    ae_key_len          |
              |                           |            |
              v                           v            v
            +----+----+--...--+----+----+----+--...--+----+
            |             K             |        NR       |
            +----+----+--...--+----+----+----+--...--+----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 4: Format of Traffic Key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図4：トラフィックキーのフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With reference to the &#34;AEAD Interface&#34; described in Section 2 of [RFC5116], the first ae_key_len bytes of the traffic key provide the AEAD key K. The remaining ae_nonce_len bytes provide a nonce randomizer value NR, which is combined via bitwise exclusive-or with the frame ID to yield N, the AEAD nonce for the frame:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5116]のセクション2で説明されている「AEADインターフェース」を参照すると、トラフィックキーの最初のae_key_lenバイトがAEADキーKを提供します。残りのae_nonce_lenバイトはノンスランダマイザー値NRを提供します。フレームIDをNにすると、フレームのAEADナンスは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                            N = frame_ID XOR NR
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining AEAD inputs, P and A, are provided by the frame&#39;s plaintext value and associated data, respectively. The output of the AEAD operation, C, is transmitted in the frame&#39;s ciphertext field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りのAEAD入力、PとAは、それぞれフレームの平文値と関連データによって提供されます。 AEAD操作の出力Cは、フレームの暗号文フィールドで送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a frame is received, tcpcrypt reconstructs the associated data and frame ID values (the former contains only data sent in the clear, and the latter is implicit in the TCP stream), computes the nonce N as above, and provides these and the ciphertext value to the AEAD decryption operation. The output of this operation is either a plaintext value P or the special symbol FAIL. In the latter case, the implementation SHOULD abort the connection and raise an error condition distinct from the end-of-file condition. But if none of the TCP segment(s) containing the frame have been acknowledged and retransmission could potentially result in a valid frame, an implementation MAY instead drop these segments (and renege if they have been selectively acknowledged (SACKed), according to Section 8 of [RFC2018]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレームを受信すると、tcpcryptは関連するデータとフレームID値を再構築し（前者はクリアテキストで送信されたデータのみを含み、後者はTCPストリームで暗黙的です）、上記のようにナンスNを計算し、これらと暗号文を提供しますAEAD復号化操作の値。この操作の出力は、プレーンテキストの値Pまたは特殊記号FAILのいずれかです。後者の場合、実装は接続を中止し、ファイル終了条件とは異なるエラー条件を発生させる必要があります（SHOULD）。ただし、フレームを含むTCPセグメントのいずれも確認されておらず、再送信により有効なフレームが生じる可能性がある場合、セクション8によると、実装は代わりにこれらのセグメントを削除（およびそれらが選択的に確認（SACKされた）した場合は無効にすることができます） [RFC2018]の）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-7--TCP-Header-Protection">
3.7. TCP Header Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. TCPヘッダー保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ciphertext field of the encryption frame contains protected versions of certain TCP header values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化フレームの暗号文フィールドには、特定のTCPヘッダー値の保護されたバージョンが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the URGp bit is set, the urgent field indicates an offset from the current frame&#39;s beginning offset; the sum of these offsets gives the index of the last byte of urgent data in the application datastream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URGpビットが設定されている場合、緊急フィールドは現在のフレームの開始オフセットからのオフセットを示します。これらのオフセットの合計は、アプリケーションデータストリーム内の緊急データの最後のバイトのインデックスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST set the FINp bit on the last frame it sends in the connection (unless it aborts the connection) and MUST NOT set FINp on any other frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、接続で送信する最後のフレームにFINpビットを設定しなければならず（接続を中止しない限り）、他のフレームにはFINpを設定してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP sets the FIN flag when a sender has no more data, which with tcpcrypt means setting FIN on the segment containing the last byte of the last frame. However, a receiver MUST report the end-of-file condition to the connection&#39;s local user when and only when it receives a frame with the FINp bit set. If a host receives a segment with the TCP FIN flag set but the received datastream including this segment does not contain a frame with FINp set, the host SHOULD abort the connection and raise an error condition distinct from the end-of-file condition. But if there are unacknowledged segments whose retransmission could potentially result in a valid frame, the host MAY instead drop the segment with the TCP FIN flag set (and renege if it has been SACKed, according to Section 8 of [RFC2018]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPは、送信者にデータがなくなったときにFINフラグを設定します。これは、tcpcryptを使用すると、最後のフレームの最後のバイトを含むセグメントにFINを設定することを意味します。ただし、受信者は、FINpビットが設定されたフレームを受信したときにのみ、ファイルの終わり条件を接続のローカルユーザーに報告する必要があります。ホストがTCP FINフラグが設定されたセグメントを受信したが、このセグメントを含む受信データストリームにFINpが設定されたフレームが含まれていない場合、ホストは接続を中止し、ファイルの終わりの状態とは異なるエラー状態を発生させる必要があります（SHOULD）。ただし、再送信によって有効なフレームが生成される可能性がある未確認のセグメントがある場合、ホストは代わりにTCP FINフラグが設定されたセグメントをドロップできます（[RFC2018]のセクション8に従って、SACKされている場合は破棄します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-8--Rekeying">
3.8. Rekeying
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. 鍵の再生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rekeying allows hosts to wipe from memory keys that could decrypt previously transmitted segments. It also allows the use of AEAD ciphers that can securely encrypt only a bounded number of messages under a given key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーの再生成により、ホストは、以前に送信されたセグメントを解読する可能性のあるメモリキーを消去できます。また、所定のキーの下で制限された数のメッセージのみを安全に暗号化できるAEAD暗号を使用することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 3.3, a master key mk[j] is used to generate two encryption keys k_ab[j] and k_ba[j]. We refer to these as a key set with generation number &#34;j&#34;. Each host maintains both a local generation number that determines which key set it uses to encrypt outgoing frames and a remote generation number equal to the highest generation used in frames received from its peer. Initially, these two generation numbers are set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.3で説明したように、マスターキーmk [j]を使用して、2つの暗号化キーk_ab [j]およびk_ba [j]を生成します。これらを世代番号「j」のキーセットと呼びます。各ホストは、発信フレームの暗号化に使用するキーセットを決定するローカル世代番号と、ピアから受信したフレームで使用される最も高い世代に等しいリモート世代番号の両方を維持します。最初は、これらの2つの世代番号はゼロに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host MAY increment its local generation number beyond the remote generation number it has recorded. We call this action &#34;initiating rekeying&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストは、ローカルの世代番号を、記録したリモートの世代番号を超えて増分してもよい（MAY）。このアクションを「キーの再発行」と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a host has incremented its local generation number and uses the new key set for the first time to encrypt an outgoing frame, it MUST set rekey = 1 for that frame. It MUST set rekey = 0 in all other cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストがローカル生成番号を増分し、新しいキーセットを初めて使用して送信フレームを暗号化する場合、そのフレームに対してrekey = 1を設定する必要があります。それ以外の場合はすべて、rekey = 0を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a host receives a frame with rekey = 1, it increments its record of the remote generation number. If the remote generation number is now greater than the local generation number, the receiver MUST immediately increment its local generation number to match. Moreover, if the receiver has not yet transmitted a segment with the FIN flag set, it MUST immediately send a frame (with empty application data if necessary) with rekey = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストがrekey = 1のフレームを受信すると、リモート世代番号のレコードを増分します。リモート世代番号がローカル世代番号よりも大きい場合、レシーバーはローカル世代番号をすぐにインクリメントして一致させる必要があります。さらに、受信者がFINフラグが設定されたセグメントをまだ送信していない場合は、rekey = 1のフレーム（必要に応じて空のアプリケーションデータを含む）を直ちに送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host MUST NOT initiate more than one concurrent rekey operation if it has no data to send; that is, it MUST NOT initiate rekeying with an empty encryption frame more than once while its record of the remote generation number is less than its own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信するデータがない場合、ホストは複数の同時キー更新操作を開始してはなりません（MUST NOT）。つまり、リモートの世代番号の記録が自身の記録よりも少ない間は、空の暗号化フレームでキーの再生成を複数回開始してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when parts of the datastream are retransmitted, TCP requires that implementations always send the same data bytes for the same TCP sequence numbers. Thus, frame data in retransmitted segments MUST be encrypted with the same key as when it was first transmitted, regardless of the current local generation number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データストリームの一部が再送信される場合、TCPでは実装が常に同じTCPシーケンス番号に対して同じデータバイトを送信する必要があることに注意してください。したがって、再送信されたセグメントのフレームデータは、現在のローカル世代番号に関係なく、最初に送信されたときと同じキーで暗号化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD delete older-generation keys from memory once they have received all frames they will need to decrypt with the old keys and have encrypted all outgoing frames under the old keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、古いキーで復号化する必要があるすべてのフレームを受信し、古いキーですべての送信フレームを暗号化したら、メモリから古い世代のキーを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-9--Keep-Alive">
3.9. Keep-Alive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. 生き続ける
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of using TCP keep-alives to verify that the remote endpoint is still responsive, tcpcrypt implementations SHOULD employ the rekeying mechanism for this purpose, as follows. When necessary, a host SHOULD probe the liveness of its peer by initiating rekeying and transmitting a new frame immediately (with empty application data if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPキープアライブを使用してリモートエンドポイントがまだ応答していることを確認する代わりに、tcpcryptの実装では、次のように、この目的で鍵の再生成メカニズムを使用する必要があります（SHOULD）。必要に応じて、ホストは、キーの再生成を開始して新しいフレームをすぐに送信することにより（必要な場合は空のアプリケーションデータを使用して）、ピアの活性を調査する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 3.8, a host receiving a frame encrypted under a generation number greater than its own MUST increment its own generation number and (if it has not already transmitted a segment with FIN set) immediately transmit a new frame (with zero-length application data if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.8で説明されているように、自身の世代番号よりも大きい世代番号で暗号化されたフレームを受信するホストは、自身の世代番号をインクリメントし（FINが設定されたセグメントをまだ送信していない場合）、すぐに新しいフレーム（長さ0のフレーム）を送信する必要があります必要に応じてアプリケーションデータ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MAY use TCP keep-alives for purposes that do not require endpoint authentication, as discussed in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション8.2で説明されているように、実装はエンドポイント認証を必要としない目的のためにTCPキープアライブを使用してもよい（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Encodings">
4. Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. エンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides byte-level encodings for values transmitted or computed by the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、プロトコルによって送信または計算される値のバイトレベルのエンコーディングを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Key-Exchange-Messages">
4.1. Key-Exchange Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Init1 message has the following encoding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Init1メッセージのエンコードは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       byte   0       1       2       3
          +-------+-------+-------+-------+
          |          INIT1_MAGIC          |
          |                               |
          +-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  4        5      6       7
              +-------+-------+-------+-------+
              |          message_len          |
              |              = M              |
              +-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  8
              +--------+-----+----+-----+----+---...---+-----+-----+
              |nciphers|sym_      |sym_      |         |sym_       |
              | = K    |cipher[0] |cipher[1] |         |cipher[K-1]|
              +--------+-----+----+-----+----+---...---+-----+-----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               2*K + 9                     2*K + 9 + N_A_LEN
                  |                         |
                  v                         v
              +-------+---...---+-------+-------+---...---+-------+
              |           N_A           |          Pub_A          |
              |                         |                         |
              +-------+---...---+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  M - 1
              +-------+---...---+-------+
              |         ignored         |
              |                         |
              +-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The constant INIT1_MAGIC is defined in Section 4.3. The four-byte field message_len gives the length of the entire Init1 message, encoded as a big-endian integer. The nciphers field contains an integer value that specifies the number of two-byte symmetric-cipher identifiers that follow. The sym_cipher[i] identifiers indicate cryptographic algorithms in Table 5 in Section 7. The length N_A_LEN and the length of Pub_A are both determined by the negotiated TEP as described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
定数INIT1_MAGICはセクション4.3で定義されています。 4バイトのフィールドmessage_lenは、ビッグエンディアン整数としてエンコードされたInit1メッセージ全体の長さを示します。 nciphersフィールドには、続く2バイトの対称暗号識別子の数を指定する整数値が含まれています。 sym_cipher [i]識別子は、セクション7の表5の暗号アルゴリズムを示します。長さN_A_LENとPub_Aの長さは、セクション5で説明されているように、ネゴシエートされたTEPによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of this protocol MUST construct Init1 such that the ignored field has zero length; that is, they MUST construct the message such that its end, as determined by message_len, coincides with the end of the field Pub_A. When receiving Init1, however, implementations MUST permit and ignore any bytes following Pub_A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルの実装では、無視されたフィールドの長さがゼロになるようにInit1を構築する必要があります。つまり、message_lenによって決定されるその終わりがフィールドPub_Aの終わりと一致するように、メッセージを構築する必要があります。ただし、Init1を受信する場合、実装はPub_Aに続くバイトを許可および無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Init2 message has the following encoding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Init2メッセージのエンコードは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       byte   0       1       2       3
          +-------+-------+-------+-------+
          |          INIT2_MAGIC          |
          |                               |
          +-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  4        5      6       7       8       9
              +-------+-------+-------+-------+-------+-------+
              |          message_len          |  sym_cipher   |
              |              = M              |               |
              +-------+-------+-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  10                      10 + N_B_LEN
                  |                         |
                  v                         v
              +-------+---...---+-------+-------+---...---+-------+
              |           N_B           |          Pub_B          |
              |                         |                         |
              +-------+---...---+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  M - 1
              +-------+---...---+-------+
              |          ignored        |
              |                         |
              +-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constant INIT2_MAGIC is defined in Section 4.3. The four-byte field message_len gives the length of the entire Init2 message, encoded as a big-endian integer. The sym_cipher value is a selection from the symmetric-cipher identifiers in the previously-received Init1 message. The length N_B_LEN and the length of Pub_B are both determined by the negotiated TEP as described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定数INIT2_MAGICはセクション4.3で定義されています。 4バイトのフィールドmessage_lenは、ビッグエンディアン整数としてエンコードされたInit2メッセージ全体の長さを示します。 sym_cipher値は、以前に受信したInit1メッセージの対称暗号識別子からの選択です。セクション5で説明されているように、長さN_B_LENとPub_Bの長さはどちらも、ネゴシエートされたTEPによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of this protocol MUST construct Init2 such that the field &#34;ignored&#34; has zero length; that is, they MUST construct the message such that its end, as determined by message_len, coincides with the end of the Pub_B field. When receiving Init2, however, implementations MUST permit and ignore any bytes following Pub_B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロトコルの実装は、「無視」フィールドの長さがゼロになるようにInit2を構築する必要があります。つまり、message_lenによって決定される最後がPub_Bフィールドの最後と一致するようにメッセージを構築する必要があります。ただし、Init2を受信する場合、実装はPub_Bに続くバイトを許可および無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Encryption-Frames">
4.2. Encryption Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 暗号化フレーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An encryption frame comprises a control byte and a length-prefixed ciphertext value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化フレームは、制御バイトと長さが前に付けられた暗号文の値で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          byte   0       1       2       3               clen+2
             +-------+-------+-------+-------+---...---+-------+
             |control|      clen     |        ciphertext       |
             +-------+-------+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field clen is an integer in big-endian format and gives the length of the ciphertext field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドclenはビッグエンディアン形式の整数で、暗号文フィールドの長さを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control field has this structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御フィールドの構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  bit     7                 1       0
                      +-------+---...---+-------+-------+
                      |          cres           | rekey |
                      +-------+---...---+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The seven-bit field cres is reserved; implementations MUST set these bits to zero when sending and MUST ignore them when receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7ビットのフィールドcresは予約されています。実装では、送信時にこれらのビットをゼロに設定する必要があり、受信時には無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the rekey field is described in Section 3.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キー再生成フィールドの使用については、セクション3.8で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-1--Plaintext">
4.2.1. Plaintext
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 平文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ciphertext field is the result of applying the negotiated authenticated-encryption algorithm to a plaintext value, which has one of these two formats:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号文フィールドは、ネゴシエートされた認証済み暗号化アルゴリズムをプレーンテキスト値に適用した結果であり、次の2つの形式のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          byte   0       1               plen-1
             +-------+-------+---...---+-------+
             | flags |           data          |
             +-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          byte   0       1       2       3               plen-1
             +-------+-------+-------+-------+---...---+-------+
             | flags |    urgent     |          data           |
             +-------+-------+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note that clen in the previous section will generally be greater than plen, as the ciphertext produced by the authenticated-encryption scheme both encrypts the application data and provides redundancy with which to verify its integrity.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（前のセクションのclenは、認証済み暗号化スキームによって生成された暗号文がアプリケーションデータを暗号化し、整合性を検証するための冗長性を提供するため、一般的にplenより大きくなることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flags field has this structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグフィールドの構造は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               bit    7    6    5    4    3    2    1    0
                   +----+----+----+----+----+----+----+----+
                   |            fres             |URGp|FINp|
                   +----+----+----+----+----+----+----+----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The six-bit field fres is reserved; implementations MUST set these six bits to zero when sending, and MUST ignore them when receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6ビットのフィールドfresは予約されています。実装は、送信時にこれらの6ビットをゼロに設定しなければならず、受信時にそれらを無視しなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the URGp bit is set, it indicates that the urgent field is present, and thus that the plaintext value has the second structure variant above; otherwise, the first variant is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URGpビットが設定されている場合、緊急フィールドが存在すること、したがって平文値が上記の2番目の構造バリアントを持つことを示します。それ以外の場合は、最初のバリアントが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the urgent field and of the flag bits is described in Section 3.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
緊急フィールドとフラグビットの意味については、セクション3.7で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-2--Associated-Data">
4.2.2. Associated Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 関連データ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An encryption frame&#39;s associated data (which is supplied to the AEAD algorithm when decrypting the ciphertext and verifying the frame&#39;s integrity) has this format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化フレームの関連データ（暗号化テキストを復号化してフレームの整合性を検証するときにAEADアルゴリズムに提供される）の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       byte   0       1       2
                          +-------+-------+-------+
                          |control|     clen      |
                          +-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It contains the same values as the frame&#39;s control and clen fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これには、フレームのコントロールおよびclenフィールドと同じ値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2-3--Frame-ID">
4.2.3. Frame ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. フレームID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, a frame ID (used to construct the nonce for the AEAD algorithm) has this format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、フレームID（AEADアルゴリズムのナンスを構築するために使用される）は次の形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          byte  0            ae_nonce_len - 8    ae_nonce_len - 1
                |                   |             |
                v                   v             v
             +-----+--...--+-----+-----+--...--+-----+
             |  0  |       |  0  |       offset      |
             +-----+--...--+-----+-----+--...--+-----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 8-byte offset field contains an integer in big-endian format. Its value is specified in Section 3.6. Zero-valued bytes are prepended to the offset field to form a structure of length ae_nonce_len.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8バイトのオフセットフィールドには、ビッグエンディアン形式の整数が含まれます。その値はセクション3.6で指定されています。ゼロ値のバイトがオフセットフィールドの前に付加され、長さae_nonce_lenの構造を形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--Constant-Values">
4.3. Constant Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 定数値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The table below defines values for the constants used in the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の表は、プロトコルで使用される定数の値を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       +------------+--------------+
                       | Value      | Name         |
                       +------------+--------------+
                       | 0x01       | CONST_NEXTK  |
                       | 0x02       | CONST_SESSID |
                       | 0x03       | CONST_REKEY  |
                       | 0x04       | CONST_KEY_A  |
                       | 0x05       | CONST_KEY_B  |
                       | 0x06       | CONST_RESUME |
                       | 0x15101a0e | INIT1_MAGIC  |
                       | 0x097105e0 | INIT2_MAGIC  |
                       +------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Table 1: Constant Values Used in the Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
表1：プロトコルで使用される定数値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Key-Agreement-Schemes">
5. Key-Agreement Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 鍵合意スキーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEP negotiated via TCP-ENO indicates the use of one of the key-agreement schemes named in Table 4 in Section 7. For example, TCPCRYPT_ECDHE_P256 names the tcpcrypt protocol using ECDHE-P256 together with the CPRF and length parameters specified below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENOを介してネゴシエートされたTEPは、セクション7の表4に示されている鍵合意方式の1つを使用していることを示します。たとえば、TCPCRYPT_ECDHE_P256は、以下で指定されているCPRFおよび長さパラメーターと共にECDHE-P256を使用するtcpcryptプロトコルに名前を付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the TEPs specified in this document require the use of HKDF-Expand-SHA256 as the CPRF, and these lengths for nonces and session secrets:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで指定されているすべてのTEPでは、CPRFとしてHKDF-Expand-SHA256を使用する必要があり、ノンスとセッションシークレットの長さは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
N_A_LEN: 32 bytes N_B_LEN: 32 bytes K_LEN: 32 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
N_A_LEN：32バイトN_B_LEN：32バイトK_LEN：32バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future documents assigning additional TEPs for use with tcpcrypt might specify different values for the lengths above. Note that the minimum session ID length specified by TCP-ENO, together with the way tcpcrypt constructs session IDs, implies that K_LEN MUST have length at least 32 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcryptで使用するために追加のTEPを割り当てる将来のドキュメントでは、上記の長さに異なる値を指定する可能性があります。 TCP-ENOで指定された最小のセッションIDの長さは、tcpcryptがセッションIDを構築する方法とともに、K_LENが少なくとも32バイトの長さを持っている必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Key-agreement schemes ECDHE-P256 and ECDHE-P521 employ the Elliptic Curve Secret Value Derivation Primitive, Diffie-Hellman version (ECSVDP-DH) defined in [IEEE-1363]. The named curves are defined in [NIST-DSS]. When the public-key values Pub_A and Pub_B are transmitted as described in Section 4.1, they are encoded with the &#34;Elliptic Curve Point to Octet String Conversion Primitive&#34; described in Section E.2.3 of [IEEE-1363] and are prefixed by a two-byte length in big-endian format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
鍵合意方式ECDHE-P256およびECDHE-P521は、[IEEE-1363]で定義されている楕円曲線秘密値導出プリミティブ、Diffie-Hellmanバージョン（ECSVDP-DH）を採用しています。名前付き曲線は[NIST-DSS]で定義されています。公開鍵の値Pub_AとPub_Bがセクション4.1で説明されているように送信されると、[IEEE-1363]のセクションE.2.3で説明されている「楕円曲線ポイントからオクテット文字列への変換プリミティブ」でエンコードされ、先頭に2ビッグエンディアン形式のバイト長：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              byte   0       1       2               L - 1
                 +-------+-------+-------+---...---+-------+
                 |   pubkey_len  |          pubkey         |
                 |      = L      |                         |
                 +-------+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST encode these pubkey values in &#34;compressed format&#34;. Implementations MUST validate these pubkey values according to the algorithm in Section A.16.10 of [IEEE-1363].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装では、これらのpubkey値を「圧縮形式」でエンコードする必要があります。 [IEEE-1363]のセクションA.16.10のアルゴリズムに従って、実装はこれらのpubkey値を検証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key-agreement schemes ECDHE-Curve25519 and ECDHE-Curve448 perform the Diffie-Hellman protocol using the functions X25519 and X448, respectively. Implementations SHOULD compute these functions using the algorithms described in [RFC7748]. When they do so, implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. Alternative implementations of these functions SHOULD abort when either input forces the shared secret to one of a small set of values as discussed in Section 7 of [RFC7748].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵合意方式ECDHE-Curve25519およびECDHE-Curve448は、それぞれ関数X25519およびX448を使用してDiffie-Hellmanプロトコルを実行します。実装は、[RFC7748]で説明されているアルゴリズムを使用してこれらの関数を計算する必要があります（SHOULD）。その場合、[RFC7748]のセクション6で説明されているように、実装は計算されたDiffie-Hellman共有秘密がすべてゼロの値であるかどうかをチェックし、そうである場合は中止する必要があります。これらの関数の代替実装は、[RFC7748]のセクション7で説明されているように、いずれかの入力が共有シークレットを小さな値のセットの1つに強制したときに中止する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For these schemes, public-key values Pub_A and Pub_B are transmitted directly with no length prefix: 32 bytes for ECDHE-Curve25519 and 56 bytes for ECDHE-Curve448.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのスキームの場合、公開鍵の値Pub_AおよびPub_Bは、長さの接頭辞なしで直接送信されます。ECDHE-Curve25519の場合は32バイト、ECDHE-Curve448の場合は56バイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2 below specifies the requirement levels of the four TEPs specified in this document. In particular, all implementations of tcpcrypt MUST support TCPCRYPT_ECDHE_Curve25519. However, system administrators MAY configure which TEPs a host will negotiate independent of these implementation requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の表2は、このドキュメントで指定されている4つのTEPの要件レベルを示しています。特に、tcpcryptのすべての実装はTCPCRYPT_ECDHE_Curve25519をサポートする必要があります。ただし、システム管理者は、これらの実装要件とは関係なく、ホストがネゴシエートするTEPを構成できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +-------------+---------------------------+
                | Requirement | TEP                       |
                +-------------+---------------------------+
                | REQUIRED    | TCPCRYPT_ECDHE_Curve25519 |
                | RECOMMENDED | TCPCRYPT_ECDHE_Curve448   |
                | OPTIONAL    | TCPCRYPT_ECDHE_P256       |
                | OPTIONAL    | TCPCRYPT_ECDHE_P521       |
                +-------------+---------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Table 2: Requirements for Implementation of TEPs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
表2：TEPの実装の要件
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--AEAD-Algorithms">
6. AEAD Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. AEADアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses sym_cipher identifiers in the messages Init1 and Init2 (see Section 3.3) to negotiate the use of AEAD algorithms; the values of these identifiers are given in Table 5 in Section 7. The algorithms AEAD_AES_128_GCM and AEAD_AES_256_GCM are specified in [RFC5116]. The algorithm AEAD_CHACHA20_POLY1305 is specified in [RFC8439].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、メッセージInit1およびInit2（セクション3.3を参照）でsym_cipher識別子を使用して、AEADアルゴリズムの使用をネゴシエートします。これらの識別子の値は、セクション7の表5に示されています。アルゴリズムAEAD_AES_128_GCMおよびAEAD_AES_256_GCMは、[RFC5116]で指定されています。アルゴリズムAEAD_CHACHA20_POLY1305は[RFC8439]で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST support certain AEAD algorithms according to Table 3. Note that system administrators MAY configure which algorithms a host will negotiate independently of these requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、表3に従って特定のAEADアルゴリズムをサポートする必要があります。システム管理者は、ホストがこれらの要件とは無関係にネゴシエートするアルゴリズムを構成できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, this document uses the lengths ae_key_len and ae_nonce_len to specify aspects of encryption and data formats. These values depend on the negotiated AEAD algorithm, also according to the table below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、このドキュメントでは、長さae_key_lenおよびae_nonce_lenを使用して、暗号化とデータ形式の側面を指定します。これらの値は、ネゴシエートされたAEADアルゴリズムに依存します。これも以下の表に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------------------+-------------+------------+--------------+
   | AEAD Algorithm         | Requirement | ae_key_len | ae_nonce_len |
   +------------------------+-------------+------------+--------------+
   | AEAD_AES_128_GCM       | REQUIRED    | 16 bytes   | 12 bytes     |
   | AEAD_AES_256_GCM       | RECOMMENDED | 32 bytes   | 12 bytes     |
   | AEAD_CHACHA20_POLY1305 | RECOMMENDED | 32 bytes   | 12 bytes     |
   +------------------------+-------------+------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Table 3: Requirement and Lengths for Each AEAD Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
表3：各AEADアルゴリズムの要件と長さ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--IANA-Considerations">
7. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For use with TCP-ENO&#39;s negotiation mechanism, tcpcrypt&#39;s TEP identifiers have been incorporated in IANA&#39;s &#34;TCP Encryption Protocol Identifiers&#34; registry under the &#34;Transmission Control Protocol (TCP) Parameters&#34; registry, as in Table 4. The various key-agreement schemes used by these tcpcrypt variants are defined in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENOのネゴシエーションメカニズムで使用するために、tcpcryptのTEP識別子は、表4に示すように、「Transmission Control Protocol（TCP）Parameters」レジストリの下のIANAの「TCP Encryption Protocol Identifiers」レジストリに組み込まれています。これらのtcpcryptバリアントはセクション5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +-------+---------------------------+-----------+
             | Value | Meaning                   | Reference |
             +-------+---------------------------+-----------+
             | 0x21  | TCPCRYPT_ECDHE_P256       | [RFC8548] |
             | 0x22  | TCPCRYPT_ECDHE_P521       | [RFC8548] |
             | 0x23  | TCPCRYPT_ECDHE_Curve25519 | [RFC8548] |
             | 0x24  | TCPCRYPT_ECDHE_Curve448   | [RFC8548] |
             +-------+---------------------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Table 4: TEP Identifiers for Use with tcpcrypt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
表4：tcpcryptで使用するTEP識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 In Section 6, this document defines the use of several AEAD algorithms for encrypting application data. To name these algorithms, the tcpcrypt protocol uses two-byte identifiers in the range 0x0001 to 0xFFFF, inclusively, for which IANA maintains a new &#34;tcpcrypt AEAD Algorithms&#34; registry under the &#34;Transmission Control Protocol (TCP) Parameters&#34; registry. The initial values for this registry are given in Table 5. Future assignments are to be made upon satisfying either of two policies defined in [RFC8126]: &#34;IETF Review&#34; or (for non-IETF stream specifications) &#34;Expert Review with RFC Required.&#34; IANA will furthermore provide early allocation [RFC7120] to facilitate testing before RFCs are finalized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
セクション6で、このドキュメントは、アプリケーションデータを暗号化するためのいくつかのAEADアルゴリズムの使用を定義します。これらのアルゴリズムに名前を付けるために、tcpcryptプロトコルは、0x0001から0xFFFFまでの範囲の2バイトの識別子を使用します。これに対して、IANAは、「Transmission Control Protocol（TCP）Parameters」レジストリの下に新しい「tcpcrypt AEAD Algorithms」レジストリを維持します。このレジストリの初期値を表5に示します。将来の割り当ては、[RFC8126]で定義されている2つのポリシー「IETFレビュー」または（非IETFストリーム仕様の場合）「RFCが必要なエキスパートレビュー」のいずれかを満たすときに行われます。 」 IANAはさらに、RFCが確定する前のテストを容易にするために、早期割り当て[RFC7120]を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +--------+------------------------+----------------------+
        | Value  | AEAD Algorithm         | Reference            |
        +--------+------------------------+----------------------+
        | 0x0001 | AEAD_AES_128_GCM       | [RFC8548], Section 6 |
        | 0x0002 | AEAD_AES_256_GCM       | [RFC8548], Section 6 |
        | 0x0010 | AEAD_CHACHA20_POLY1305 | [RFC8548], Section 6 |
        +--------+------------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Table 5: Authenticated-Encryption Algorithms for Use with tcpcrypt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
表5：tcpcryptで使用する認証済み暗号化アルゴリズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Security-Considerations">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the security considerations of TCP-ENO apply to tcpcrypt. In particular, tcpcrypt does not protect against active network attackers unless applications authenticate the session ID. If it can be established that the session IDs computed at each end of the connection match, then tcpcrypt guarantees that no man-in-the-middle attacks occurred unless the attacker has broken the underlying cryptographic primitives, e.g., Elliptic Curve Diffie-Hellman (ECDH). A proof of this property for an earlier version of the protocol has been published [tcpcrypt].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENOのセキュリティに関する考慮事項はすべてtcpcryptに適用されます。特に、アプリケーションがセッションIDを認証しない限り、tcpcryptはアクティブなネットワーク攻撃者から保護しません。接続の両端で計算されたセッションIDが一致することが確認できる場合、tcpcryptは、攻撃者が基本的な暗号プリミティブ（Elliptic Curve Diffie-Hellmanなど）を壊していない限り、中間者攻撃が発生しなかったことを保証します。 ECDH）。プロトコルの以前のバージョンに対するこのプロパティの証明は公開されています[tcpcrypt]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure middlebox compatibility, tcpcrypt does not protect TCP headers. Therefore, the protocol is vulnerable to denial-of-service from off-path attackers just as plain TCP is. Possible attacks include desynchronizing the underlying TCP stream, injecting RST or FIN segments, and forging rekey bits. These attacks will cause a tcpcrypt connection to hang or fail with an error, but not in any circumstance where plain TCP could continue uncorrupted. Implementations MUST give higher-level software a way to distinguish such errors from a clean end-of-stream (indicated by an authenticated FINp bit) so that applications can avoid semantic truncation attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミドルボックスの互換性を確保するために、tcpcryptはTCPヘッダーを保護しません。したがって、このプロトコルは、プレーンTCPと同様に、パス外の攻撃者からのサービス拒否攻撃に対して脆弱です。可能性のある攻撃には、基礎となるTCPストリームの非同期化、RSTまたはFINセグメントの挿入、キー再生成ビットの偽造などがあります。これらの攻撃により、tcpcrypt接続がハングするか、エラーで失敗しますが、プレーンなTCPが破損せずに継続できる状況では発生しません。実装は、アプリケーションがセマンティックトランケーション攻撃を回避できるように、高レベルのソフトウェアにそのようなエラーをストリームの終了（認証されたFINpビットによって示される）から区別する方法を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 There is no &#34;key confirmation&#34; step in tcpcrypt. This is not needed because tcpcrypt&#39;s threat model includes the possibility of a connection to an adversary. If key negotiation is compromised and yields two different keys, failed integrity checks on every subsequent frame will cause the connection either to hang or to abort. This is not a new threat as an active attacker can achieve the same results against a plain TCP connection by injecting RST segments or modifying sequence and acknowledgement numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
tcpcryptには「鍵の確認」手順はありません。 tcpcryptの脅威モデルには攻撃者への接続の可能性が含まれているため、これは必要ありません。キーネゴシエーションが危険にさらされ、2つの異なるキーが生成される場合、後続のすべてのフレームで整合性チェックに失敗すると、接続がハングまたは中止します。アクティブな攻撃者は、RSTセグメントを挿入するか、シーケンス番号と確認応答番号を変更することにより、プレーンTCP接続に対して同じ結果を得ることができるため、これは新しい脅威ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt uses short-lived public keys to provide forward secrecy; once an implementation removes these keys from memory, a compromise of the system will not provide any means to derive the session secrets for past connections. All currently-specified key agreement schemes involve key agreement based on Ephemeral Elliptic Curve Diffie-Hellman (ECDHE), meaning a new key pair can be efficiently computed for each connection. If implementations reuse these parameters, they MUST limit the lifetime of the private parameters as far as is practical in order to minimize the number of past connections that are vulnerable. Of course, placing private keys in persistent storage introduces severe risks that they will not be destroyed reliably and in a timely fashion, and it SHOULD be avoided whenever possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcryptは、有効期間が短い公開鍵を使用して転送秘密を提供します。実装がこれらのキーをメモリから削除すると、システムのセキュリティが侵害されても、過去の接続のセッションシークレットを取得する手段は提供されません。現在指定されているすべてのキー合意スキームには、Ephemeral Elliptic Curve Diffie-Hellman（ECDHE）に基づくキー合意が含まれます。つまり、新しいキーペアを接続ごとに効率的に計算できます。実装がこれらのパラメーターを再利用する場合、脆弱性のある過去の接続の数を最小限に抑えるために、実用的な範囲でプライベートパラメーターの有効期間を制限する必要があります。もちろん、秘密鍵を永続ストレージに配置すると、信頼性が高くタイムリーに破棄されないという重大なリスクが発生します。可能な限り回避する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attackers cannot force passive openers to move forward in their session resumption chain without guessing the content of the resumption identifier, which will be difficult without key knowledge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、再開識別子の内容を推測することなく、パッシブオープナーにセッション再開チェーンを前進させることはできません。これは、主要な知識がなければ困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cipher-suites specified in this document all use HMAC-SHA256 to implement the collision-resistant pseudo-random function denoted by CPRF. A collision-resistant function is one for which, for sufficiently large L, an attacker cannot find two distinct inputs (K_1, CONST_1) and (K_2, CONST_2) such that CPRF(K_1, CONST_1, L) = CPRF(K_2, CONST_2, L). Collision resistance is important to assure the uniqueness of session IDs, which are generated using the CPRF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで指定されている暗号スイートはすべて、HMAC-SHA256を使用して、CPRFで示される耐衝突性の疑似ランダム関数を実装します。耐衝突機能とは、Lが十分に大きい場合、攻撃者は2つの異なる入力（K_1、CONST_1）と（K_2、CONST_2）を見つけることができないため、CPRF（K_1、CONST_1、L）= CPRF（K_2、CONST_2、 L）。衝突耐性は、CPRFを使用して生成されるセッションIDの一意性を保証するために重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, many of tcpcrypt&#39;s cryptographic functions require random input, and thus any host implementing tcpcrypt MUST have access to a cryptographically-secure source of randomness or pseudo-randomness. [RFC4086] provides recommendations on how to achieve this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、tcpcryptの暗号化機能の多くはランダムな入力を必要とするため、tcpcryptを実装するホストは、暗号化された安全なランダムネスまたは疑似ランダムネスのソースにアクセスできる必要があります。 [RFC4086]は、これを実現する方法に関する推奨事項を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most implementations will rely on a device&#39;s pseudo-random generator, seeded from hardware events and a seed carried over from the previous boot. Once a pseudo-random generator has been properly seeded, it can generate effectively arbitrary amounts of pseudo-random data. However, until a pseudo-random generator has been seeded with sufficient entropy, not only will tcpcrypt be insecure, it will reveal information that further weakens the security of the pseudo-random generator, potentially harming other applications. As REQUIRED by TCP-ENO, implementations MUST NOT send ENO options unless they have access to an adequate source of randomness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどの実装は、ハードウェアイベントからシードされたデバイスの疑似ランダムジェネレーターと、前回のブートから引き継がれたシードに依存します。擬似ランダムジェネレーターが適切にシードされると、任意の量の擬似ランダムデータを効果的に生成できます。ただし、疑似ランダムジェネレーターに十分なエントロピーがシードされるまで、tcpcryptが安全でなくなるだけでなく、疑似ランダムジェネレーターのセキュリティがさらに弱まり、他のアプリケーションに害を及ぼす可能性があるという情報が明らかになります。 TCP-ENOで要求されるように、実装は、適切なランダム性のソースにアクセスできない限り、ENOオプションを送信してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Asymmetric-Roles">
8.1. Asymmetric Roles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 非対称の役割
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt transforms a shared pseudo-random key (PRK) into cryptographic traffic keys for each direction. Doing so requires an asymmetry in the protocol, as the key derivation function must be perturbed differently to generate different keys in each direction. Tcpcrypt includes other asymmetries in the roles of the two hosts, such as the process of negotiating algorithms (e.g., proposing vs. selecting cipher suites).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcryptは、共有疑似ランダムキー（PRK）を各方向の暗号化トラフィックキーに変換します。各方向で異なる鍵を生成するには、鍵導出関数を異なる方法で摂動する必要があるため、これにはプロトコルの非対称性が必要です。 Tcpcryptには、アルゴリズムのネゴシエーションプロセス（暗号スイートの提案と選択など）など、2つのホストの役割に他の非対称性が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Verified-Liveness">
8.2. Verified Liveness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 検証された活性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many hosts implement TCP keep-alives [RFC1122] as an option for applications to ensure that the other end of a TCP connection still exists even when there is no data to be sent. A TCP keep-alive segment carries a sequence number one prior to the beginning of the send window and may carry one byte of &#34;garbage&#34; data. Such a segment causes the remote side to send an acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのホストは、アプリケーションのオプションとしてTCPキープアライブ[RFC1122]を実装して、送信するデータがない場合でも、TCP接続のもう一方の端が確実に存在するようにします。 TCPキープアライブセグメントは、送信ウィンドウの開始前にシーケンス番号1を伝達し、「ガベージ」データの1バイトを伝達する場合があります。このようなセグメントにより、リモート側は確認応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, tcpcrypt cannot cryptographically verify keep-alive acknowledgments. Therefore, an attacker could prolong the existence of a session at one host after the other end of the connection no longer exists. (Such an attack might prevent a process with sensitive data from exiting, giving an attacker more time to compromise a host and extract the sensitive data.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残念ながら、tcpcryptはキープアライブの確認を暗号で検証できません。したがって、攻撃者は、接続のもう一方の端が存在しなくなった後、1つのホストでのセッションの存在を延長する可能性があります。 （このような攻撃は、機密データを含むプロセスが終了するのを防ぎ、攻撃者がホストを危険にさらして機密データを抽出するためにより多くの時間を与える可能性があります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To counter this threat, tcpcrypt specifies a way to stimulate the remote host to send verifiably fresh and authentic data, described in Section 3.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この脅威に対抗するために、tcpcryptは、リモートホストを刺激して、検証可能に新鮮で信頼できるデータを送信する方法を指定します（セクション3.9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP keep-alive mechanism has also been used for its effects on intermediate nodes in the network, such as preventing flow state from expiring at NAT boxes or firewalls. As these purposes do not require the authentication of endpoints, implementations MAY safely accomplish them using either the existing TCP keep-alive mechanism or tcpcrypt&#39;s verified keep-alive mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPキープアライブメカニズムは、NATボックスやファイアウォールでフロー状態が期限切れになるのを防ぐなど、ネットワークの中間ノードに影響を与えるためにも使用されています。これらの目的はエンドポイントの認証を必要としないため、実装は、既存のTCPキープアライブメカニズムまたはtcpcryptの検証済みキープアライブメカニズムのいずれかを使用して、エンドポイントの認証を安全に達成できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--Mandatory-Key-Agreement-Schemes">
8.3. Mandatory Key-Agreement Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. 必須の鍵合意スキーム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document mandates that tcpcrypt implementations provide support for at least one key-agreement scheme: ECDHE using Curve25519. This choice of a single mandatory algorithm is the result of a difficult tradeoff between cryptographic diversity and the ease and security of actual deployment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、tcpcrypt実装が少なくとも1つの鍵合意方式（Curve25519を使用するECDHE）のサポートを提供することを義務付けています。単一の必須アルゴリズムをこのように選択したのは、暗号化の多様性と実際の展開の容易さとセキュリティとの間の難しいトレードオフの結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 The IETF&#39;s appraisal of best current practice on this matter [RFC7696] says, &#34;Ideally, two independent sets of mandatory-to-implement algorithms will be specified, allowing for a primary suite and a secondary suite. This approach ensures that the secondary suite is widely deployed if a flaw is found in the primary one.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
この問題に関する現在のベストプラクティスに関するIETFの評価[RFC7696]は、「理想的には、必須から実装までのアルゴリズムの2つの独立したセットが指定され、プライマリスイートとセカンダリスイートを許可します。このアプローチにより、セカンダリスイートが主要な欠陥に欠陥が見つかった場合、広く展開されています。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To meet that ideal, it might appear natural to also mandate ECDHE using P-256. However, implementing the Diffie-Hellman function using NIST elliptic curves (including those specified for use with tcpcrypt, P-256 and P-521) appears to be very difficult to achieve without introducing vulnerability to side-channel attacks [NIST-fail]. Although well-trusted implementations are available as part of large cryptographic libraries, these can be difficult to extract for use in operating-system kernels where tcpcrypt is usually best implemented. In contrast, the characteristics of Curve25519 together with its recent popularity has led to many safe and efficient implementations, including some that fit naturally into the kernel environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その理想を満たすために、P-256を使用してECDHEを義務付けることも当然のように思われるかもしれません。ただし、NIST楕円曲線（tcpcrypt、P-256、P-521で使用するために指定されたものを含む）を使用してDiffie-Hellman関数を実装することは、サイドチャネル攻撃の脆弱性を導入せずに達成するのが非常に難しいようです[NIST-fail]。大規模な暗号化ライブラリの一部として信頼できる実装を利用できますが、tcpcryptが通常最適に実装されているオペレーティングシステムカーネルで使用するためにこれらを抽出するのは難しい場合があります。対照的に、Curve25519の特徴と最近の人気により、カーネル環境に自然に適合するものを含め、多くの安全で効率的な実装が可能になりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696] insists that, &#34;The selected algorithms need to be resistant to side-channel attacks and also meet the performance, power, and code size requirements on a wide variety of platforms.&#34; On this principle, tcpcrypt excludes the NIST curves from the set of mandatory-to-implement key-agreement algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696]は、「選択したアルゴリズムはサイドチャネル攻撃に耐性があり、さまざまなプラットフォームのパフォーマンス、電力、およびコードサイズの要件を満たす必要がある」と主張しています。この原則では、tcpcryptはNIST曲線を、実装に必須の鍵合意アルゴリズムのセットから除外します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, this document encourages support for key agreement with Curve448, categorizing it as RECOMMENDED. Curve448 appears likely to admit safe and efficient implementations. However, support is not REQUIRED because existing implementations might not yet be sufficiently well proven.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、このドキュメントは、Curve448との主要な合意のサポートを奨励し、それをRECOMMENDEDとして分類しています。 Curve448は、安全で効率的な実装を認めているようです。ただし、既存の実装はまだ十分に実証されていない可能性があるため、サポートは必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Experiments">
9. Experiments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 実験
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some experience will be required to determine whether the tcpcrypt protocol can be deployed safely and successfully across the diverse environments of the global internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グローバルインターネットのさまざまな環境にtcpcryptプロトコルを安全かつ正常に展開できるかどうかを判断するには、ある程度の経験が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Safety means that TCP implementations that support tcpcrypt are able to communicate reliably in all the same settings as they would without tcpcrypt. As described in Section 9 of [RFC8547], this property can be subverted if middleboxes strip ENO options from non-SYN segments after allowing them in SYN segments, or if the particular communication patterns of tcpcrypt offend the policies of middleboxes doing deep-packet inspection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全性とは、tcpcryptをサポートするTCP実装が、tcpcryptを使用しない場合と同じすべての設定で確実に通信できることを意味します。 [RFC8547]のセクション9で説明されているように、ミドルボックスがSYNセグメントで許可された後に非SYNセグメントからENOオプションを削除した場合、またはtcpcryptの特定の通信パターンがディープパケットインスペクションを実行するミドルボックスのポリシーを害する場合、このプロパティは破壊される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Success, in addition to safety, means hosts that implement tcpcrypt actually enable encryption when connecting to one another. This property depends on the network&#39;s treatment of the TCP-ENO handshake and can be subverted if middleboxes merely strip unknown TCP options or terminate TCP connections and relay data back and forth unencrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全性に加えて、成功とは、tcpcryptを実装するホストが相互に接続するときに実際に暗号化を有効にすることを意味します。このプロパティは、TCP-ENOハンドシェイクのネットワークの処理に依存し、ミドルボックスが不明なTCPオプションを削除するか、TCP接続を終了してデータを暗号化せずに中継するだけで破壊される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ease of implementation will be a further challenge to deployment. Because tcpcrypt requires encryption operations on frames that may span TCP segments, kernel implementations are forced to buffer segments in different ways than are necessary for plain TCP. More implementation experience will show how much additional code complexity is required in various operating systems and what kind of performance effects can be expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装の容易さは、展開のさらなる課題となります。 tcpcryptは、TCPセグメントにまたがる可能性のあるフレームで暗号化操作を必要とするため、カーネルの実装では、プレーンTCPに必要な方法とは異なる方法でセグメントをバッファリングする必要があります。より多くの実装経験は、さまざまなオペレーティングシステムでどれだけ多くのコードの複雑さが必要であり、どのようなパフォーマンス効果が期待できるかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--References">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-1--Normative-References">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE-1363] IEEE, &#34;IEEE Standard Specifications for Public-Key Cryptography&#34;, IEEE Standard 1363-2000, DOI 10.1109/IEEESTD.2000.92292.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE-1363] IEEE、「IEEE Standard Specifications for Public-Key Cryptography」、IEEE Standard 1363-2000、DOI 10.1109 / IEEESTD.2000.92292。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-DSS] National Institute of Standards and Technology (NIST), &#34;Digital Signature Standard (DSS)&#34;, FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-DSS]国立標準技術研究所（NIST）、「デジタル署名標準（DSS）」、FIPS PUB 186-4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, &lt;https://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel、J。、「Transmission Control Protocol」、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、&lt;https://www.rfc-editor.org/info/rfc793&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, DOI 10.17487/RFC2018, October 1996, &lt;https://www.rfc-editor.org/info/rfc2018&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis、M.、Madhavi、J.、Floyd、S。、およびA. Romanow、「TCP選択的確認応答オプション」、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、&lt;https：//www.rfc- editor.org/info/rfc2018&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, DOI 10.17487/RFC2104, February 1997, &lt;https://www.rfc-editor.org/info/rfc2104&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、&lt;https：//www.rfc-editor .org / info / rfc2104&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5116] McGrew, D., &#34;An Interface and Algorithms for Authenticated Encryption&#34;, RFC 5116, DOI 10.17487/RFC5116, January 2008, &lt;https://www.rfc-editor.org/info/rfc5116&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5116] McGrew、D。、「認証された暗号化のためのインターフェースとアルゴリズム」、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、&lt;https://www.rfc-editor.org/info/rfc5116&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5869] Krawczyk, H. and P. Eronen, &#34;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&#34;, RFC 5869, DOI 10.17487/RFC5869, May 2010, &lt;https://www.rfc-editor.org/info/rfc5869&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー導出関数（HKDF）」、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、&lt;https：//www.rfc-editor .org / info / rfc5869&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7120] Cotton, M., &#34;Early IANA Allocation of Standards Track Code Points&#34;, BCP 100, RFC 7120, DOI 10.17487/RFC7120, January 2014, &lt;https://www.rfc-editor.org/info/rfc7120&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7120] Cotton、M。、「Early IANA Allocation of Standards Track Code Points」、BCP 100、RFC 7120、DOI 10.17487 / RFC7120、2014年1月、&lt;https://www.rfc-editor.org/info/rfc7120&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7748] Langley, A., Hamburg, M., and S. Turner, &#34;Elliptic Curves for Security&#34;, RFC 7748, DOI 10.17487/RFC7748, January 2016, &lt;https://www.rfc-editor.org/info/rfc7748&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7748]ラングレー、A。、ハンブルク、M。、およびS.ターナー、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、&lt;https://www.rfc-editor.org/info / rfc7748&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8126] Cotton, M., Leiba, B., and T. Narten, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, &lt;https://www.rfc-editor.org/info/rfc8126&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8126]コットン、M。、レイバ、B。、およびT.ナルテン、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、&lt;https：// www .rfc-editor.org / info / rfc8126&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8439] Nir, Y. and A. Langley, &#34;ChaCha20 and Poly1305 for IETF Protocols&#34;, RFC 8439, DOI 10.17487/RFC8439, June 2018, &lt;https://www.rfc-editor.org/info/rfc8439&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8439] Nir、Y。およびA. Langley、「IETFプロトコル用のChaCha20およびPoly1305」、RFC 8439、DOI 10.17487 / RFC8439、2018年6月、&lt;https://www.rfc-editor.org/info/rfc8439&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8547] Bittau, A., Giffin, D., Handley, M., Mazieres, D., and E. Smith, &#34;TCP-ENO: Encryption Negotiation Option&#34;, RFC 8547, DOI 10.17487/RFC8547, May 2019, &lt;https://www.rfc-editor.org/info/rfc8547&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8547] Bittau、A.、Gifin、D.、Handley、M.、Mazieres、D。、およびE. Smith、「TCP-ENO：Encryption Negotiation Option」、RFC 8547、DOI 10.17487 / RFC8547、2019年5月、&lt; https://www.rfc-editor.org/info/rfc8547&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10-2--Informative-References">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-fail] Bernstein, D. and T. Lange, &#34;Failures in NIST&#39;s ECC Standards&#34;, January 2016, &lt;https://cr.yp.to/newelliptic/nistecc-20160106.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-fail] Bernstein、D.およびT. Lange、「Failures in NIST&#39;s ECC Standards」、2016年1月、&lt;https://cr.yp.to/newelliptic/nistecc-20160106.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, &lt;https://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden、R。、編、「インターネットホストの要件-通信層」、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、&lt;https://www.rfc-editor.org/info/ rfc1122&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, &lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 &#34;Randomness Requirements for Security&#34;、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、June 2005、&lt;https：//www.rfc-editor .org / info / rfc4086&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696] Housley, R., &#34;Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms&#34;, BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015, &lt;https://www.rfc-editor.org/info/rfc7696&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696] Housley、R。、「暗号化アルゴリズムの敏捷性と実装必須アルゴリズムの選択に関するガイドライン」、BCP 201、RFC 7696、DOI 10.17487 / RFC7696、2015年11月、&lt;https://www.rfc-editor.org / info / rfc7696&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[tcpcrypt] Bittau, A., Hamburg, M., Handley, M., Mazieres, D., and D. Boneh, &#34;The case for ubiquitous transport-level encryption&#34;, USENIX Security Symposium, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[tcpcrypt] Bittau、A.、Hamburg、M.、Handley、M.、Mazieres、D。、およびD. Boneh、「ユビキタストランスポートレベル暗号化の事例」、USENIXセキュリティシンポジウム、2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCPINC-API] Bittau, A., Boneh, D., Giffin, D., Handley, M., Mazieres, D., and E. Smith, &#34;Interface Extensions for TCP-ENO and tcpcrypt&#34;, Work in Progress, draft-ietf-tcpinc-api-06, June 2018.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCPINC-API] Bittau、A.、Boneh、D.、Gifin、D.、Handley、M.、Mazieres、D。、およびE. Smith、「TCP-ENOおよびtcpcryptのインターフェイス拡張」、作業中、 draft-ietf-tcpinc-api-06、2018年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We are grateful for contributions, help, discussions, and feedback from the TCPINC Working Group and from other IETF reviewers, including Marcelo Bagnulo, David Black, Bob Briscoe, Jana Iyengar, Stephen Kent, Tero Kivinen, Mirja Kuhlewind, Yoav Nir, Christoph Paasch, Eric Rescorla, Kyle Rose, and Dale Worley.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPINCワーキンググループ、およびMarcelo Bagnulo、David Black、Bob Briscoe、Jana Iyengar、Stephen Kent、Tero Kivinen、Mirja Kuhlewind、Yoav Nir、Christoph Paaschなどの他のIETFレビューアからの寄稿、ヘルプ、ディスカッション、フィードバックに感謝します、エリック・レスコーラ、カイル・ローズ、デール・ウォーリー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This work was funded by gifts from Intel (to Brad Karp) and from Google; by NSF award CNS-0716806 (A Clean-Slate Infrastructure for Information Flow Control); by DARPA CRASH under contract #N66001-10-2-4088; and by the Stanford Secure Internet of Things Project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この作品は、Intel（Brad Karp宛て）およびGoogleからの寄付によって賄われました。 NSF賞CNS-0716806（情報フロー制御のためのクリーンスレートインフラストラクチャ）による。契約番号D66001-10-2-4088に基づくDARPA CRASHによる。 Stanford Secure Internet of Things Projectによるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
貢献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dan Boneh and Michael Hamburg were coauthors of the draft that became this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダンボネーとマイケルハンブルクは、このドキュメントとなったドラフトの共著者でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andrea Bittau Google 345 Spear Street San Francisco, CA 94105 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンドレアビッタウグーグル345 Spear Streetサンフランシスコ、CA 94105アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
 Email: bittau@google.com Daniel B. Giffin Stanford University 353 Serra Mall, Room 288 Stanford, CA 94305 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
メール：bittau@google.com Daniel B. Giffin Stanford University 353 Serra Mall、Room 288 Stanford、CA 94305 United States of America
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: daniel@beech-grove.net
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Handley University College London Gower St. London WC1E 6BT United Kingdom
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マークハンドラリーユニバーシティカレッジロンドンガワーセントロンドンWC1E 6BTイギリス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: M.Handley@cs.ucl.ac.uk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Mazieres Stanford University 353 Serra Mall, Room 290 Stanford, CA 94305 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Mazieresスタンフォード大学353 Serra Mall、Room 290 Stanford、CA 94305アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: dm@uun.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Quinn Slack Sourcegraph 121 2nd St Ste 200 San Francisco, CA 94105 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Quinn Slack Sourcegraph 121 2nd St Ste 200 San Francisco、CA 94105アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: sqs@sourcegraph.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric W. Smith Kestrel Institute 3260 Hillview Avenue Palo Alto, CA 94304 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エリックW.スミスケストレルインスティテュート3260 Hillview Avenueパロアルト、CA 94304アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: eric.smith@kestrel.edu
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
