<!DOCTYPE html>


<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 8785 - JSON Canonicalization Scheme (JCS) 日本語訳</title>

  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8785</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8785">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 8785 - JSON Canonicalization Scheme (JCS) 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://datatracker.ietf.org/doc/html/rfc8785">
            https://datatracker.ietf.org/doc/html/rfc8785
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 8785 - JSON正規化スキーム（JCS）</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Independent Submission                                       A. Rundgren
Request for Comments: 8785                                   Independent
Category: Informational                                        B. Jordan
ISSN: 2070-1721                                                 Broadcom
                                                              S. Erdtman
                                                              Spotify AB
                                                               June 2020
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
JSON Canonicalization Scheme (JCS)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
JSON正規化スキーム（JCS）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cryptographic operations like hashing and signing need the data to be expressed in an invariant format so that the operations are reliably repeatable. One way to address this is to create a canonical representation of the data. Canonicalization also permits data to be exchanged in its original form on the &#34;wire&#34; while cryptographic operations performed on the canonicalized counterpart of the data in the producer and consumer endpoints generate consistent results.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュや署名などの暗号化操作では、データを不変の形式で表現して、操作を確実に繰り返すことができるようにする必要があります。これに対処する1つの方法は、データの正規表現を作成することです。正規化により、「ワイヤー」上で元の形式でデータを交換することもできます。一方、プロデューサーエンドポイントとコンシューマーエンドポイントでデータの正規化されたカウンターパートに対して実行される暗号化操作は、一貫した結果を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the JSON Canonicalization Scheme (JCS). This specification defines how to create a canonical representation of JSON data by building on the strict serialization methods for JSON primitives defined by ECMAScript, constraining JSON data to the Internet JSON (I-JSON) subset, and by using deterministic property sorting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、JSON Canonicalization Scheme（JCS）について説明します。この仕様は、ECMAScriptによって定義されたJSONプリミティブの厳密なシリアル化メソッドを構築し、JSONデータをインターネットJSON（I-JSON）サブセットに制約し、確定的なプロパティソートを使用することにより、JSONデータの正規表現を作成する方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本文書の状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはInternet Standards Trackの仕様ではありません。情報提供を目的として公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。 RFCエディターは、このドキュメントを独自の裁量で公開することを選択し、実装または展開に対するその価値については何も述べていません。 RFC Editorによって公開が承認されたドキュメントは、どのレベルのインターネット標準の候補にもなりません。 RFC 7841のセクション2をご覧ください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8785.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8785で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2020 IETFトラストおよびドキュメントの作成者として識別された人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です。これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Terminology
   3.  Detailed Operation
     3.1.  Creation of Input Data
     3.2.  Generation of Canonical JSON Data
       3.2.1.  Whitespace
       3.2.2.  Serialization of Primitive Data Types
         3.2.2.1.  Serialization of Literals
         3.2.2.2.  Serialization of Strings
         3.2.2.3.  Serialization of Numbers
       3.2.3.  Sorting of Object Properties
       3.2.4.  UTF-8 Generation
   4.  IANA Considerations
   5.  Security Considerations
   6.  References
     6.1.  Normative References
     6.2.  Informative References
   Appendix A.  ECMAScript Sample Canonicalizer
   Appendix B.  Number Serialization Samples
   Appendix C.  Canonicalized JSON as &#34;Wire Format&#34;
   Appendix D.  Dealing with Big Numbers
   Appendix E.  String Subtype Handling
     E.1.  Subtypes in Arrays
   Appendix F.  Implementation Guidelines
   Appendix G.  Open-Source Implementations
   Appendix H.  Other JSON Canonicalization Efforts
   Appendix I.  Development Portal
   Acknowledgements
   Authors&#39; Addresses
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the JSON Canonicalization Scheme (JCS). This specification defines how to create a canonical representation of JSON [RFC8259] data by building on the strict serialization methods for JSON primitives defined by ECMAScript [ECMA-262], constraining JSON data to the I-JSON [RFC7493] subset, and by using deterministic property sorting. The output from JCS is a &#34;hashable&#34; representation of JSON data that can be used by cryptographic methods. The subsequent paragraphs outline the primary design considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、JSON Canonicalization Scheme（JCS）について説明します。この仕様は、ECMAScript [ECMA-262]によって定義されたJSONプリミティブの厳密なシリアル化メソッドに基づいて構築し、JSONデータをI-JSON [RFC7493]サブセットに制限することにより、JSON [RFC8259]データの正規表現を作成する方法を定義します。確定的なプロパティの並べ替え。 JCSからの出力は、暗号化メソッドで使用できるJSONデータの「ハッシュ可能な」表現です。以降の段落では、主な設計上の考慮事項について概説します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cryptographic operations like hashing and signing need the data to be expressed in an invariant format so that the operations are reliably repeatable. One way to accomplish this is to convert the data into a format that has a simple and fixed representation, like base64url [RFC4648]. This is how JSON Web Signature (JWS) [RFC7515] addressed this issue. Another solution is to create a canonical version of the data, similar to what was done for the XML signature [XMLDSIG] standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュや署名などの暗号化操作では、データを不変の形式で表現して、操作を確実に繰り返すことができるようにする必要があります。これを実現する1つの方法は、base64url [RFC4648]のような単純で固定された表現を持つフォーマットにデータを変換することです。これが、JSON Web Signature（JWS）[RFC7515]がこの問題に対処する方法です。別の解決策は、XML署名[XMLDSIG]標準に対して行われたのと同様に、データの正規バージョンを作成することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary advantage with a canonicalizing scheme is that data can be kept in its original form. This is the core rationale behind JCS. Put another way, using canonicalization enables a JSON object to remain a JSON object even after being signed. This can simplify system design, documentation, and logging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規化スキームの主な利点は、データを元の形式で維持できることです。これは、JCSの根底にある根拠です。言い換えると、正規化を使用すると、署名された後でもJSONオブジェクトをJSONオブジェクトのままにすることができます。これにより、システムの設計、文書化、およびロギングを簡素化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid &#34;reinventing the wheel&#34;, JCS relies on the serialization of JSON primitives (strings, numbers, and literals), as defined by ECMAScript (aka JavaScript) [ECMA-262] beginning with version 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「ホイールの再発明」を回避するために、JCSは、バージョン6以降のECMAScript（別名JavaScript）[ECMA-262]で定義されているJSONプリミティブ（文字列、数値、およびリテラル）のシリアル化に依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Seasoned XML developers may recall difficulties getting XML signatures to validate. This was usually due to different interpretations of the quite intricate XML canonicalization rules as well as of the equally complex Web Services security standards. The reasons why JCS should not suffer from similar issues are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
熟練したXML開発者は、XML署名を検証する際の問題を思い出すかもしれません。これは通常、非常に複雑なXML正規化ルールと同様に複雑なWebサービスセキュリティ標準の解釈が異なるためでした。 JCSが同様の問題に悩まされるべきではない理由は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON does not have a namespace concept and default values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSONには名前空間の概念とデフォルト値はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Data is constrained to the I-JSON [RFC7493] subset. This eliminates the need for specific parsers for dealing with canonicalization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* データはI-JSON [RFC7493]サブセットに制限されています。これにより、正規化を処理するための特定のパーサーが不要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JCS-compatible serialization of JSON primitives is currently supported by most web browsers as well as by Node.js [NODEJS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSONプリミティブのJCS互換のシリアル化は、現在ほとんどのWebブラウザーとNode.js [NODEJS]でサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The full JCS specification is currently supported by multiple open-source implementations (see Appendix G). See also Appendix F for implementation guidelines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 完全なJCS仕様は現在、複数のオープンソース実装でサポートされています（付録Gを参照）。実装ガイドラインについては、付録Fも参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCS is compatible with some existing systems relying on JSON canonicalization such as JSON Web Key (JWK) Thumbprint [RFC7638] and Keybase [KEYBASE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCSは、JSON Web Key（JWK）Thumbprint [RFC7638]やKeybase [KEYBASE]などのJSON正規化に依存している既存のシステムと互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For potential uses outside of cryptography, see [JSONCOMP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化以外の潜在的な用途については、[JSONCOMP]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intended audiences of this document are JSON tool vendors as well as designers of JSON-based cryptographic solutions. The reader is assumed to be knowledgeable in ECMAScript, including the &#34;JSON&#34; object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの対象読者は、JSONベースの暗号化ソリューションの設計者だけでなく、JSONツールベンダーでもあります。読者は、「JSON」オブジェクトを含むECMAScriptに精通していることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Terminology">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this document is not on the IETF standards track. However, a conformant implementation is supposed to adhere to the specified behavior for security and interoperability reasons. This text uses BCP 14 to describe that necessary behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETF標準トラックには含まれていません。ただし、準拠する実装は、セキュリティと相互運用性の理由から、指定された動作に準拠することになっています。このテキストでは、BCP 14を使用してその必要な動作を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Detailed-Operation">
3. Detailed Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 詳細な操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the details related to creating a canonical JSON representation and how they are addressed by JCS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、正規のJSON表現の作成に関連する詳細と、JCSによるそれらの表現方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix F describes the RECOMMENDED way of adding JCS support to existing JSON tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Fでは、JCSサポートを既存のJSONツールに追加する推奨方法を説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Creation-of-Input-Data">
3.1. Creation of Input Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 入力データの作成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data to be canonically serialized is usually created by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規化されてシリアル化されるデータは、通常、次のように作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Parsing previously generated JSON data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 以前に生成されたJSONデータの解析。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Programmatically creating data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* プログラムでデータを作成する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Irrespective of the method used, the data to be serialized MUST be adapted for I-JSON [RFC7493] formatting, which implies the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用される方法に関係なく、シリアル化されるデータは、I-JSON [RFC7493]のフォーマットに適合させる必要があります。これは、以下を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON objects MUST NOT exhibit duplicate property names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSONオブジェクトは、重複したプロパティ名を示すことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON string data MUST be expressible as Unicode [UNICODE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON文字列データはUnicode [UNICODE]として表現できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON number data MUST be expressible as IEEE 754 [IEEE754] double-precision values. For applications needing higher precision or longer integers than offered by IEEE 754 double precision, it is RECOMMENDED to represent such numbers as JSON strings; see Appendix D for details on how this can be performed in an interoperable and extensible way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON数値データは、IEEE 754 [IEEE754]倍精度値として表現できる必要があります。 IEEE 754倍精度で提供されるよりも高い精度または長い整数が必要なアプリケーションでは、JSON文字列などの数値を表すことをお勧めします。これを相互運用可能かつ拡張可能な方法で実行する方法の詳細については、付録Dを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An additional constraint is that parsed JSON string data MUST NOT be altered during subsequent serializations. For more information, see Appendix E.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加の制約は、解析されたJSON文字列データは、後続のシリアル化中に変更してはならないことです。詳細については、付録Eを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Although the Unicode standard offers the possibility of rearranging certain character sequences, referred to as &#34;Unicode Normalization&#34; [UCNORM], JCS-compliant string processing does not take this into consideration. That is, all components involved in a scheme depending on JCS MUST preserve Unicode string data &#34;as is&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：Unicode標準では、「Unicode Normalization」[UCNORM]と呼ばれる特定の文字シーケンスを再配置する可能性がありますが、JCS準拠の文字列処理ではこれが考慮されません。つまり、JCSに依存するスキームに含まれるすべてのコンポーネントは、Unicode文字列データを「そのまま」保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Generation-of-Canonical-JSON-Data">
3.2. Generation of Canonical JSON Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 正規JSONデータの生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections describe the steps required to create a canonical JSON representation of the data elaborated on in the previous section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、前のセクションで詳しく説明したデータの正規JSON表現を作成するために必要な手順について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix A shows sample code for an ECMAScript-based canonicalizer, matching the JCS specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Aは、JCS仕様に一致するECMAScriptベースの正規化子のサンプルコードを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-1--Whitespace">
3.2.1. Whitespace
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 空白
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whitespace between JSON tokens MUST NOT be emitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSONトークン間の空白は出力してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2--Serialization-of-Primitive-Data-Types">
3.2.2. Serialization of Primitive Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. プリミティブデータ型のシリアル化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume the following JSON object is parsed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のJSONオブジェクトが解析されると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {
       &#34;numbers&#34;: [333333333.33333329, 1E30, 4.50,
                   2e-3, 0.000000000000000000000000001],
       &#34;string&#34;: &#34;\u20ac$\u000F\u000aA&#39;\u0042\u0022\u005c\\\&#34;\/&#34;,
       &#34;literals&#34;: [null, true, false]
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the parsed data is subsequently serialized using a serializer compliant with ECMAScript&#39;s &#34;JSON.stringify()&#34;, the result would (with a line wrap added for display purposes only) be rather divergent with respect to the original data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解析されたデータがECMAScriptの「JSON.stringify()」に準拠したシリアライザを使用してその後シリアル化される場合、結果は（表示目的でのみ行折り返しが追加された状態で）元のデータとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {&#34;numbers&#34;:[333333333.3333333,1e+30,4.5,0.002,1e-27],&#34;string&#34;:
     &#34;€$\u000f\nA&#39;B\&#34;\\\\\&#34;/&#34;,&#34;literals&#34;:[null,true,false]}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason for the difference between the parsed data and its serialized counterpart is due to a wide tolerance on input data (as defined by JSON [RFC8259]), while output data (as defined by ECMAScript) has a fixed representation. As can be seen in the example, numbers are subject to rounding as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解析されたデータとそのシリアル化されたデータの違いの理由は、入力データ（JSON [RFC8259]で定義）の許容範囲が広いためですが、出力データ（ECMAScriptで定義）の表現は固定されています。この例でわかるように、数値も丸められます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections describe the serialization of primitive JSON data types according to JCS. This part is identical to that of ECMAScript. In the (unlikely) event that a future version of ECMAScript would invalidate any of the following serialization methods, it will be up to the developer community to either stick to this specification or create a new specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、JCSによるプリミティブJSONデータ型のシリアル化について説明します。この部分はECMAScriptの部分と同じです。 ECMAScriptの将来のバージョンで以下のシリアル化メソッドが無効になる（まれに）イベントでは、この仕様に固執するか、新しい仕様を作成するかは、開発者コミュニティの責任になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2-1--Serialization-of-Literals">
3.2.2.1. Serialization of Literals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.1. リテラルのシリアル化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In accordance with JSON [RFC8259], the literals &#34;null&#34;, &#34;true&#34;, and &#34;false&#34; MUST be serialized as null, true, and false, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSON [RFC8259]に従って、リテラル「null」、「true」、および「false」は、それぞれnull、true、falseとしてシリアル化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2-2--Serialization-of-Strings">
3.2.2.2. Serialization of Strings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.2. 文字列のシリアル化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For JSON string data (which includes JSON object property names as well), each Unicode code point MUST be serialized as described below (see Section 24.3.2.2 of [ECMA-262]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSON文字列データ（JSONオブジェクトのプロパティ名も含む）の場合、各Unicodeコードポイントは、下記のようにシリアル化する必要があります（[ECMA-262]のセクション24.3.2.2を参照）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the Unicode value falls within the traditional ASCII control character range (U+0000 through U+001F), it MUST be serialized using lowercase hexadecimal Unicode notation (\uhhhh) unless it is in the set of predefined JSON control characters U+0008, U+0009, U+000A, U+000C, or U+000D, which MUST be serialized as \b, \t, \n, \f, and \r, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Unicode値が従来のASCII制御文字の範囲（U + 0000からU + 001F）に含まれる場合、事前定義されたJSON制御文字U + 0008のセットに含まれていない限り、小文字の16進Unicode表記（\ uhhhh）を使用してシリアル化する必要があります。 U + 0009、U + 000A、U + 000C、またはU + 000D。それぞれ\ b、\ t、\ n、\ f、および\ rとしてシリアル化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* If the Unicode value is outside of the ASCII control character range, it MUST be serialized &#34;as is&#34; unless it is equivalent to U+005C (\) or U+0022 (&#34;), which MUST be serialized as \\ and \&#34;, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Unicode値がASCII制御文字の範囲外にある場合、U + 005C（\）またはU + 0022（ &#34;）と同等でない限り、「そのまま」シリアル化する必要があります。 、それぞれ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the resulting sequence of Unicode code points MUST be enclosed in double quotes (&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、結果のUnicodeコードポイントのシーケンスは二重引用符（ &#34;）で囲む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Since invalid Unicode data like &#34;lone surrogates&#34; (e.g., U+DEAD) may lead to interoperability issues including broken signatures, occurrences of such data MUST cause a compliant JCS implementation to terminate with an appropriate error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：「サロゲート」などの無効なUnicodeデータ（U + DEADなど）は、署名の破損などの相互運用性の問題を引き起こす可能性があるため、このようなデータが発生すると、準拠するJCS実装が適切なエラーで終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-2-3--Serialization-of-Numbers">
3.2.2.3. Serialization of Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.3. 番号のシリアル化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECMAScript builds on the IEEE 754 [IEEE754] double-precision standard for representing JSON number data. Such data MUST be serialized according to Section 7.1.12.1 of [ECMA-262], including the &#34;Note 2&#34; enhancement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECMAScriptは、JSON数値データを表すためのIEEE 754 [IEEE754]倍精度標準に基づいています。このようなデータは、「注2」の拡張を含め、[ECMA-262]のセクション7.1.12.1に従ってシリアル化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to the relative complexity of this part, the algorithm itself is not included in this document. For implementers of JCS-compliant number serialization, Google&#39;s implementation in V8 [V8] may serve as a reference. Another compatible number serialization reference implementation is Ryu [RYU], which is used by the JCS open-source Java implementation mentioned in Appendix G. Appendix B holds a set of IEEE 754 sample values and their corresponding JSON serialization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この部分は比較的複雑であるため、アルゴリズム自体はこのドキュメントには含まれていません。 JCS準拠の番号シリアル化の実装者は、V8 [V8]でのGoogleの実装が参照として役立つ場合があります。別の互換性のある番号シリアル化リファレンス実装は、Ryu [RYU]です。これは、付録Gで説明されているJCSオープンソースJava実装で使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Since Not a Number (NaN) and Infinity are not permitted in JSON, occurrences of NaN or Infinity MUST cause a compliant JCS implementation to terminate with an appropriate error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：非数（NaN）および無限大はJSONでは許可されていないため、NaNまたは無限大が発生すると、準拠JCS実装が適切なエラーで終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-3--Sorting-of-Object-Properties">
3.2.3. Sorting of Object Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. オブジェクトプロパティの並べ替え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the previous step normalized the representation of primitive JSON data types, the result would not yet qualify as &#34;canonical&#34; since JSON object properties are not in lexicographic (alphabetical) order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前の手順ではプリミティブJSONデータ型の表現を正規化しましたが、JSONオブジェクトのプロパティは辞書式（アルファベット順）の順序ではないため、結果はまだ「正規」とは見なされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applied to the sample in Section 3.2.2, a properly canonicalized version should (with a line wrap added for display purposes only) read as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.2.2のサンプルに適用すると、適切に正規化されたバージョンは（表示目的でのみ行折り返しを追加して）次のように読み取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {&#34;literals&#34;:[null,true,false],&#34;numbers&#34;:[333333333.3333333,
     1e+30,4.5,0.002,1e-27],&#34;string&#34;:&#34;€$\u000f\nA&#39;B\&#34;\\\\\&#34;/&#34;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules for lexicographic sorting of JSON object properties according to JCS are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCSによるJSONオブジェクトプロパティの辞書式ソートのルールは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON object properties MUST be sorted recursively, which means that JSON child Objects MUST have their properties sorted as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSONオブジェクトのプロパティは再帰的にソートする必要があります。つまり、JSON子オブジェクトのプロパティもソートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON array data MUST also be scanned for the presence of JSON objects (if an object is found, then its properties MUST be sorted), but array element order MUST NOT be changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JSON配列データもJSONオブジェクトの存在をスキャンする必要があります（オブジェクトが見つかった場合、そのプロパティをソートする必要があります）が、配列要素の順序を変更してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a JSON object is about to have its properties sorted, the following measures MUST be adhered to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSONオブジェクトがそのプロパティをソートしようとしているときは、次の措置を遵守する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* The sorting process is applied to property name strings in their &#34;raw&#34; (unescaped) form. That is, a newline character is treated as U+000A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 並べ替えプロセスは、「生の」（エスケープされていない）形式のプロパティ名文字列に適用されます。つまり、改行文字はU + 000Aとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Property name strings to be sorted are formatted as arrays of UTF-16 [UNICODE] code units. The sorting is based on pure value comparisons, where code units are treated as unsigned integers, independent of locale settings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 並べ替えられるプロパティ名の文字列は、UTF-16 [UNICODE]コード単位の配列としてフォーマットされます。並べ替えは純粋な値の比較に基づいて行われ、ロケール設定に関係なく、コード単位は符号なし整数として扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Property name strings either have different values at some index that is a valid index for both strings, or their lengths are different, or both. If they have different values at one or more index positions, let k be the smallest such index; then, the string whose value at position k has the smaller value, as determined by using the &#34;&lt;&#34; operator, lexicographically precedes the other string. If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* プロパティ名の文字列は、両方の文字列に有効なインデックスであるいくつかのインデックスで異なる値を持っているか、それらの長さが異なるか、またはその両方です。 1つ以上のインデックス位置に異なる値がある場合、kをそのようなインデックスの最小値とします。次に、「&lt;」演算子を使用して決定された、位置kの値が小さい値の文字列が、辞書順で他の文字列の前に置かれます。それらが異なるインデックス位置がない場合は、短い文字列が辞書順で長い文字列に先行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In plain English, this means that property names are sorted in ascending order like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
プレーンな英語では、これはプロパティ名が次のように昇順でソートされることを意味します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
&#34;&#34; &#34;a&#34; &#34;aa&#34; &#34;ab&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
「」「a」「aa」「ab」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rationale for basing the sorting algorithm on UTF-16 code units is that it maps directly to the string type in ECMAScript (featured in web browsers and Node.js), Java, and .NET. In addition, JSON only supports escape sequences expressed as UTF-16 code units, making knowledge and handling of such data a necessity anyway. Systems using another internal representation of string data will need to convert JSON property name strings into arrays of UTF-16 code units before sorting. The conversion from UTF-8 or UTF-32 to UTF-16 is defined by the Unicode [UNICODE] standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソートアルゴリズムをUTF-16コード単位に基づいた根拠は、ECMAScript（WebブラウザーとNode.jsで機能）、Java、および.NETの文字列型に直接マッピングすることです。さらに、JSONはUTF-16コード単位として表現されたエスケープシーケンスのみをサポートしているため、このようなデータの知識と処理がとにかく必要になります。文字列データの別の内部表現を使用するシステムは、ソートする前にJSONプロパティ名文字列をUTF-16コード単位の配列に変換する必要があります。 UTF-8またはUTF-32からUTF-16への変換は、Unicode [UNICODE]標準で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following JSON test data can be used for verifying the correctness of the sorting scheme in a JCS implementation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のJSONテストデータは、JCS実装でのソートスキームの正確さを確認するために使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {
       &#34;\u20ac&#34;: &#34;Euro Sign&#34;,
       &#34;\r&#34;: &#34;Carriage Return&#34;,
       &#34;\ufb33&#34;: &#34;Hebrew Letter Dalet With Dagesh&#34;,
       &#34;1&#34;: &#34;One&#34;,
       &#34;\ud83d\ude00&#34;: &#34;Emoji: Grinning Face&#34;,
       &#34;\u0080&#34;: &#34;Control&#34;,
       &#34;\u00f6&#34;: &#34;Latin Small Letter O With Diaeresis&#34;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expected argument order after sorting property strings:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロパティ文字列をソートした後に期待される引数の順序：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&#34;Carriage Return&#34; &#34;One&#34; &#34;Control&#34; &#34;Latin Small Letter O With Diaeresis&#34; &#34;Euro Sign&#34; &#34;Emoji: Grinning Face&#34; &#34;Hebrew Letter Dalet With Dagesh&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
「復帰」「1」「コントロール」「分音記号付きラテン小文字O」「ユーロ記号」「絵文字：ニヤリと顔」「ヘゲライ文字ダゲシュ文字ダレット」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: For the purpose of obtaining a deterministic property order, sorting of data encoded in UTF-8 or UTF-32 would also work, but the outcome for JSON data like above would differ and thus be incompatible with this specification. However, in practice, property names are rarely defined outside of 7-bit ASCII, making it possible to sort string data in UTF-8 or UTF-32 format without conversion to UTF-16 and still be compatible with JCS. Whether or not this is a viable option depends on the environment JCS is used in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：確定的なプロパティの順序を取得するために、UTF-8またはUTF-32でエンコードされたデータの並べ替えも機能しますが、上記のようなJSONデータの結果は異なるため、この仕様と互換性がありません。ただし、実際には、プロパティ名が7ビットASCIIの外で定義されることはほとんどないため、UTF-16に変換せずに文字列データをUTF-8またはUTF-32形式でソートでき、JCSと互換性があります。これが実行可能なオプションであるかどうかは、JCSが使用されている環境によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2-4--UTF-8-Generation">
3.2.4. UTF-8 Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.4. UTF-8の生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, in order to create a platform-independent representation, the result of the preceding step MUST be encoded in UTF-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、プラットフォームに依存しない表現を作成するには、前のステップの結果をUTF-8でエンコードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applied to the sample in Section 3.2.3, this should yield the following bytes, here shown in hexadecimal notation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.2.3のサンプルに適用すると、次のバイトが生成されます。ここでは、16進表記で示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72 75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a 5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31 65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37 5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30 30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
7b 22 6c 69 74 65 72 61 6c 73 22 3a 5b 6e 75 6c 6c 2c 74 72 75 65 2c 66 61 6c 73 65 5d 2c 22 6e 75 6d 62 65 72 73 22 3a 5b 33 33 33 33 33 33 33 33 33 2e 33 33 33 33 33 33 33 2c 31 65 2b 33 30 2c 34 2e 35 2c 30 2e 30 30 32 2c 31 65 2d 32 37 5d 2c 22 73 74 72 69 6e 67 22 3a 22 e2 82 ac 24 5c 75 30 30 30 66 5c 6e 41 27 42 5c 22 5c 5c 5c 5c 5c 22 2f 22 7d
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data is intended to be usable as input to cryptographic methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータは、暗号化メソッドへの入力として使用できるように意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--IANA-Considerations">
4. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. IANAに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントにはIANAアクションはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Security-Considerations">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is crucial to perform sanity checks on input data to avoid overflowing buffers and similar things that could affect the integrity of the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
システムの整合性に影響を与える可能性のあるバッファのオーバーフローや同様のものを回避するために、入力データの健全性チェックを実行することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When JCS is applied to signature schemes like the one described in Appendix F, applications MUST perform the following operations before acting upon received data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Fで説明されているような署名方式にJCSが適用される場合、アプリケーションは受信したデータを処理する前に次の操作を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Parse the JSON data and verify that it adheres to I-JSON.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JSONデータを解析し、I-JSONに準拠していることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Verify the data for correctness according to the conventions defined by the ecosystem where it is to be used. This also includes locating the property holding the signature data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. データが使用されるエコシステムによって定義された規則に従って、データが正しいことを確認します。これには、署名データを保持するプロパティの検索も含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Verify the signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 署名を確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any of these steps fail, the operation in progress MUST be aborted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのステップのいずれかが失敗した場合、進行中の操作を中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--References">
6. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--Normative-References">
6.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 引用文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECMA-262] ECMA International, &#34;ECMAScript 2019 Language Specification&#34;, Standard ECMA-262 10th Edition, June 2019, &lt;https://www.ecma-international.org/ecma-262/10.0/ index.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECMA-262] ECMA International、「ECMAScript 2019 Language Specification」、Standard ECMA-262 10th Edition、2019年6月、&lt;https://www.ecma-international.org/ecma-262/10.0/ index.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE754] IEEE, &#34;IEEE Standard for Floating-Point Arithmetic&#34;, IEEE 754-2019, DOI 10.1109/IEEESTD.2019.8766229, &lt;https://ieeexplore.ieee.org/document/8766229&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE754] IEEE、「IEEE Standard for Floating-Point Arithmetic」、IEEE 754-2019、DOI 10.1109 / IEEESTD.2019.8766229、&lt;https://ieeexplore.ieee.org/document/8766229&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7493] Bray, T., Ed., &#34;The I-JSON Message Format&#34;, RFC 7493, DOI 10.17487/RFC7493, March 2015, &lt;https://www.rfc-editor.org/info/rfc7493&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7493]ブレイ、T。、編、「The I-JSON Message Format」、RFC 7493、DOI 10.17487 / RFC7493、2015年3月、&lt;https://www.rfc-editor.org/info/rfc7493&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8259] Bray, T., Ed., &#34;The JavaScript Object Notation (JSON) Data Interchange Format&#34;, STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, &lt;https://www.rfc-editor.org/info/rfc8259&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8259]ブレイ、T。、編、「JavaScript Object Notation（JSON）データ交換フォーマット」、STD 90、RFC 8259、DOI 10.17487 / RFC8259、2017年12月、&lt;https://www.rfc-editor.org / info / rfc8259&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UCNORM] The Unicode Consortium, &#34;Unicode Normalization Forms&#34;, &lt;https://www.unicode.org/reports/tr15/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UCNORM] Unicodeコンソーシアム、「Unicode Normalization Forms」、&lt;https://www.unicode.org/reports/tr15/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] The Unicode Consortium, &#34;The Unicode Standard&#34;, &lt;https://www.unicode.org/versions/latest/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UNICODE] Unicodeコンソーシアム、「The Unicode Standard」、&lt;https://www.unicode.org/versions/latest/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--Informative-References">
6.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 参考引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JSONCOMP] Rundgren, A., &#34;&#34;Comparable&#34; JSON (JSONCOMP)&#34;, Work in Progress, Internet-Draft, draft-rundgren-comparable-json-04, 13 February 2019, &lt;https://tools.ietf.org/html/draft-rundgren-comparable-json-04&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JSONCOMP] Rundgren、A。、「 &#34;Comparable&#34; JSON（JSONCOMP）」、Work in Progress、Internet-Draft、draft-rundgren-comparable-json-04、2019年2月13日、&lt;https://tools.ietf.org / html / draft-rundgren-comparable-json-04&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KEYBASE] Keybase, &#34;Canonical Packings for JSON and Msgpack&#34;, &lt;https://keybase.io/docs/api/1.0/canonical_packings&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KEYBASE]キーベース、「JSONおよびMsgpackの正規パッキング」、&lt;https://keybase.io/docs/api/1.0/canonical_packings&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NODEJS] OpenJS Foundation, &#34;Node.js&#34;, &lt;https://nodejs.org&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NODEJS] OpenJS Foundation、「Node.js」、&lt;https://nodejs.org&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OPENAPI] OpenAPI Initiative, &#34;The OpenAPI Specification: a broadly adopted industry standard for describing modern APIs&#34;, &lt;https://www.openapis.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OPENAPI] OpenAPIイニシアチブ、「OpenAPI仕様：最新のAPIを記述するために広く採用されている業界標準」、&lt;https://www.openapis.org/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, DOI 10.17487/RFC4648, October 2006, &lt;https://www.rfc-editor.org/info/rfc4648&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、&lt;https://www.rfc-editor.org/info/rfc4648&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7515] Jones, M., Bradley, J., and N. Sakimura, &#34;JSON Web Signature (JWS)&#34;, RFC 7515, DOI 10.17487/RFC7515, May 2015, &lt;https://www.rfc-editor.org/info/rfc7515&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7515]ジョーンズ、M。、ブラッドリー、J。、およびN.崎村、「JSON Web Signature（JWS）」、RFC 7515、DOI 10.17487 / RFC7515、2015年5月、&lt;https://www.rfc-editor.org / info / rfc7515&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7638] Jones, M. and N. Sakimura, &#34;JSON Web Key (JWK) Thumbprint&#34;, RFC 7638, DOI 10.17487/RFC7638, September 2015, &lt;https://www.rfc-editor.org/info/rfc7638&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7638]ジョーンズ、M。およびN.崎村、「JSON Web Key（JWK）Thumbprint」、RFC 7638、DOI 10.17487 / RFC7638、2015年9月、&lt;https://www.rfc-editor.org/info/rfc7638&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RYU] &#34;Ryu floating point number serializing algorithm&#34;, commit 27d3c55, May 2020, &lt;https://github.com/ulfjack/ryu&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RYU]「Ryu浮動小数点数シリアル化アルゴリズム」、コミット27d3c55、2020年5月、&lt;https://github.com/ulfjack/ryu&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V8] Google LLC, &#34;What is V8?&#34;, &lt;https://v8.dev/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V8] Google LLC、「V8とは」、&lt;https://v8.dev/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XMLDSIG] W3C, &#34;XML Signature Syntax and Processing Version 1.1&#34;, W3C Recommendation, April 2013, &lt;https://www.w3.org/TR/xmldsig-core1/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XMLDSIG] W3C、「XML署名構文および処理バージョン1.1」、W3C勧告、2013年4月、&lt;https://www.w3.org/TR/xmldsig-core1/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--ECMAScript-Sample-Canonicalizer">
Appendix A. ECMAScript Sample Canonicalizer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. ECMAScriptサンプルCanonicalizer
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below is an example of a JCS canonicalizer for usage with ECMAScript-based systems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、ECMAScriptベースのシステムで使用するJCS正規化子の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ////////////////////////////////////////////////////////////
     // Since the primary purpose of this code is highlighting //
     // the core of the JCS algorithm, error handling and      //
     // UTF-8 generation were not implemented.                 //
     ////////////////////////////////////////////////////////////
     var canonicalize = function(object) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         var buffer = &#39;&#39;;
         serialize(object);
         return buffer;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         function serialize(object) {
             if (object === null || typeof object !== &#39;object&#39; ||
                 object.toJSON != null) {
                 /////////////////////////////////////////////////
                 // Primitive type or toJSON, use &#34;JSON&#34;        //
                 /////////////////////////////////////////////////
                 buffer += JSON.stringify(object);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             } else if (Array.isArray(object)) {
                 /////////////////////////////////////////////////
                 // Array - Maintain element order              //
                 /////////////////////////////////////////////////
                 buffer += &#39;[&#39;;
                 let next = false;
                 object.forEach((element) =&gt; {
                     if (next) {
                         buffer += &#39;,&#39;;
                     }
                     next = true;
                     /////////////////////////////////////////
                     // Array element - Recursive expansion //
                     /////////////////////////////////////////
                     serialize(element);
                 });
                 buffer += &#39;]&#39;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             } else {
                 /////////////////////////////////////////////////
                 // Object - Sort properties before serializing //
                 /////////////////////////////////////////////////
                 buffer += &#39;{&#39;;
                 let next = false;
                 Object.keys(object).sort().forEach((property) =&gt; {
                     if (next) {
                         buffer += &#39;,&#39;;
                     }
                     next = true;
                     /////////////////////////////////////////////
                     // Property names are strings, use &#34;JSON&#34;  //
                     /////////////////////////////////////////////
                     buffer += JSON.stringify(property);
                     buffer += &#39;:&#39;;
                     //////////////////////////////////////////
                     // Property value - Recursive expansion //
                     //////////////////////////////////////////
                     serialize(object[property]);
                 });
                 buffer += &#39;}&#39;;
             }
         }
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Number-Serialization-Samples">
Appendix B. Number Serialization Samples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B.シリアル番号のサンプル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following table holds a set of ECMAScript-compatible number serialization samples, including some edge cases. The column &#34;IEEE 754&#34; refers to the internal ECMAScript representation of the &#34;Number&#34; data type, which is based on the IEEE 754 [IEEE754] standard using 64-bit (double-precision) values, here expressed in hexadecimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の表は、いくつかのエッジケースを含む、ECMAScript互換の番号シリアル化サンプルのセットを保持しています。 「IEEE 754」列は、「数値」データタイプの内部ECMAScript表現を指します。これは、64ビット（倍精度）値を使用するIEEE 754 [IEEE754]標準に基づいており、ここでは16進数で表現されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +==================+===========================+====================+
   |     IEEE 754     |    JSON Representation    |      Comment       |
   +==================+===========================+====================+
   | 0000000000000000 | 0                         | Zero               |
   +------------------+---------------------------+--------------------+
   | 8000000000000000 | 0                         | Minus zero         |
   +------------------+---------------------------+--------------------+
   | 0000000000000001 | 5e-324                    | Min pos number     |
   +------------------+---------------------------+--------------------+
   | 8000000000000001 | -5e-324                   | Min neg number     |
   +------------------+---------------------------+--------------------+
   | 7fefffffffffffff | 1.7976931348623157e+308   | Max pos number     |
   +------------------+---------------------------+--------------------+
   | ffefffffffffffff | -1.7976931348623157e+308  | Max neg number     |
   +------------------+---------------------------+--------------------+
   | 4340000000000000 | 9007199254740992          | Max pos int    (1) |
   +------------------+---------------------------+--------------------+
   | c340000000000000 | -9007199254740992         | Max neg int    (1) |
   +------------------+---------------------------+--------------------+
   | 4430000000000000 | 295147905179352830000     | ~2**68         (2) |
   +------------------+---------------------------+--------------------+
   | 7fffffffffffffff |                           | NaN            (3) |
   +------------------+---------------------------+--------------------+
   | 7ff0000000000000 |                           | Infinity       (3) |
   +------------------+---------------------------+--------------------+
   | 44b52d02c7e14af5 | 9.999999999999997e+22     |                    |
   +------------------+---------------------------+--------------------+
   | 44b52d02c7e14af6 | 1e+23                     |                    |
   +------------------+---------------------------+--------------------+
   | 44b52d02c7e14af7 | 1.0000000000000001e+23    |                    |
   +------------------+---------------------------+--------------------+
   | 444b1ae4d6e2ef4e | 999999999999999700000     |                    |
   +------------------+---------------------------+--------------------+
   | 444b1ae4d6e2ef4f | 999999999999999900000     |                    |
   +------------------+---------------------------+--------------------+
   | 444b1ae4d6e2ef50 | 1e+21                     |                    |
   +------------------+---------------------------+--------------------+
   | 3eb0c6f7a0b5ed8c | 9.999999999999997e-7      |                    |
   +------------------+---------------------------+--------------------+
   | 3eb0c6f7a0b5ed8d | 0.000001                  |                    |
   +------------------+---------------------------+--------------------+
   | 41b3de4355555553 | 333333333.3333332         |                    |
   +------------------+---------------------------+--------------------+
   | 41b3de4355555554 | 333333333.33333325        |                    |
   +------------------+---------------------------+--------------------+
   | 41b3de4355555555 | 333333333.3333333         |                    |
   +------------------+---------------------------+--------------------+
   | 41b3de4355555556 | 333333333.3333334         |                    |
   +------------------+---------------------------+--------------------+
   | 41b3de4355555557 | 333333333.33333343        |                    |
   +------------------+---------------------------+--------------------+
   | becbf647612f3696 | -0.0000033333333333333333 |                    |
   +------------------+---------------------------+--------------------+
   | 43143ff3c1cb0959 | 1424953923781206.2        | Round to even  (4) |
   +------------------+---------------------------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table 1: ECMAScript-Compatible JSON Number Serialization Samples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表1：ECMAScript互換のJSON番号シリアル化サンプル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノート：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) For maximum compliance with the ECMAScript &#34;JSON&#34; object, values that are to be interpreted as true integers SHOULD be in the range -9007199254740991 to 9007199254740991. However, how numbers are used in applications does not affect the JCS algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1）ECMAScript「JSON」オブジェクトに最大限準拠するには、真の整数として解釈される値は-9007199254740991〜9007199254740991の範囲にある必要があります。ただし、アプリケーションでの数値の使用方法はJCSアルゴリズムに影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) Although a set of specific integers like 2**68 could be regarded as having extended precision, the JCS/ECMAScript number serialization algorithm does not take this into consideration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2）2 ** 68のような特定の整数のセットは拡張精度を持つと見なすことができますが、JCS / ECMAScript番号シリアル化アルゴリズムはこれを考慮しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) Values out of range are not permitted in JSON. See Section 3.2.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3）範囲外の値はJSONでは許可されていません。セクション3.2.2.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) This number is exactly 1424953923781206.25 but will, after the &#34;Note 2&#34; rule mentioned in Section 3.2.2.3, be truncated and rounded to the closest even value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（4）この数値は正確に1424953923781206.25ですが、セクション3.2.2.3で説明されている「注2」のルールの後、切り捨てられ、最も近い偶数値に丸められます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a more exhaustive validation of a JCS number serializer, you may test against a file (currently) available in the development portal (see Appendix I) containing a large set of sample values. Another option is running V8 [V8] as a live reference together with a program generating a substantial amount of random IEEE 754 values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCS番号シリアライザのより徹底的な検証のために、サンプル値の大規模なセットを含む開発ポータル（付録Iを参照）で（現在）利用可能なファイルに対してテストできます。別のオプションは、相当量のランダムなIEEE 754値を生成するプログラムと共にライブ参照としてV8 [V8]を実行することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix C. Canonicalized JSON as &#34;Wire Format&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録C.「ワイヤー形式」としての正規化されたJSON
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the result from the canonicalization process (see Section 3.2.4) is fully valid JSON, it can also be used as &#34;Wire Format&#34;. However, this is just an option since cryptographic schemes based on JCS, in most cases, would not depend on that externally supplied JSON data already being canonicalized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規化プロセス（セクション3.2.4を参照）の結果は完全に有効なJSONであるため、「ワイヤー形式」としても使用できます。ただし、これは単なる選択肢です。JCSに基づく暗号化スキームは、ほとんどの場合、すでに正規化されている外部から提供されたJSONデータに依存しないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In fact, the ECMAScript standard way of serializing objects using &#34;JSON.stringify()&#34; produces a more &#34;logical&#34; format, where properties are kept in the order they were created or received. The example below shows an address record that could benefit from ECMAScript standard serialization:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際、「JSON.stringify()」を使用してオブジェクトをシリアル化するECMAScriptの標準的な方法では、より「論理的な」形式が生成され、プロパティは作成または受信された順序で保持されます。以下の例は、ECMAScript標準シリアル化の恩恵を受けることができる住所レコードを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {
       &#34;name&#34;: &#34;John Doe&#34;,
       &#34;address&#34;: &#34;2000 Sunset Boulevard&#34;,
       &#34;city&#34;: &#34;Los Angeles&#34;,
       &#34;zip&#34;: &#34;90001&#34;,
       &#34;state&#34;: &#34;CA&#34;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using canonicalization, the properties above would be output in the order &#34;address&#34;, &#34;city&#34;, &#34;name&#34;, &#34;state&#34;, and &#34;zip&#34;, which adds fuzziness to the data from a human (developer or technical support) perspective. Canonicalization also converts JSON data into a single line of text, which may be less than ideal for debugging and logging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規化を使用すると、上記のプロパティは「住所」、「市」、「名前」、「州」、「zip」の順に出力され、人間（開発者または技術サポート）の観点からデータにあいまいさが追加されます。正規化では、JSONデータも1行のテキストに変換されます。これは、デバッグやロギングに理想的ではない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-D--Dealing-with-Big-Numbers">
Appendix D. Dealing with Big Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録D.大きな数字への対処
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several issues associated with the JSON number type, here illustrated by the following sample object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSON番号タイプに関連する問題がいくつかあります。ここでは、次のサンプルオブジェクトで示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {
       &#34;giantNumber&#34;: 1.4e+9999,
       &#34;payMeThis&#34;: 26000.33,
       &#34;int64Max&#34;: 9223372036854775807
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the sample above conforms to JSON [RFC8259], applications would normally use different native data types for storing &#34;giantNumber&#34; and &#34;int64Max&#34;. In addition, monetary data like &#34;payMeThis&#34; would presumably not rely on floating-point data types due to rounding issues with respect to decimal arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のサンプルはJSON [RFC8259]に準拠していますが、アプリケーションは通常、「giantNumber」と「int64Max」の格納に異なるネイティブデータタイプを使用します。さらに、「payMeThis」などの通貨データは、10進数演算に関する丸めの問題のため、おそらく浮動小数点データ型に依存しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The established way of handling this kind of &#34;overloading&#34; of the JSON number type (at least in an extensible manner) is through mapping mechanisms, instructing parsers what to do with different properties based on their name. However, this greatly limits the value of using the JSON number type outside of its original, somewhat constrained JavaScript context. The ECMAScript &#34;JSON&#34; object does not support mappings to the JSON number type either.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSON番号タイプのこのような「オーバーロード」を（少なくとも拡張可能な方法で）処理する確立された方法は、マッピングメカニズムを介して、パーサーに名前に基づいてさまざまなプロパティをどうするかを指示することです。ただし、これにより、JSON数値タイプを元の、多少制約のあるJavaScriptコンテキスト以外で使用する価値が大幅に制限されます。 ECMAScriptの「JSON」オブジェクトは、JSON数値タイプへのマッピングもサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to the above, numbers that do not have a natural place in the current JSON ecosystem MUST be wrapped using the JSON string type. This is close to a de facto standard for open systems. This is also applicable for other data types that do not have direct support in JSON, like &#34;DateTime&#34; objects as described in Appendix E.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のため、現在のJSONエコシステムで自然な位置にない数値は、JSON文字列タイプを使用してラップする必要があります。これは、オープンシステムの事実上の標準に近いものです。これは、付録Eで説明されている「DateTime」オブジェクトなど、JSONで直接サポートされていない他のデータ型にも適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aided by a system using the JSON string type, be it programmatic like
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSON文字列型を使用するシステムによって支援されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     var obj = JSON.parse(&#39;{&#34;giantNumber&#34;: &#34;1.4e+9999&#34;}&#39;);
     var biggie = new BigNumber(obj.giantNumber);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
or declarative schemes like OpenAPI [OPENAPI], JCS imposes no limits on applications, including when using ECMAScript.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
またはOpenAPI [OPENAPI]のような宣言的スキームでは、JCSはECMAScriptを使用する場合を含め、アプリケーションに制限を課しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-E--String-Subtype-Handling">
Appendix E. String Subtype Handling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録E.文字列サブタイプの処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to the limited set of data types featured in JSON, the JSON string type is commonly used for holding subtypes. This can, depending on JSON parsing method, lead to interoperability problems, which MUST be dealt with by JCS-compliant applications targeting a wider audience.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSONで特徴付けられるデータ型のセットが限られているため、JSON文字列型は一般にサブタイプを保持するために使用されます。これは、JSON解析方法に応じて、相互運用性の問題を引き起こす可能性があります。これは、より広い対象者を対象とするJCS準拠のアプリケーションで処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume you want to parse a JSON object where the schema designer assigned the property &#34;big&#34; for holding a &#34;BigInt&#34; subtype and &#34;time&#34; for holding a &#34;DateTime&#34; subtype, while &#34;val&#34; is supposed to be a JSON number compliant with JCS. The following example shows such an object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スキーマデザイナが「BigInt」サブタイプを保持するためのプロパティ「big」と「DateTime」サブタイプを保持するための「time」を割り当てたJSONオブジェクトを解析するとします。「val」は、 JCS。次の例は、そのようなオブジェクトを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {
       &#34;time&#34;: &#34;2019-01-28T07:45:10Z&#34;,
       &#34;big&#34;: &#34;055&#34;,
       &#34;val&#34;: 3.5
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parsing of this object can be accomplished by the following ECMAScript statement:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオブジェクトの解析は、次のECMAScriptステートメントによって実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     var object = JSON.parse(JSON_object_featured_as_a_string);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After parsing, the actual data can be extracted, which for subtypes, also involves a conversion step using the result of the parsing process (an ECMAScript object) as input:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解析後、実際のデータを抽出できます。サブタイプの場合、解析プロセスの結果（ECMAScriptオブジェクト）を入力として使用する変換ステップも含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ... = new Date(object.time); // Date object
     ... = BigInt(object.big);    // Big integer
     ... = object.val;            // JSON/JS number
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the &#34;BigInt&#34; data type is currently only natively supported by V8 [V8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「BigInt」データ型は現在、V8 [V8]でのみネイティブでサポートされていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Canonicalization of &#34;object&#34; using the sample code in Appendix A would return the following string:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Aのサンプルコードを使用して「オブジェクト」を正規化すると、次の文字列が返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {&#34;big&#34;:&#34;055&#34;,&#34;time&#34;:&#34;2019-01-28T07:45:10Z&#34;,&#34;val&#34;:3.5}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although this is (with respect to JCS) technically correct, there is another way of parsing JSON data, which also can be used with ECMAScript as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは（JCSに関して）技術的には正しいですが、JSONデータを解析する別の方法があり、以下に示すようにECMAScriptでも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // &#34;BigInt&#34; requires the following code to become JSON serializable
     BigInt.prototype.toJSON = function() {
         return this.toString();
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // JSON parsing using a &#34;stream&#34;-based method
     var object = JSON.parse(JSON_object_featured_as_a_string,
         (k,v) =&gt; k == &#39;time&#39; ? new Date(v) : k == &#39;big&#39; ? BigInt(v) : v
     );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If you now apply the canonicalizer in Appendix A to &#34;object&#34;, the following string would be generated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
付録Aの正規化子を「オブジェクト」に適用すると、次の文字列が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     {&#34;big&#34;:&#34;55&#34;,&#34;time&#34;:&#34;2019-01-28T07:45:10.000Z&#34;,&#34;val&#34;:3.5}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the string arguments for &#34;big&#34; and &#34;time&#34; have changed with respect to the original, presumably making an application depending on JCS fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この場合、 &#34;big&#34;と &#34;time&#34;の文字列引数が元の引数に対して変更されているため、おそらくJCSに依存するアプリケーションが失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason for the deviation is that in stream- and schema-based JSON parsers, the original string argument is typically replaced on the fly by the native subtype that, when serialized, may exhibit a different and platform-dependent pattern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
偏差の理由は、ストリームベースおよびスキーマベースのJSONパーサーでは、通常、元の文字列引数は、シリアル化されたときに異なるプラットフォーム依存のパターンを示す可能性があるネイティブサブタイプによってその場で置き換えられるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, stream- and schema-based parsing MUST treat subtypes as &#34;pure&#34; (immutable) JSON string types and perform the actual conversion to the designated native type in a subsequent step. In modern programming platforms like Go, Java, and C#, this can be achieved with moderate efforts by combining annotations, getters, and setters. Below is an example in C#/Json.NET showing a part of a class that is serializable as a JSON object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、ストリームベースおよびスキーマベースの解析では、サブタイプを「純粋な」（不変の）JSON文字列タイプとして扱い、その後のステップで指定されたネイティブタイプへの実際の変換を実行する必要があります。 Go、Java、C＃などの最新のプログラミングプラットフォームでは、アノテーション、ゲッター、セッターを組み合わせることにより、適度な労力でこれを実現できます。以下は、JSONオブジェクトとしてシリアル化可能なクラスの一部を示すC＃/ Json.NETの例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     // The &#34;pure&#34; string solution uses a local
     // string variable for JSON serialization while
     // exposing another type to the application
     [JsonProperty(&#34;amount&#34;)]
     private string _amount;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     [JsonIgnore]
     public decimal Amount {
         get { return decimal.Parse(_amount); }
         set { _amount = value.ToString(); }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an application, &#34;Amount&#34; can be accessed as any other property while it is actually represented by a quoted string in JSON contexts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションでは、「金額」は他のプロパティとしてアクセスできますが、実際にはJSONコンテキストで引用符付きの文字列で表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The example above also addresses the constraints on numeric data implied by I-JSON (the C# &#34;decimal&#34; data type has quite different characteristics compared to IEEE 754 double precision).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：上記の例は、I-JSONによって暗示される数値データの制約にも対処しています（C＃の「10進数」データ型は、IEEE 754倍精度と比較してまったく異なる特性を持っています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-1--Subtypes-in-Arrays">
E.1. Subtypes in Arrays
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. 配列のサブタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the JSON array construct permits mixing arbitrary JSON data types, custom parsing and serialization code may be required to cope with subtypes anyway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JSON配列構成では任意のJSONデータ型を混在させることができるため、いずれにしてもサブタイプを処理するにはカスタムの解析およびシリアル化コードが必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-F--Implementation-Guidelines">
Appendix F. Implementation Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録F.実装ガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The optimal solution is integrating support for JCS directly in JSON serializers (parsers need no changes). That is, canonicalization would just be an additional &#34;mode&#34; for a JSON serializer. However, this is currently not the case. Fortunately, JCS support can be introduced through externally supplied canonicalizer software acting as a post processor to existing JSON serializers. This arrangement also relieves the JCS implementer from having to deal with how underlying data is to be represented in JSON.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最適なソリューションは、JCSのサポートをJSONシリアライザーに直接統合することです（パーサーは変更を必要としません）。つまり、正規化は、JSONシリアライザーの追加の「モード」にすぎません。ただし、現在のところそうではありません。さいわい、JCSサポートは、既存のJSONシリアライザーのポストプロセッサとして機能する外部から提供された正規化ソフトウェアを通じて導入できます。また、この配置により、JCS実装者は、基礎となるデータをJSONで表現する方法を処理する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The post processor concept enables signature creation schemes like the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポストプロセッサの概念により、次のような署名作成スキームが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Create the data to be signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 署名するデータを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Serialize the data using existing JSON tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 既存のJSONツールを使用してデータをシリアル化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Let the external canonicalizer process the serialized data and return canonicalized result data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 外部正規化プログラムにシリアル化されたデータを処理させ、正規化された結果データを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Sign the canonicalized data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 正規化されたデータに署名します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Add the resulting signature value to the original JSON data through a designated signature property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 指定された署名プロパティを通じて、結果の署名値を元のJSONデータに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Serialize the completed (now signed) JSON object using existing JSON tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 既存のJSONツールを使用して、完成した（署名された）JSONオブジェクトをシリアル化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compatible signature verification scheme would then be as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互換性のある署名検証スキームは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Parse the signed JSON data using existing JSON tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 既存のJSONツールを使用して、署名されたJSONデータを解析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Read and save the signature value from the designated signature property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 指定された署名プロパティから署名値を読み取って保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Remove the signature property from the parsed JSON object.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 解析されたJSONオブジェクトから署名プロパティを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Serialize the remaining JSON data using existing JSON tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 既存のJSONツールを使用して残りのJSONデータをシリアル化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Let the external canonicalizer process the serialized data and return canonicalized result data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 外部正規化プログラムにシリアル化されたデータを処理させ、正規化された結果データを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Verify that the canonicalized data matches the saved signature value using the algorithm and key used for creating the signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 正規化されたデータが、署名の作成に使用されたアルゴリズムとキーを使用して、保存された署名の値と一致することを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A canonicalizer like above is effectively only a &#34;filter&#34;, potentially usable with a multitude of quite different cryptographic schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のような正規化子は、事実上「フィルター」にすぎず、多数のまったく異なる暗号化スキームで潜在的に使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using a JSON serializer with integrated JCS support, the serialization performed before the canonicalization step could be eliminated for both processes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
統合されたJCSサポートを備えたJSONシリアライザーを使用すると、正規化手順の前に実行されたシリアライゼーションを両方のプロセスで排除できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix G. Open-Source Implementations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録G.オープンソース実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following open-source implementations have been verified to be compatible with JCS:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のオープンソース実装は、JCSと互換性があることが確認されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JavaScript: &lt;https://www.npmjs.com/package/canonicalize&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* JavaScript：&lt;https://www.npmjs.com/package/canonicalize&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Java: &lt;https://github.com/erdtman/java-json-canonicalization&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Java：&lt;https://github.com/erdtman/java-json-canonicalization&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Go: &lt;https://github.com/cyberphone/json-canonicalization/tree/master/go&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* ご： ＜ｈっｔｐｓ：／／ぎてゅｂ。こｍ／ｃｙべｒｐほね／ｊそんーかのにかぃざちおん／ｔれえ／まｓてｒ／ご＞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   *  .NET/C#: &lt;https://github.com/cyberphone/json-
      canonicalization/tree/master/dotnet&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Python: &lt;https://github.com/cyberphone/json-canonicalization/tree/master/python3&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Python：&lt;https://github.com/cyberphone/json-canonicalization/tree/master/python3&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix H. Other JSON Canonicalization Efforts
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録H.その他のJSON正規化の取り組み
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are (and have been) other efforts creating &#34;Canonical JSON&#34;. Below is a list of URLs to some of them:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「Canonical JSON」を作成する他の取り組みがあります（されています）。以下はそれらのいくつかへのURLのリストです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   *  &lt;https://tools.ietf.org/html/draft-staykov-hu-json-canonical-form-
      00&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   *  &lt;https://gibson042.github.io/canonicaljson-spec/&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   *  &lt;http://wiki.laptop.org/go/Canonical_JSON&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The listed efforts all build on text-level JSON-to-JSON transformations. The primary feature of text-level canonicalization is that it can be made neutral to the flavor of JSON used. However, such schemes also imply major changes to the JSON parsing process, which is a likely hurdle for adoption. Albeit at the expense of certain JSON and application constraints, JCS was designed to be compatible with existing JSON tools.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リストされている取り組みはすべて、テキストレベルのJSONからJSONへの変換に基づいています。テキストレベルの正規化の主な機能は、使用するJSONのフレーバーに中立にすることができることです。ただし、このようなスキームは、JSON解析プロセスへの大きな変更も意味します。これは、採用のハードルになる可能性があります。特定のJSONおよびアプリケーションの制約を犠牲にしても、JCSは既存のJSONツールと互換性があるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix I. Development Portal
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録I.開発ポータル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JCS specification is currently developed at: &lt;https://github.com/cyberphone/ietf-json-canon&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCS仕様は現在&lt;https://github.com/cyberphone/ietf-json-canon&gt;で開発されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCS source code and extensive test data is available at: &lt;https://github.com/cyberphone/json-canonicalization&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JCSソースコードと広範なテストデータは、&lt;https://github.com/cyberphone/json-canonicalization&gt;で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Building on ECMAScript number serialization was originally proposed by James Manger. This ultimately led to the adoption of the entire ECMAScript serialization scheme for JSON primitives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECMAScript番号のシリアル化に基づくことは、もともとJames Mangerによって提案されました。これにより、最終的には、JSONプリミティブにECMAScriptシリアル化スキーム全体が採用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other people who have contributed with valuable input to this specification include Scott Ananian, Tim Bray, Ben Campbell, Adrian Farell, Richard Gibson, Bron Gondwana, John-Mark Gurney, Mike Jones, John Levine, Mark Miller, Matthew Miller, Mark Nottingham, Mike Samuel, Jim Schaad, Robert Tupelo-Schneck, and Michal Wadas.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様に貴重な情報を提供してくれた他の人々には、スコットアナニアン、ティムブレイ、ベンキャンベル、エイドリアンファレル、リチャードギブソン、ブロンゴンドワナ、ジョンマークガーニー、マイクジョーンズ、ジョンレバイン、マークミラー、マシューミラー、マークノッティンガム、 Mike Samuel、Jim Schaad、Robert Tupelo-Schneck、Michal Wadas。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For carrying out real-world concept verification, the software and support for number serialization provided by Ulf Adams, Tanner Gooding, and Remy Oudompheng was very helpful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現実世界の概念検証を実行するために、Ulf Adams、Tanner Gooding、およびRemy Oudomphengによって提供されるソフトウェアと番号シリアル化のサポートが非常に役立ちました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anders Rundgren Independent Montpellier France
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンデルスラングレンインディペンデントモンペリエフランス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: anders.rundgren.net@gmail.com
   URI:   https://www.linkedin.com/in/andersrundgren/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bret Jordan Broadcom 1320 Ridder Park Drive San Jose, CA 95131 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブレットジョーダンBroadcom 1320 Ridder Park Driveサンノゼ、CA 95131アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: bret.jordan@broadcom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Samuel Erdtman Spotify AB Birger Jarlsgatan 61, 4tr SE-113 56 Stockholm Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Samuel Erdtman Spotify AB Birger Jarlsgatan 61、4tr SE-113 56ストックホルムスウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Email: erdtman@spotify.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
