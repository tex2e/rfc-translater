<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9415 - On the Generation of Transient Numeric Identifiers 日本語訳</title>
  <meta name="description" content="この文書は、IETFプロトコルで使用されるさまざまな種類の「一時的な数値識別子」のセキュリティとプライバシーへの影響を分析し、相互運用性要件とその要件を満たさない場合の関連する障害の深刻度に基づいてそれらを分類しようとします。その後、各識別子カテゴリーの相互運用性要件を満たすために使用できる可能性のあるアルゴリズムに関するアドバイスを提供し、負のセキュリティとプライバシーへの影響を最小限に抑えながら、プロトコル設計者やプロトコル実装者にガイダンスを提供します。最後に、実際の実装で使用されているいくつかのアルゴリズムを説明し、一時的な数値識別子を生成するために使用されるセキュリティとプライバシーの特性を分析します。この文書は、IRTFのPrivacy Enhancements and Assessments Research Group（PEARG）の製品です。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9415</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc9415.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9415 - On the Generation of Transient Numeric Identifiers 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://www.rfc-editor.org/rfc/rfc9415.html">
            https://www.rfc-editor.org/rfc/rfc9415.html
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9415 - 一時的な数値識別子の生成について</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成＆手動修正</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] この文書は、IETFプロトコルで使用されるさまざまな種類の「一時的な数値識別子」のセキュリティとプライバシーへの影響を分析し、相互運用性要件とその要件を満たさない場合の関連する障害の深刻度に基づいてそれらを分類しようとします。その後、各識別子カテゴリーの相互運用性要件を満たすために使用できる可能性のあるアルゴリズムに関するアドバイスを提供し、負のセキュリティとプライバシーへの影響を最小限に抑えながら、プロトコル設計者やプロトコル実装者にガイダンスを提供します。最後に、実際の実装で使用されているいくつかのアルゴリズムを説明し、一時的な数値識別子を生成するために使用されるセキュリティとプライバシーの特性を分析します。この文書は、IRTFのPrivacy Enhancements and Assessments Research Group（PEARG）の製品です。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Research Task Force (IRTF)                              F. Gont
Request for Comments: 9415                                  SI6 Networks
Category: Informational                                          I. Arce
ISSN: 2070-1721                                                Quarkslab
                                                               July 2023
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="On-the-Generation-of-Transient-Numeric-Identifiers">
On the Generation of Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
一時的な数値識別子の生成について
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Abstract">
Abstract
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document performs an analysis of the security and privacy implications of different types of &#34;transient numeric identifiers&#34; used in IETF protocols and tries to categorize them based on their interoperability requirements and their associated failure severity when such requirements are not met. Subsequently, it provides advice on possible algorithms that could be employed to satisfy the interoperability requirements of each identifier category while minimizing the negative security and privacy implications, thus providing guidance to protocol designers and protocol implementers. Finally, it describes a number of algorithms that have been employed in real implementations to generate transient numeric identifiers and analyzes their security and privacy properties. This document is a product of the Privacy Enhancements and Assessments Research Group (PEARG) in the IRTF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IETFプロトコルで使用されるさまざまなタイプの「一時的な数値識別子」のセキュリティとプライバシーへの影響の分析を実行し、そのような要件が満たされていない場合、相互運用性要件と関連する障害の重大度に基づいてそれらを分類しようとします。その後、各識別子カテゴリの相互運用性要件を満たすために採用できる可能性のあるアルゴリズムに関するアドバイスを提供し、ネガティブなセキュリティとプライバシーへの影響を最小限に抑え、プロトコルデザイナーとプロトコル実装者にガイダンスを提供します。最後に、一時的な数値識別子を生成するために実際の実装で採用されている多くのアルゴリズムを説明し、セキュリティとプライバシーのプロパティを分析します。このドキュメントは、IRTFのプライバシー強化と評価研究グループ（PEARG）の製品です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Status-of-This-Memo">
Status of This Memo
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
本文書の位置付け
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Privacy Enhancements and Assessments Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、インターネット研究タスクフォース（IRTF）の製品です。IRTFは、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開に適していない場合があります。このRFCは、インターネット研究タスクフォース（IRTF）のプライバシー強化と評価研究グループのコンセンサスを表しています。IRSGによって公開されたことが承認された文書は、インターネット標準のレベルの候補者ではありません。RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9415.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9415で取得できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Copyright-Notice">
Copyright Notice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
著作権表示
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（c）2023 IETF Trustおよび文書著者として特定された人。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Table-of-Contents">
Table of Contents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
目次
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Terminology
   3.  Threat Model
   4.  Issues with the Specification of Transient Numeric Identifiers
   5.  Protocol Failure Severity
   6.  Categorizing Transient Numeric Identifiers
   7.  Common Algorithms for Transient Numeric Identifier Generation
     7.1.  Category #1: Uniqueness (Soft Failure)
     7.2.  Category #2: Uniqueness (Hard Failure)
     7.3.  Category #3: Uniqueness, Stable within Context (Soft
           Failure)
     7.4.  Category #4: Uniqueness, Monotonically Increasing within
           Context (Hard Failure)
   8.  Common Vulnerabilities Associated with Transient Numeric
           Identifiers
     8.1.  Network Activity Correlation
     8.2.  Information Leakage
     8.3.  Fingerprinting
     8.4.  Exploitation of the Semantics of Transient Numeric
           Identifiers
     8.5.  Exploitation of Collisions of Transient Numeric Identifiers
     8.6.  Exploitation of Predictable Transient Numeric Identifiers
           for Injection Attacks
     8.7.  Cryptanalysis
   9.  Vulnerability Assessment of Transient Numeric Identifiers
     9.1.  Category #1: Uniqueness (Soft Failure)
     9.2.  Category #2: Uniqueness (Hard Failure)
     9.3.  Category #3: Uniqueness, Stable within Context (Soft
           Failure)
     9.4.  Category #4: Uniqueness, Monotonically Increasing within
           Context (Hard Failure)
   10. IANA Considerations
   11. Security Considerations
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Algorithms and Techniques with Known Issues
     A.1.  Predictable Linear Identifiers Algorithm
     A.2.  Random-Increments Algorithm
     A.3.  Reusing Identifiers Across Different Contexts
   Acknowledgements
   Authors&#39; Addresses
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Networking protocols employ a variety of transient numeric identifiers for different protocol objects, such as IPv4 and IPv6 Identification values [RFC0791] [RFC8200], IPv6 Interface Identifiers (IIDs) [RFC4291], transport-protocol ephemeral port numbers [RFC6056], TCP Initial Sequence Numbers (ISNs) [RFC9293], NTP Reference IDs (REFIDs) [RFC5905], and DNS IDs [RFC1035]. These identifiers typically have specific requirements (e.g., uniqueness during a specified period of time) that must be satisfied such that they do not result in negative interoperability implications and an associated failure severity when such requirements are not met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーキングプロトコルは、IPv4およびIPv6識別値[RFC0791] [RFC8200]、IPv6インターフェイス識別子（IID）[RFC4291]、輸送中間ムラーポート[RFC6056]、TCP初期など、さまざまなプロトコルオブジェクトのさまざまな一時的な数値識別子を採用しています。シーケンス番号（ISNS）[RFC9293]、NTP参照ID（REFIDS）[RFC5905]、およびDNS IDS [RFC1035]。これらの識別子には通常、特定の要件（特定の期間中の単一性など）があり、そのような要件が満たされない場合、否定的な相互運用性の意味と関連する障害の重大度をもたらさないように満たさなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: Some documents refer to the DNS ID as the DNS &#34;Query ID&#34; or &#34;TxID&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：一部のドキュメントでは、DNS IDをDNS「クエリID」または「TXID」と呼びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more than 30 years, a large number of implementations of IETF protocols have been subject to a variety of attacks, with effects ranging from Denial of Service (DoS) or data injection to information leakages that could be exploited for pervasive monitoring [RFC7258]. The root cause of these issues has been, in many cases, the poor selection of transient numeric identifiers in such protocols, usually as a result of insufficient or misleading specifications. While it is generally trivial to identify an algorithm that can satisfy the interoperability requirements of a given transient numeric identifier, empirical evidence exists that doing so without negatively affecting the security and/or privacy properties of the aforementioned protocols is prone to error [RFC9414].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
30年以上にわたり、IETFプロトコルの多数の実装がさまざまな攻撃の対象となり、サービス拒否（DOS）またはデータインジェクションから、広範な監視に利用できる情報漏れに至るまでの影響があります[RFC7258]。これらの問題の根本的な原因は、多くの場合、このようなプロトコルにおける一時的な数値識別子の選択が不十分であり、通常は不十分または誤解を招く仕様の結果です。一般に、特定の一時的な数値識別子の相互運用性要件を満たすことができるアルゴリズムを識別することは些細なことですが、前述のプロトコルのセキュリティおよび/またはプライバシー特性に悪影響を与えることなくそうすることは、エラーが発生しやすいという経験的証拠が存在します[RFC9414]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, implementations have been subject to security and/or privacy issues resulting from:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、実装は、次の結果として生じるセキュリティおよび/またはプライバシーの問題の対象となっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* predictable IPv4 or IPv6 Identification values (e.g., see [Sanfilippo1998a], [RFC6274], and [RFC7739]),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 予測可能なIPv4またはIPv6識別値（たとえば、[sanfilippo1998a]、[rfc6274]、および[rfc7739]を参照）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* predictable IPv6 IIDs (e.g., see [RFC7217], [RFC7707], and [RFC7721]),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 予測可能なIPv6 IID（例：[RFC7217]、[RFC7707]、および[RFC7721]を参照）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* predictable transport-protocol ephemeral port numbers (e.g., see [RFC6056] and [Silbersack2005]),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 予測可能なトランスポートプロトコールの一時的なポート番号（例：[RFC6056]および[SilberSack2005]を参照）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* predictable TCP Initial Sequence Numbers (ISNs) (e.g., see [Morris1985], [Bellovin1989], and [RFC6528]),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 予測可能なTCP初期シーケンス番号（ISNS）（たとえば、[Morris1985]、[Bellovin1989]、および[RFC6528]を参照）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* predictable initial timestamps in TCP timestamps options (e.g., see [TCPT-uptime] and [RFC7323]), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* TCPタイムスタンプのオプションの予測可能な初期タイムスタンプ（例：[TCPT-uptime]および[RFC7323]を参照）、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* predictable DNS IDs (see, e.g., [Schuba1993] and [Klein2007]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 予測可能なDNS IDS（例えば[Schuba1993]および[Klein2007]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recent history indicates that, when new protocols are standardized or new protocol implementations are produced, the security and privacy properties of the associated transient numeric identifiers tend to be overlooked, and inappropriate algorithms to generate such identifiers are either suggested in the specifications or selected by implementers. As a result, advice in this area is warranted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最近の履歴は、新しいプロトコルが標準化されているか、新しいプロトコルの実装が生成された場合、関連する一過性の数値識別子のセキュリティとプライバシーのプロパティが見落とされる傾向があり、そのような識別子を生成するための不適切なアルゴリズムは、実装者によって提案されるか、実装者によって選択されていることを示しています。。その結果、この分野でのアドバイスが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that the use of cryptographic techniques may readily mitigate some of the issues arising from predictable transient numeric identifiers. For example, cryptographic authentication can readily mitigate data injection attacks even in the presence of predictable transient numeric identifiers (such as &#34;sequence numbers&#34;). However, use of flawed algorithms (such as global counters) for generating transient numeric identifiers could still result in information leakages even when cryptographic techniques are employed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化技術の使用は、予測可能な一時的な数値識別子から生じる問題のいくつかを容易に軽減する可能性があることに注意してください。たとえば、暗号化認証は、予測可能な一時的な数値識別子（「シーケンス番号」など）が存在する場合でも、データインジェクション攻撃を容易に軽減できます。ただし、一時的な数値識別子を生成するための欠陥のあるアルゴリズム（グローバルカウンターなど）の使用は、暗号化手法が採用されている場合でも、情報漏れをもたらす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document contains a non-exhaustive survey of transient numeric identifiers employed in various IETF protocols and aims to categorize such identifiers based on their interoperability requirements and the associated failure severity when such requirements are not met. Subsequently, it provides advice on possible algorithms that could be employed to satisfy the interoperability requirements of each category while minimizing negative security and privacy implications. Finally, it analyzes several algorithms that have been employed in real implementations to meet such requirements and analyzes their security and privacy properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントには、さまざまなIETFプロトコルで採用されている一時的な数値識別子の非網羅的な調査が含まれており、そのような要件が満たされていない場合の相互運用性要件と関連する障害の重大度に基づいて、そのような識別子を分類することを目的としています。その後、否定的なセキュリティとプライバシーへの影響を最小限に抑えながら、各カテゴリの相互運用性要件を満たすために採用できる可能性のあるアルゴリズムに関するアドバイスを提供します。最後に、このような要件を満たすために実際の実装で採用されているいくつかのアルゴリズムを分析し、セキュリティとプライバシーのプロパティを分析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document represents the consensus of the Privacy Enhancements and Assessments Research Group (PEARG).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、プライバシー強化と評価研究グループ（PEARG）のコンセンサスを表しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Terminology">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 用語
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transient Numeric Identifier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的な数値識別子：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
A data object in a protocol specification that can be used to definitely distinguish a protocol object (a datagram, network interface, transport-protocol endpoint, session, etc.) from all other objects of the same type, in a given context. Transient numeric identifiers are usually defined as a series of bits and represented using integer values. These identifiers are typically dynamically selected, as opposed to statically assigned numeric identifiers (see, e.g., [IANA-PROT]). We note that different transient numeric identifiers may have additional requirements or properties depending on their specific use in a protocol. We use the term &#34;transient numeric identifier&#34; (or simply &#34;numeric identifier&#34; or &#34;identifier&#34; as short forms) as a generic term to refer to any data object in a protocol specification that satisfies the identification property stated above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
プロトコル仕様のデータオブジェクトは、特定のコンテキストで、同じタイプの他のすべてのオブジェクトからプロトコルオブジェクト（データグラム、ネットワークインターフェイス、トランスポートプロトコルエンドポイント、セッションなど）を明確に区別するために使用できます。通常、一時的な数値識別子は一連のビットとして定義され、整数値を使用して表されます。これらの識別子は通常、静的に割り当てられた数値識別子とは対照的に、動的に選択されます（例えば[IANA-Prot]を参照）。さまざまな一時的な数値識別子には、プロトコルでの特定の使用に応じて、追加の要件またはプロパティがある場合があることに注意してください。上記の識別プロパティを満たすプロトコル仕様のデータオブジェクトを参照するための一般的な用語として、「一時的な数値識別子」（または単に「数値識別子」または「識別子」）を一般的な用語として使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Failure Severity:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失敗の重大度：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
The interoperability consequences of a failure to comply with the interoperability requirements of a given identifier. Severity considers the worst potential consequence of a failure, determined by the system damage and/or time lost to repair the failure. In this document, we define two types of failure severity: &#34;soft failure&#34; and &#34;hard failure&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
特定の識別子の相互運用性要件に準拠しなかったことの相互運用性の結果。重大度は、障害の修復のために失われたシステムの損傷および/または時間によって決定される、失敗の最悪の潜在的な結果を考慮します。このドキュメントでは、2種類の障害の重大度を定義します。「ソフト障害」と「困難な障害」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Soft Failure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソフト障害：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
A recoverable condition in which a protocol does not operate in the prescribed manner but normal operation can be resumed automatically in a short period of time. For example, a simple packet-loss event that is subsequently recovered with a packet retransmission can be considered a soft failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
プロトコルが規定の方法で動作しないが、通常の操作は短期間で自動的に再開できる回復可能な条件。たとえば、パケットの再送信でその後回復される単純なパケットロスイベントは、ソフト障害と見なすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hard Failure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
困難な失敗：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
A non-recoverable condition in which a protocol does not operate in the prescribed manner or it operates with excessive degradation of service. For example, an established TCP connection that is aborted due to an error condition constitutes, from the point of view of the transport protocol, a hard failure, since it enters a state from which normal operation cannot be resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
プロトコルが規定された方法で動作しないか、サービスの過度の劣化で動作することのない非回復不可能な条件。たとえば、輸送プロトコルの観点からは、通常の操作が再開できない状態に入るため、輸送プロトコルの観点からは、エラー条件のために中止される確立されたTCP接続が構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Threat-Model">
3. Threat Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 脅威モデル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this document, we do not consider on-path attacks. That is, we assume the attacker does not have physical or logical access to the system(s) being attacked and that the attacker can only observe traffic explicitly directed to the attacker. Similarly, an attacker cannot observe traffic transferred between the sender and the receiver(s) of a target protocol but may be able to interact with any of these entities, including by, e.g., sending any traffic to them to sample transient numeric identifiers employed by the target hosts when communicating with the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント全体で、パス上の攻撃を考慮しません。つまり、攻撃者は攻撃されているシステムへの物理的または論理的なアクセスがなく、攻撃者は攻撃者に明示的に向けられたトラフィックのみを観察できると仮定します。同様に、攻撃者は、ターゲットプロトコルの送信者と受信機の間で転送されたトラフィックを観察することはできませんが、たとえば、それらにトラフィックを送信して、採用されている一時的な数値識別子をサンプリングするためにそれらに送信するなど、これらのエンティティのいずれかと対話できる場合があります。ターゲットは、攻撃者と通信するときにホストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, when analyzing vulnerabilities associated with TCP Initial Sequence Numbers (ISNs), we consider the attacker is unable to capture network traffic corresponding to a TCP connection between two other hosts. However, we consider the attacker is able to communicate with any of these hosts (e.g., establish a TCP connection with any of them) to, e.g., sample the TCP ISNs employed by these hosts when communicating with the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、TCP初期シーケンス番号（ISNS）に関連する脆弱性を分析する場合、攻撃者は他の2つのホスト間のTCP接続に対応するネットワークトラフィックをキャプチャできないと考えています。ただし、攻撃者は、攻撃者と通信するときにこれらのホストが採用しているTCP ISNをサンプリングするために、攻撃者がこれらのホストのいずれかと通信することができると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, when considering host-tracking attacks based on IPv6 Interface Identifiers, we consider an attacker may learn the IPv6 address employed by a victim host if, e.g., the address becomes exposed as a result of the victim host communicating with an attacker-operated server. Subsequently, an attacker may perform host-tracking by probing a set of target addresses composed by a set of target prefixes and the IPv6 Interface Identifier originally learned by the attacker. Alternatively, an attacker may perform host-tracking if, e.g., the victim host communicates with an attacker-operated server as it moves from one location to another, thereby exposing its configured addresses. We note that none of these scenarios require the attacker observe traffic not explicitly directed to the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、IPv6インターフェイス識別子に基づいてホスト追跡攻撃を検討する場合、攻撃者が攻撃者ホストが通信した結果として住所が公開される場合、攻撃者は被害者ホストが採用したIPv6アドレスを学習できると考えています。。その後、攻撃者は、ターゲットプレフィックスのセットとIPv6インターフェイス識別子によって構成された一連のターゲットアドレスを攻撃者が元々学習したIPv6インターフェイス識別子を調査することにより、ホストトラッキングを実行できます。あるいは、攻撃者は、たとえば、被害者のホストが、ある場所から別の場所に移動するときに攻撃者が運営するサーバーと通信し、それによって構成されたアドレスを公開する場合、ホストトラッキングを実行することができます。これらのシナリオはどれも、攻撃者が攻撃者に明示的に向けられていないトラフィックを観察する必要はないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Issues-with-the-Specification-of-Transient-Numeric-Identifiers">
4. Issues with the Specification of Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 一時的な数値識別子の仕様に関する問題
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While assessing IETF protocol specifications regarding the use of transient numeric identifiers, we have found that most of the issues discussed in this document arise as a result of one of the following conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的な数値識別子の使用に関するIETFプロトコル仕様を評価している間、このドキュメントで説明した問題のほとんどは、次の条件の1つの結果として生じることがわかりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* protocol specifications that under specify their transient numeric identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 一時的な数値識別子を規定していないプロトコル仕様
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* protocol specifications that over specify their transient numeric identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 一時的な数値識別子を過剰に指定するプロトコル仕様
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* protocol implementations that simply fail to comply with the specified requirements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 指定された要件に単純に準拠していないプロトコル実装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of IETF protocol specifications under specified their transient numeric identifiers, thus leading to implementations that were vulnerable to numerous off-path attacks. Examples of them are the specification of TCP local ports in [RFC0793] or the specification of the DNS ID in [RFC1035].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのIETFプロトコル仕様は、それらの一時的な数値識別子を指定したため、多数のオフパス攻撃に対して脆弱な実装につながりました。それらの例は、[RFC0793]のTCPローカルポートの仕様または[RFC1035]のDNS IDの仕様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: The TCP local port in an active OPEN request is commonly known as the &#34;ephemeral port&#34; of the corresponding TCP connection [RFC6056].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：アクティブなオープンリクエストのTCPローカルポートは、対応するTCP接続[RFC6056]の「はかないポート」として一般的に知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, there are a number of IETF protocol specifications that over specify some of their associated transient numeric identifiers. For example, [RFC4291] essentially overloads the semantics of IPv6 Interface Identifiers (IIDs) by embedding link-layer addresses in the IPv6 IIDs when the interoperability requirement of uniqueness could be achieved in other ways that do not result in negative security and privacy implications [RFC7721]. Similarly, [RFC2460] suggests the use of a global counter for the generation of Identification values when the interoperability requirement of uniqueness per {IPv6 Source Address, IPv6 Destination Address} could be achieved with other algorithms that do not result in negative security and privacy implications [RFC7739].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、関連する一時的な数値識別子の一部を指定するIETFプロトコル仕様が多数あります。たとえば、[RFC4291]は、IPv6 IIDにリンク層アドレスを埋め込むことにより、IPv6インターフェイス識別子（IID）のセマンティクスを本質的に過負荷にします。RFC7721]。同様に、[RFC2460]は、{IPv6ソースアドレス、IPv6宛先アドレス}ごとに一意性の相互運用性の要件が、否定的なセキュリティとプライバシーへの影響をもたらさない他のアルゴリズムで達成できる場合、識別値の生成にグローバルカウンターを使用することを示唆しています。[RFC7739]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, there are protocol implementations that simply fail to comply with existing protocol specifications. For example, some popular operating systems still fail to implement transport-protocol ephemeral port randomization, as recommended in [RFC6056], or TCP Initial Sequence Number randomization, as recommended in [RFC9293].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、既存のプロトコル仕様に単に準拠していないプロトコルの実装があります。たとえば、一部の一般的なオペレーティングシステムは、[RFC6056]で推奨されているように、[RFC9293]で推奨されるTCP初期シーケンス数ランダム化を実装していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Protocol-Failure-Severity">
5. Protocol Failure Severity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. プロトコル障害の重大度
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2 defines the concept of &#34;failure severity&#34;, along with two types of failure severities that we employ throughout this document: soft and hard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション2では、このドキュメント全体で採用する2種類の障害の重大度、ソフトアンドハードとともに、「故障の重大度」の概念を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our analysis of the severity of a failure is performed from the point of view of the protocol in question. However, the corresponding severity on the upper protocol (or application) might not be the same as that of the protocol in question. For example, a TCP connection that is aborted might or might not result in a hard failure of the upper application, i.e., if the upper application can establish a new TCP connection without any impact on the application, a hard failure at the TCP protocol may have no severity at the application layer. On the other hand, if a hard failure of a TCP connection results in excessive degradation of service at the application layer, it will also result in a hard failure at the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
障害の重症度の分析は、問題のプロトコルの観点から実行されます。ただし、上部プロトコル（またはアプリケーション）の対応する重大度は、問題のプロトコルの重大度と同じではない場合があります。たとえば、中止されたTCP接続は、アプリケーションの上部の困難な障害につながる可能性があるか、そうでない可能性があります。つまり、アプリケーションがアプリケーションに影響を与えることなく新しいTCP接続を確立できる場合、TCPプロトコルの困難な障害はアプリケーションレイヤーに重大度はありません。一方、TCP接続の困難な障害により、アプリケーション層でのサービスの過度の劣化が生じると、アプリケーションでも困難な障害が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Categorizing-Transient-Numeric-Identifiers">
6. Categorizing Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 一時的な数値識別子の分類
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section includes a non-exhaustive survey of transient numeric identifiers, which are representative of all the possible combinations of interoperability requirements and failure severities found in popular protocols of different layers. Additionally, it proposes a number of categories that can accommodate these identifiers based on their interoperability requirements and their associated failure severity (soft or hard).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、異なる層の一般的なプロトコルで見られる相互運用性要件と障害の重大度のすべての可能な組み合わせを代表する一時的な数値識別子の非網羅的な調査が含まれています。さらに、相互運用性要件と関連する障害の重大度（ソフトまたはハード）に基づいて、これらの識別子に対応できる多くのカテゴリを提案します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: All other transient numeric identifiers that were analyzed as part of this effort could be accommodated into one of the existing categories from Table 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：この取り組みの一部として分析された他のすべての一時的な数値識別子は、表1の既存のカテゴリの1つに対応できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +===============+===============================+==================+
   |   Identifier  | Interoperability Requirements | Failure Severity |
   +===============+===============================+==================+
   |    IPv6 ID    |  Uniqueness (for IPv6 address |  Soft/Hard (1)   |
   |               |             pair)             |                  |
   +---------------+-------------------------------+------------------+
   |    IPv6 IID   | Uniqueness (and stable within |     Soft (3)     |
   |               |        IPv6 prefix) (2)       |                  |
   +---------------+-------------------------------+------------------+
   |    TCP ISN    |  Monotonically increasing (4) |     Hard (4)     |
   +---------------+-------------------------------+------------------+
   |  TCP initial  |  Monotonically increasing (5) |     Hard (5)     |
   |   timestamp   |                               |                  |
   +---------------+-------------------------------+------------------+
   | TCP ephemeral |   Uniqueness (for connection  |       Hard       |
   |      port     |              ID)              |                  |
   +---------------+-------------------------------+------------------+
   |   IPv6 Flow   |           Uniqueness          |     None (6)     |
   |     Label     |                               |                  |
   +---------------+-------------------------------+------------------+
   |     DNS ID    |           Uniqueness          |     None (7)     |
   +---------------+-------------------------------+------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Table 1: Survey of Transient Numeric Identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
表1：一時的な数値識別子の調査
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(1) While a single collision of IPv6 Identification (ID) values would simply lead to a single packet drop (and hence, a &#34;soft&#34; failure), repeated collisions at high data rates might result in self-propagating collisions of IPv6 IDs, thus possibly leading to a hard failure [RFC4963].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(1) IPv6識別（ID）値の単一の衝突は、単に単一のパケットドロップ（したがって、「ソフト」障害）につながるだけですが、高いデータレートでの衝突を繰り返すと、IPv6 IDの自己伝播衝突が発生する可能性があり、したがって、おそらくリードする可能性があります。困難な障害[RFC4963]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(2) While the interoperability requirements are simply that the Interface Identifier results in a unique IPv6 address, for operational reasons, it is typically desirable that the resulting IPv6 address (and hence, the corresponding Interface Identifier) be stable within each network [RFC7217] [RFC8064].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(2) 相互運用性の要件は、単にインターフェイス識別子が一意のIPv6アドレスをもたらすということですが、運用上の理由から、結果のIPv6アドレス（したがって、対応するインターフェイス識別子）が各ネットワーク内で安定することが通常望ましい[RFC7217] [RFC8064]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(3) While IPv6 Interface Identifiers must result in unique IPv6 addresses, IPv6 Duplicate Address Detection (DAD) [RFC4862] allows for the detection of duplicate addresses, and hence, such Interface Identifier collisions can be recovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(3) IPv6インターフェイス識別子は一意のIPv6アドレスをもたらす必要がありますが、IPv6の重複アドレス検出（DAD）[RFC4862]により、複製アドレスの検出が可能になるため、そのようなインターフェイス識別子衝突を回復できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(4) In theory, there are no interoperability requirements for TCP Initial Sequence Numbers (ISNs), since the TIME-WAIT state and TCP&#39;s &#34;quiet time&#34; concept take care of old segments from previous incarnations of a connection. However, a widespread optimization allows for a new incarnation of a previous connection to be created if the ISN of the incoming SYN is larger than the last sequence number seen in that direction for the previous incarnation of the connection. Thus, monotonically increasing TCP ISNs allow for such optimization to work as expected [RFC6528] and can help avoid connection-establishment failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(4) 理論的には、TCPの初期シーケンス数（ISNS）の相互運用性要件はありません。これは、時間とTCPの「静かな時間」の概念が、以前の接続の化身から古いセグメントを処理するためです。ただし、広範囲にわたる最適化により、入ってくるSynのISNが接続の前の化身でその方向に見られる最後のシーケンス数よりも大きい場合、以前の接続の新しい化身が作成されます。したがって、単調に増加するTCP ISNにより、このような最適化が期待どおりに動作し[RFC6528]、接続確立の障害を回避するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(5) Strictly speaking, there are no interoperability requirements for the *initial* TCP timestamp employed by a TCP instance (i.e., the TS Value (TSval) in a segment with the SYN bit set). However, some TCP implementations allow a new incarnation of a previous connection to be created if the TSval of the incoming SYN is larger than the last TSval seen in that direction for the previous incarnation of the connection (please see [RFC6191]). Thus, monotonically increasing TCP initial timestamps (across connections to the same endpoint) allow for such optimization to work as expected [RFC6191] and can help avoid connection-establishment failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(5) 厳密に言えば、TCPインスタンス（つまり、SYNビットセットのセグメントにTS値（TSVAL））で採用されている *初期 * TCPタイムスタンプの相互運用性要件はありません。ただし、一部のTCP実装により、入ってくるSynのTsvalが、接続の以前の化身についてその方向に見られる最後のTsvalよりも大きい場合、以前の接続の新しい化身を作成できます（[RFC6191]を参照）。したがって、単調に増加するTCP初期タイムスタンプ（同じエンドポイントへの接続全体）により、このような最適化が期待どおりに動作し[RFC6191]、接続確立の障害を回避するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(6) The IPv6 Flow Label [RFC6437], along with the IPv6 Source Address and the IPv6 Destination Address, is typically employed for load sharing [RFC7098]. Reuse of a Flow Label value for the same set {Source Address, Destination Address} would typically cause both flows to be multiplexed onto the same link. However, as long as this does not occur deterministically, it will not result in any negative implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(6) IPv6フローラベル[RFC6437]は、IPv6ソースアドレスとIPv6宛先アドレスとともに、通常、負荷共有に使用されます[RFC7098]。同じセット{ソースアドレス、宛先アドレス}のフローラベル値の再利用により、通常、両方のフローが同じリンクに多重化されます。ただし、これが決定論的に発生しない限り、否定的な意味をもたらすことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(7) DNS IDs are employed, together with the IP Source Address, the IP Destination Address, the transport-protocol Source Port, and the transport-protocol Destination Port, to match DNS requests and responses. However, since an implementation knows which DNS requests were sent for that set of {IP Source Address, IP Destination Address, transport-protocol Source Port, transport-protocol Destination Port, DNS ID}, a collision of DNS IDs would result, if anything, in a small performance penalty (the response would nevertheless be discarded when it is found that it does not answer the query sent in the corresponding DNS query).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(7) DNS IDは、IPソースアドレス、IP宛先アドレス、Transport-Protocolソースポート、およびDNSリクエストと応答を一致させるために、Transport-Protocol Destinationポートとともに採用されています。ただし、実装が{IPソースアドレス、IP宛先アドレス、Transport-Protocol Source Port、Transport-Protocol Destination Port、DNS ID}のセットに対してどのDNS要求が送信されたかを知っているため、DNS IDの衝突が生じます。、小さなパフォーマンスペナルティで（それにもかかわらず、対応するDNSクエリで送信されたクエリに応答しないことがわかった場合、応答は破棄されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Based on the survey above, we can categorize identifiers as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の調査に基づいて、識別子を次のように分類できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +=======+======================================+====================+
   | Cat # |               Category               |   Sample Numeric   |
   |       |                                      |        IDs         |
   +=======+======================================+====================+
   |   1   |      Uniqueness (soft failure)       | IPv6 Flow L., DNS  |
   |       |                                      |         ID         |
   +-------+--------------------------------------+--------------------+
   |   2   |      Uniqueness (hard failure)       |    IPv6 ID, TCP    |
   |       |                                      |   ephemeral port   |
   +-------+--------------------------------------+--------------------+
   |   3   |  Uniqueness, stable within context   |      IPv6 IID      |
   |       |            (soft failure)            |                    |
   +-------+--------------------------------------+--------------------+
   |   4   | Uniqueness, monotonically increasing |    TCP ISN, TCP    |
   |       |    within context (hard failure)     | initial timestamp  |
   +-------+--------------------------------------+--------------------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Table 2: Identifier Categories
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
表2：識別子カテゴリ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that Category #4 could be considered a generalized case of Category #3, in which a monotonically increasing element is added to a stable (within context) element, such that the resulting identifiers are monotonically increasing within a specified context. That is, the same algorithm could be employed for both #3 and #4, given appropriate parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カテゴリ＃4は、カテゴリ＃3の一般化されたケースと見なされる可能性があることに注意してください。このケースでは、単調に増加する要素が安定した（コンテキスト内）要素に追加され、結果の識別子が指定されたコンテキスト内で単調に増加しています。つまり、適切なパラメーターを考慮して、＃3と＃4の両方に同じアルゴリズムを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Common-Algorithms-for-Transient-Numeric-Identifier-Generation">
7. Common Algorithms for Transient Numeric Identifier Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 一時的な数値識別子生成の共通アルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections describe some sample algorithms that can be employed for generating transient numeric identifiers for each of the categories above while mitigating the vulnerabilities analyzed in Section 8 of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、このドキュメントのセクション8で分析された脆弱性を緩和しながら、上記の各カテゴリの一時的な数値識別子を生成するために使用できるサンプルアルゴリズムについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the variables employed in the algorithms of the following subsections are of &#34;unsigned integer&#34; type, except for the &#34;retry&#34; variable, which is of (signed) &#34;integer&#34; type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションのアルゴリズムで採用されているすべての変数は、（署名された）「整数」タイプである「retry」変数を除き、「署名されていない整数」タイプのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Category-1-Uniqueness-Soft-Failure">
7.1. Category #1: Uniqueness (Soft Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. カテゴリ＃1：一意性（ソフト障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirement of uniqueness with a soft failure severity can be complied with a Pseudorandom Number Generator (PRNG).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソフト障害の重症度を備えた一意性の要件は、擬似ランダム数ジェネレーター（PRNG）で遵守することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: Please see [RFC4086] regarding randomness requirements for security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：セキュリティのランダム性要件については、[RFC4086]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While most systems provide access to a PRNG, many of such PRNG implementations are not cryptographically secure and therefore might be statistically biased or subject to adversarial influence. For example, ISO C [C11] rand(3) implementations are not cryptographically secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ほとんどのシステムはPRNGへのアクセスを提供しますが、このようなPRNG実装の多くは暗号化されていないため、統計的に偏っているか、敵対的な影響を受けられる可能性があります。たとえば、ISO C [C11] RAND（3）の実装は暗号化的に安全ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: Section 7.1 (&#34;Uniform Deviates&#34;) of [Press1992] discusses the underlying issues affecting ISO C [C11] rand(3) implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：[Press1992]のセクション7.1（ &#34;均一な逸脱&#34;）は、ISO C [C11] RAND（3）の実装に影響する根本的な問題について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, a number of systems provide an interface to a Cryptographically Secure PRNG (CSPRNG) [RFC4086] [RFC8937], which guarantees high entropy, unpredictability, and good statistical distribution of the random values generated. For example, GNU/ Linux&#39;s CSPRNG implementation is available via the getentropy(3) interface [GETENTROPY], while OpenBSD&#39;s CSPRNG implementation is available via the arc4random(3) and arc4random_uniform(3) interfaces [ARC4RANDOM]. Where available, these CSPRNGs should be preferred over, e.g., POSIX [POSIX] random(3) or ISO C [C11] rand(3) implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、多くのシステムは、発生したランダム値の高いエントロピー、予測不能、および良好な統計分布を保証する、暗号化されたPRNG（CSPRNG）[RFC4086] [RFC8937] [RFC4086] [RFC8937]へのインターフェイスを提供します。たとえば、GNU/ LinuxのCSPRNG実装は、GetEntropy（3）インターフェイス[GetEntropy]を介して利用できますが、OpenBSDのCSPRNG実装はArc4random（3）およびArc4random_uniform（3）インターフェイス[Arc4random]を介して利用可能です。利用可能な場合、これらのcsprngは、例えば、posix [posix]ランダム（3）またはISO C [C11] rand（3）の実装よりも優先される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In scenarios where a CSPRNG is not readily available to select transient numeric identifiers of Category #1, a security and privacy assessment of employing a regular PRNG should be performed, supporting the implementation decision.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSPRNGがカテゴリ＃1の一時的な数値識別子を選択できるシナリオでは、通常のPRNGを採用するセキュリティとプライバシー評価を実行し、実装決定をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: [Aumasson2018], [Press1992], and [Knuth1983] discuss theoretical and practical aspects of pseudorandom number generation and provide guidance on how to evaluate PRNGs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：[Aumasson2018]、[Press1992]、および[Knuth1983]は、擬似ランダム数生成の理論的および実用的な側面について議論し、PRNGを評価する方法に関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that, since the premise is that collisions of transient numeric identifiers of this category only lead to soft failures, in many cases, the algorithm might not need to check the suitability of a selected identifier (i.e., the suitable_id() function, described below, could always return &#34;true&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前提は、このカテゴリの一時的な数値識別子の衝突がソフト障害につながるだけであるため、多くの場合、アルゴリズムは選択した識別子の適合性を確認する必要がないかもしれないことに注意してください（つまり、suitable_id()関数は、説明されています。以下では、常に「真」を返すことができます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In scenarios where, e.g., simultaneous use of a given numeric identifier is undesirable and an implementation detects such condition, the implementation may opt to select the next available identifier in the same sequence or select another random number. Section 7.1.1 is an implementation of the former strategy, while Section 7.1.2 is an implementation of the latter. Typically, the algorithm in Section 7.1.2 results in a more uniform distribution of the generated transient numeric identifiers. However, for transient numeric identifiers where an implementation typically keeps local state about unsuitable/used identifiers, the algorithm in Section 7.1.2 may require many more iterations than the algorithm in Section 7.1.1 to generate a suitable transient numeric identifier. This will usually be affected by the current usage ratio of transient numeric identifiers (i.e., the number of numeric identifiers considered suitable / total number of numeric identifiers) and other parameters. Therefore, in such cases, many implementations tend to prefer the algorithm in Section 7.1.1 over the algorithm in Section 7.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、特定の数値識別子の同時使用が望ましくなく、実装がそのような条件を検出するシナリオでは、実装が同じシーケンスで次の使用可能な識別子を選択するか、別の乱数を選択することを選択する場合があります。セクション7.1.1は以前の戦略の実装であり、セクション7.1.2は後者の実装です。通常、セクション7.1.2のアルゴリズムは、生成された一時的な数値識別子のより均一な分布をもたらします。ただし、実装が通常不適切/使用識別子に関するローカル状態を維持する一時的な数値識別子の場合、セクション7.1.2のアルゴリズムは、セクション7.1.1のアルゴリズムよりも多くの反復を必要とする場合があります。これは通常、一時的な数値識別子の現在の使用率（つまり、適切な /数値識別子の総数と見なされる数値識別子の数）およびその他のパラメーターの影響を受けます。したがって、そのような場合、多くの実装は、セクション7.1.2のアルゴリズムよりもセクション7.1.1のアルゴリズムを好む傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1-1--Simple-Randomization-Algorithm">
7.1.1. Simple Randomization Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.1. 単純なランダム化アルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       next_id = min_id + (random() % id_range);
       retry = id_range;

       do {
           if (suitable_id(next_id)) {
               return next_id;
           }

           if (next_id == max_id) {
               next_id = min_id;
           } else {
               next_id++;
           }

           retry--;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 random() is a PRNG that returns a pseudorandom unsigned integer number of appropriate size. Beware that &#34;adapting&#34; the length of the output of random() with a modulo operator (e.g., C language&#39;s &#34;%&#34;) may change the distribution of the PRNG. To preserve a uniform distribution, the rejection sampling technique [Romailler2020] can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random() は、適切なサイズの擬似ランダム整数整数数を返すPRNGです。random() の出力の長さをModulo演算子（C Languageの「％」など）に「適応」すると、PRNGの分布が変更される可能性があることに注意してください。均一な分布を保持するために、拒絶サンプリング手法[Romailler2020]を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() is a function that checks, if possible and desirable, whether a candidate numeric identifier is suitable (e.g., whether it is in use or has been recently employed). Depending on how/where the numeric identifier is used, it may or may not be possible (or even desirable) to check whether the numeric identifier is suitable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
surable_id() は、候補数値識別子が適切かどうか（例えば、使用中であるか、最近採用されているか）かどうかを、可能であれば望ましいチェックと望ましい関数です。数値識別子の使用方法/場所に応じて、数値識別子が適切かどうかを確認することができる（または望ましい）可能性がある場合とそうでない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 All the variables (in this algorithm and all the others algorithms discussed in this document) are unsigned integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての変数（このアルゴリズムおよびこのドキュメントで説明されている他のすべてのアルゴリズム）は、署名されていない整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an identifier is found to be unsuitable, this algorithm selects the next available numeric identifier in sequence. Thus, even when this algorithm selects numeric identifiers randomly, it is biased towards the first available numeric identifier after a sequence of unavailable numeric identifiers. For example, if this algorithm is employed for transport-protocol ephemeral port randomization [RFC6056] and the local list of unsuitable port numbers (e.g., registered port numbers that should not be used for ephemeral ports) is significant, an attacker may actually have a significantly better chance of guessing an ephemeral port number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子が不適切であることがわかった場合、このアルゴリズムは順番に次に利用可能な数値識別子を選択します。したがって、このアルゴリズムが数値識別子をランダムに選択した場合でも、利用できない数値識別子のシーケンスの後、最初に利用可能な数値識別子にバイアスされます。たとえば、このアルゴリズムがトランスポートプロトコールの短命ポートランダム化[RFC6056]および不適切なポート番号のローカルリスト（たとえば、一時的なポートには使用すべきではない登録ポート番号など）に使用されている場合、攻撃者は実際に重要です。一時的なポート番号を推測する可能性が大幅に向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the randomness requirements for the PRNG are met (see [RFC4086]), this algorithm does not suffer from any of the issues discussed in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRNGのランダム性要件が満たされていると仮定すると（[RFC4086]を参照）、このアルゴリズムはセクション8で説明されている問題のいずれにも悩まされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1-2--Another-Simple-Randomization-Algorithm">
7.1.2. Another Simple Randomization Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1.2. 別の単純なランダム化アルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following pseudocode illustrates another algorithm for selecting a random transient numeric identifier where, in the event a selected identifier is found to be unsuitable (e.g., already in use), another identifier is randomly selected:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の擬似コードは、選択された識別子が不適切であることが判明した場合（すでに使用中）、別の識別子がランダムに選択されている場合、ランダムな一時的な数値識別子を選択するための別のアルゴリズムを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       retry = id_range;

       do {
           next_id = min_id + (random() % id_range);

           if (suitable_id(next_id)) {
               return next_id;
           }

           retry--;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 random() is a PRNG that returns a pseudorandom unsigned integer number of appropriate size. Beware that &#34;adapting&#34; the length of the output of random() with a modulo operator (e.g., C language&#39;s &#34;%&#34;) may change the distribution of the PRNG. To preserve a uniform distribution, the rejection sampling technique [Romailler2020] can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random() は、適切なサイズの擬似ランダム整数整数数を返すPRNGです。random() の出力の長さをModulo演算子（C Languageの「％」など）に「適応」すると、PRNGの分布が変更される可能性があることに注意してください。均一な分布を保持するために、拒絶サンプリング手法[Romailler2020]を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() is a function that checks, if possible and desirable, whether a candidate numeric identifier is suitable (e.g., if it is not already in use). Depending on how/where the numeric identifier is used, it may or may not be possible (or even desirable) to check whether the numeric identifier is in use (or whether it has been recently employed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
satable_id() は、候補数値識別子が適切かどうかを、可能であれば望ましい場合にチェックする関数です（たとえば、まだ使用されていない場合）。数値識別子の使用方法/場所に応じて、数値識別子が使用されているかどうか（または最近採用されているかどうか）を確認することが可能である場合とそうでない場合があります（または望ましい）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an identifier is found to be unsuitable, this algorithm selects another random numeric identifier. Thus, this algorithm might be unable to select a transient numeric identifier (i.e., return &#34;ERROR&#34;), even if there are suitable identifiers available, in cases where a large number of identifiers are found to be unsuitable (e.g., &#34;in use&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子が不適切であることがわかった場合、このアルゴリズムは別のランダム数値識別子を選択します。したがって、このアルゴリズムは、適切な識別子が利用可能であっても、多数の識別子が不適切であることが判明した場合（例：「使用中」」と認められている場合に利用可能な適切な識別子がある場合でも、一時的な数値識別子（つまり、「エラー」を返す）を選択できない場合があります。）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming the randomness requirements for the PRNG are met (see [RFC4086]), this algorithm does not suffer from any of the issues discussed in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRNGのランダム性要件が満たされていると仮定すると（[RFC4086]を参照）、このアルゴリズムはセクション8で説明されている問題のいずれにも悩まされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Category-2-Uniqueness-Hard-Failure">
7.2. Category #2: Uniqueness (Hard Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. カテゴリ＃2：ユニークさ（困難な障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the most trivial approaches for generating a unique transient numeric identifier (with a hard failure severity) is to reduce the identifier reuse frequency by generating the numeric identifiers with a monotonically increasing function (e.g., linear). As a result, any of the algorithms described in Section 7.4 (&#34;Category #4: Uniqueness, Monotonically Increasing within Context (Hard Failure)&#34;) can be readily employed for complying with the requirements of this transient numeric identifier category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意の一時的な数値識別子（硬質障害の重大度を持つ）を生成するための最も些細なアプローチの1つは、単調に増加する機能（例えば、線形）で数値識別子を生成することにより、識別子の再利用周波数を減らすことです。その結果、セクション7.4（ &#34;カテゴリ＃4：一意性、コンテキスト内で単調に増加する（困難な障害）内で単独で増加する&#34;）で説明したアルゴリズムは、この一時的な数値識別子カテゴリの要件に準拠するために容易に採用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases where suitability (e.g., uniqueness) of the selected identifiers can be definitely assessed by the local system, any of the algorithms described in Section 7.1 (&#34;Category #1: Uniqueness (Soft Failure)&#34;) can be readily employed for complying with the requirements of this numeric identifier category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
選択された識別子の適合性（例えば、単一性）をローカルシステムによって間違いなく評価できる場合、セクション7.1（「カテゴリ＃1：ユニークネス（ソフト障害）」）で説明したアルゴリズムを容易に採用することができます。この数値識別子カテゴリの要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: In the case of, e.g., TCP ephemeral ports or TCP ISNs, a transient numeric identifier that might seem suitable from the perspective of the local system might actually be unsuitable from the perspective of the remote system (e.g., because there is state associated with the selected identifier at the remote system). Therefore, in such cases, it is not possible to employ the algorithms from Section 7.1 (&#34;Category #1: Uniqueness (Soft Failure)&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：たとえば、TCP Ephemeral PortsまたはTCP ISNの場合、ローカルシステムの観点から適していると思われる一時的な数値識別子は、リモートシステムの観点からは実際には不適切ではない可能性があります（例えば、状態に関連する状態が関連するため、リモートシステムで選択された識別子を使用）。したがって、そのような場合、セクション7.1（「カテゴリ＃1：一意性（ソフト障害）」）からアルゴリズムを使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Category-3-Uniqueness-Stable-within-Context-Soft-Failure">
7.3. Category #3: Uniqueness, Stable within Context (Soft Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. カテゴリ＃3：一意性、コンテキスト内の安定（ソフト障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of the following algorithm is to produce identifiers that are stable for a given context (identified by &#34;CONTEXT&#34;) but that change when the aforementioned context changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のアルゴリズムの目標は、特定のコンテキスト（「コンテキスト」で識別される）で安定した識別子を生成することですが、前述のコンテキストが変更されると変更されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid storing the transient numeric identifiers computed for each CONTEXT in memory, the following algorithm employs a calculated technique (as opposed to keeping state in memory) to generate a stable transient numeric identifier for each given context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メモリ内の各コンテキストに対して計算された一時的な数値識別子を保存することを避けるために、次のアルゴリズムは（メモリ内に状態を維持するのではなく）計算された手法を採用して、指定された各コンテキストの安定した一時的な数値識別子を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Transient Numeric ID selection function  */

       id_range = max_id - min_id + 1;

       retry = 0;

       do {
           offset = F(CONTEXT, retry, secret_key);
           next_id = min_id + (offset % id_range);

           if (suitable_id(next_id)) {
               return next_id;
           }

           retry++;

       } while (retry &lt;= MAX_RETRIES);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 CONTEXT is the concatenation of all the elements that define a given context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストは、特定のコンテキストを定義するすべての要素の連結です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 F() is a pseudorandom function (PRF). It must not be computable from the outside (without knowledge of the secret key). F() must also be difficult to reverse, such that it resists attempts to obtain the secret key, even when given samples of the output of F() and knowledge or control of the other input parameters. F() should produce an output of at least as many bits as required for the transient numeric identifier. SipHash-2-4 (128-bit key, 64-bit output) [SipHash] and BLAKE3 (256-bit key, arbitrary-length output) [BLAKE3] are two possible options for F(). Alternatively, F() could be implemented with a keyed hash message authentication code (HMAC) [RFC2104]. HMAC-SHA-256 [FIPS-SHS] would be one possible option for such implementation alternative. Note: Use of HMAC-MD5 [RFC1321] or HMAC-SHA1 [FIPS-SHS] are not recommended for F() [RFC6151] [RFC6194]. The result of F() is no more secure than the secret key, and therefore, &#34;secret_key&#34; must be unknown to the attacker and must be of a reasonable length. &#34;secret_key&#34; must remain stable for a given CONTEXT, since otherwise, the numeric identifiers generated by this algorithm would not have the desired stability properties (i.e., stable for a given CONTEXT). In most cases, &#34;secret_key&#34; should be selected with a PRNG (see [RFC4086] for recommendations on choosing secrets) at an appropriate time and stored in stable or volatile storage (as necessary) for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F() は擬似ランダム関数（PRF）です。外部から計算可能であってはなりません（秘密の鍵の知識なし）。F() も逆になるのが難しい必要があります。そのため、F() の出力のサンプルと他の入力パラメーターの知識または制御のサンプルが与えられた場合でも、秘密の鍵を取得しようとします。F() は、一時的な数値識別子に必要な数のビットの出力を生成する必要があります。Siphash-2-4（128ビットキー、64ビット出力）[Siphash]およびBlake3（256ビットキー、任意の長さの出力）[Blake3]は、F() の2つの可能なオプションです。あるいは、F() は、キー付きハッシュメッセージ認証コード（HMAC）[RFC2104]で実装できます。HMAC-SHA-256 [FIPS-shs]は、このような実装の代替案の1つの可能なオプションです。注：HMAC-MD5 [RFC1321]またはHMAC-SHA1 [FIPS-SHS]の使用は、F() [RFC6151] [RFC6194]には推奨されません。F() の結果はシークレットキーほど安全ではないため、「Secret_Key」は攻撃者には知られていない必要があり、妥当な長さでなければなりません。「secret_key」は、特定のコンテキストでは安定したままでなければなりません。そうしないと、このアルゴリズムによって生成された数値識別子には、望ましい安定性特性がありません（つまり、特定のコンテキストでは安定します）。ほとんどの場合、適切な時間に「Secret_key」をPRNG（秘密の選択に関する推奨事項については[RFC4086]を参照）で選択し、将来の使用のために（必要に応じて）安定または揮発性の保管に保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() checks whether a candidate numeric identifier has suitable uniqueness properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
satable_id() は候補数値識別子に適切な一意性プロパティがあるかどうかをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this algorithm, the function F() provides a stateless and stable per-CONTEXT offset, where CONTEXT is the concatenation of all the elements that define the given context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムでは、関数F() は、文脈が指定されたコンテキストを定義するすべての要素の連結であるというステートレスで安定したコンテキストごとのオフセットを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if this algorithm is expected to produce IPv6 IIDs that are unique per network interface and Stateless Address Autoconfiguration (SLAAC) prefix, CONTEXT should be the concatenation of, e.g., the network interface index and the SLAAC autoconfiguration prefix (please see [RFC7217] for an implementation of this algorithm for generation of stable IPv6 addresses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、このアルゴリズムがネットワークインターフェイスごとに一意のIPv6 IIDを生成すると予想される場合、ステートレスアドレスAutoconfiguration（SLAAC）プレフィックスは、たとえば、ネットワークインターフェイスインデックスとSLAACオートコンチュレーションのプレフィックスの連結である必要があります（[RFC72177を参照してください。]安定したIPv6アドレスの生成のためのこのアルゴリズムの実装。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result of F() is stored in the variable &#34;offset&#34;, which may take any value within the storage type range, since we are restricting the resulting identifier to be in the range [min_id, max_id] in a similar way as in the algorithm described in Section 7.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F() の結果は変数「オフセット」に保存されます。これは、結果の識別子を範囲[min_id、max_id]に制限しているため、ストレージタイプの範囲内で任意の値をとることがあります。セクション7.1.1で説明されているアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted above, suitable_id() checks whether a candidate numeric identifier has suitable uniqueness properties. Collisions (i.e., an identifier that is not unique) are recovered by incrementing the &#34;retry&#34; variable and recomputing F(), up to a maximum of MAX_RETRIES times. However, recovering from collisions will usually result in identifiers that fail to remain constant for the specified context. This is normally acceptable when the probability of collisions is small, as in the case of, e.g., IPv6 IIDs resulting from SLAAC [RFC7217] [RFC8981].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のように、surtable_id() は、候補数値識別子に適切な一意性特性があるかどうかをチェックします。衝突（つまり、一意ではない識別子）は、「再試行」変数を増やし、最大MAX_RETRIES時間までに F() を再計算することにより回収されます。ただし、衝突から回復すると、通常、指定されたコンテキストで一定のままにならない識別子が生じます。これは通常、SLAAC [RFC7217] [RFC8981]に起因するIPv6 IIDなどの場合のように、衝突の確率が小さい場合に許容されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For obvious reasons, the transient numeric identifiers generated with this algorithm allow for network activity correlation and fingerprinting within &#34;CONTEXT&#34;. However, this is essentially a design goal of this category of transient numeric identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明らかな理由から、このアルゴリズムで生成された一時的な数値識別子は、「コンテキスト」内でネットワークアクティビティの相関とフィンガープリントを可能にします。ただし、これは本質的に、このカテゴリの一時的な数値識別子の設計目標です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--Category-4-Uniqueness-Monotonically-Increasing-within-ContextHard-Failure">
7.4. Category #4: Uniqueness, Monotonically Increasing within Context (Hard Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. カテゴリ＃4：一意性、コンテキスト内で単調に増加する（困難な障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4-1--Per-Context-Counter-Algorithm">
7.4.1. Per-Context Counter Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. コンテキストごとのカウンターアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible way of selecting unique monotonically increasing identifiers (per context) is to employ a per-context counter. Such an algorithm could be described as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一意の単調に増加する識別子（コンテキストごと）を選択する1つの可能な方法は、コンテキストごとのカウンターを使用することです。このようなアルゴリズムは、次のように説明できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       retry = id_range;
       id_inc = increment() % id_range;

       if( (next_id = lookup_counter(CONTEXT)) == ERROR){
            next_id = min_id + random() % id_range;
       }

       do {
           if ( (max_id - next_id) &gt;= id_inc){
               next_id = next_id + id_inc;
           }
           else {
               next_id = min_id + id_inc - (max_id - next_id);
           }

           if (suitable_id(next_id)){
               store_counter(CONTEXT, next_id);
               return next_id;
           }

           retry = retry - id_inc;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 CONTEXT is the concatenation of all the elements that define a given context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストは、特定のコンテキストを定義するすべての要素の連結です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 increment() returns a small integer that is employed to increment the current counter value to obtain the next transient numeric identifier. This value must be larger than or equal to 1, and much smaller than the number of possible values for the numeric identifiers (i.e., &#34;id_range&#34;). Most implementations of this algorithm employ a constant increment of 1. Using a value other than 1 can help mitigate some information leakages (please see below) at the expense of a possible increase in the numeric identifier reuse frequency. The code above makes sure that the increment employed in the algorithm (id_inc) is always smaller than the number of possible values for the numeric identifiers (i.e., &#34;max_id - min_d + 1&#34;). However, as noted above, this value must also be much smaller than the number of possible values for the numeric identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
increment()は、次の一時的な数値識別子を取得するために現在のカウンター値を増分するために使用される小整数を返します。この値は1以上、数値識別子の可能な値の数よりもはるかに小さい必要があります（つまり、「id_range」）。このアルゴリズムのほとんどの実装では、1以外の値を使用すると、数値識別子の再利用頻度が増加する可能性があるため、情報の漏れ（以下を参照）を軽減することができます。上記のコードは、アルゴリズム（id_inc）で採用されている増分が、数値識別子の可能な値の数よりも常に小さいことを確認します（つまり、 &#34;max_id -min_d 1&#34;）。ただし、上記のように、この値は、数値識別子の可能な値の数よりもはるかに少ない必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 lookup_counter() is a function that returns the current counter for a given context or an error condition if that counter does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lookup_counter() は、そのカウンターが存在しない場合、特定のコンテキストまたはエラー条件に対して現在のカウンターを返す関数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 random() is a PRNG that returns a pseudorandom unsigned integer number of appropriate size. Beware that &#34;adapting&#34; the length of the output of random() with a modulo operator (e.g., C language&#39;s &#34;%&#34;) may change the distribution of the PRNG. To preserve a uniform distribution, the rejection sampling technique [Romailler2020] can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random() は、適切なサイズの擬似ランダム整数整数数を返すPRNGです。random()の出力の長さをModulo演算子（C Languageの「％」など）に「適応」すると、PRNGの分布が変更される可能性があることに注意してください。均一な分布を保持するために、拒絶サンプリング手法[Romailler2020]を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 store_counter() is a function that saves a counter value for a given context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
store_counter()は、特定のコンテキストのカウンター値を保存する関数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() checks whether a candidate numeric identifier has suitable uniqueness properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
satable_id() は候補数値識別子に適切な一意性プロパティがあるかどうかをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Essentially, whenever a new identifier is to be selected, the algorithm checks whether a counter for the corresponding context exists. If it does, the value of such counter is incremented to obtain the new transient numeric identifier, and the counter is updated. If no counter exists for such context, a new counter is created and initialized to a random value and used as the selected transient numeric identifier. This algorithm produces a per-context counter, which results in one monotonically increasing function for each context. Since each counter is initialized to a random value, the resulting values are unpredictable by an off-path attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的に、新しい識別子を選択する場合はいつでも、アルゴリズムは、対応するコンテキストのカウンターが存在するかどうかをチェックします。もしそうなら、そのようなカウンターの値は、新しい一時的な数値識別子を取得するために増分され、カウンターが更新されます。そのようなコンテキストにカウンターが存在しない場合、新しいカウンターが作成され、ランダム値に初期化され、選択された一時的な数値識別子として使用されます。このアルゴリズムは、コンテキストごとのカウンターを生成し、各コンテキストで単調に増加する機能を1つ増やします。各カウンターはランダム値に初期化されるため、結果の値はオフパス攻撃者が予測不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of id_inc has implications on both the security and privacy properties of the resulting identifiers and also on the corresponding interoperability properties. On one hand, minimizing the increments generally minimizes the identifier reuse frequency, albeit at increased predictability. On the other hand, if the increments are randomized, predictability of the resulting identifiers is reduced, and the information leakage produced by global constant increments is mitigated. However, using larger increments than necessary can result in higher numeric identifier reuse frequency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID_INCの選択には、結果の識別子のセキュリティプロパティとプライバシープロパティの両方、および対応する相互運用性プロパティにも影響があります。一方では、増分を最小化すると、予測可能性が向上しているにもかかわらず、識別子の再利用頻度を最小限に抑えます。一方、増分がランダム化されている場合、結果の識別子の予測可能性が低下し、グローバルな一定の増分によって生成される情報漏れが軽減されます。ただし、必要以上に増分を使用すると、数値識別子の再利用頻度が高くなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm has the following drawbacks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムには、次の欠点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* It requires an implementation to store each per-context counter in memory. If, as a result of resource management, the counter for a given context must be removed, the last transient numeric identifier value used for that context will be lost. Thus, if an identifier subsequently needs to be generated for the same context, the corresponding counter will need to be recreated and reinitialized to a random value, thus possibly leading to reuse/ collision of numeric identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 各コンテキストごとのカウンターをメモリに保存するための実装が必要です。リソース管理の結果として、特定のコンテキストのカウンターを削除する必要がある場合、そのコンテキストで使用される最後の一時的な数値識別子値が失われます。したがって、その後、識別子を同じコンテキストで生成する必要がある場合、対応するカウンターを再現してランダムな値に再発射する必要があり、したがって、数値識別子の再利用/衝突につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Keeping one counter for each possible &#34;context&#34; may in some cases be considered too onerous in terms of memory requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 可能な「コンテキスト」ごとに1つのカウンターを維持することは、場合によっては、メモリ要件の点であまりにも面倒であると見なされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the identifiers produced by this algorithm do not suffer from the other issues discussed in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合、このアルゴリズムによって生成された識別子は、セクション8で説明されている他の問題に悩まされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4-2--Simple-PRF-Based-Algorithm">
7.4.2. Simple PRF-Based Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. 単純なPRFベースのアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of this algorithm is to produce monotonically increasing transient numeric identifiers (for each given context) with a randomized initial value. For example, if the identifiers being generated must be monotonically increasing for each {Source Address, Destination Address} set, then each possible combination of {Source Address, Destination Address} should have a separate monotonically increasing sequence that starts at a different random value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムの目標は、ランダム化された初期値で単調に増加する一時的な数値識別子（指定されたコンテキストごと）を生成することです。たとえば、生成される識別子が各{ソースアドレス、宛先アドレス}セットごとに単調に増加する必要がある場合、{ソースアドレス、宛先アドレス}の各組み合わせが、異なるランダム値で始まる個別の単調に増加するシーケンスを持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of maintaining a per-context counter (as in the algorithm from Section 7.4.1), the following algorithm employs a calculated technique to maintain a random offset for each possible context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストごとのカウンターを維持する代わりに（セクション7.4.1のアルゴリズムのように）、次のアルゴリズムは計算された手法を採用して、可能なコンテキストごとにランダムオフセットを維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Initialization code */
       counter = 0;

       /* Transient Numeric ID selection function  */

       id_range = max_id - min_id + 1;
       id_inc = increment() % id_range;
       offset = F(CONTEXT, secret_key);
       retry = id_range;

       do {
           next_id = min_id + (offset + counter) % id_range;
           counter = counter + id_inc;

           if (suitable_id(next_id)) {
               return next_id;
           }

           retry = retry - id_inc;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 CONTEXT is the concatenation of all the elements that define a given context. For example, if this algorithm is expected to produce identifiers that are monotonically increasing for each set {Source Address, Destination Address}, CONTEXT should be the concatenation of Source Address and Destination Address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテキストは、特定のコンテキストを定義するすべての要素の連結です。たとえば、このアルゴリズムが各セット{ソースアドレス、宛先アドレス}に対して単調に増加する識別子を生成すると予想される場合、コンテキストはソースアドレスと宛先アドレスの連結である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 increment() has the same properties and requirements as those specified for increment() in Section 7.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
increment() には、セクション7.4.1で increment() に指定されたプロパティと同じプロパティと要件があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 F() is a PRF, with the same properties as those specified for F() in Section 7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F() はPRFであり、セクション7.3で F() に指定されているプロパティと同じプロパティがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() checks whether a candidate numeric identifier has suitable uniqueness properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
satable_id() は候補数値識別子に適切な一意性プロパティがあるかどうかをチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the algorithm above, the function F() provides a stateless, stable, and unpredictable offset for each given context (as identified by &#34;CONTEXT&#34;). Both the &#34;offset&#34; and &#34;counter&#34; variables may take any value within the storage type range since we are restricting the resulting identifier to be in the range [min_id, max_id] in a similar way as in the algorithm described in Section 7.1.1. This allows us to simply increment the &#34;counter&#34; variable and rely on the unsigned integer to wrap around.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のアルゴリズムでは、関数F() は、指定された各コンテキスト（「コンテキスト」で識別される）に対して、ステートレス、安定、および予測不可能なオフセットを提供します。「オフセット」と「カウンター」変数の両方は、セクション7.1.1で説明されているアルゴリズムのように、結果の識別子を同様の方法で範囲内に制限するため、ストレージタイプの範囲内で任意の値を取ることができます。これにより、「カウンター」変数を単純に増やし、署名していない整数に依存してラップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The result of F() is no more secure than the secret key, and therefore, &#34;secret_key&#34; must be unknown to the attacker and must be of a reasonable length. &#34;secret_key&#34; must remain stable for a given CONTEXT, since otherwise, the numeric identifiers generated by this algorithm would not have the desired properties (i.e., monotonically increasing for a given CONTEXT). In most cases, &#34;secret_key&#34; should be selected with a PRNG (see [RFC4086] for recommendations on choosing secrets) at an appropriate time and stored in stable or volatile storage (as necessary) for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F() の結果はシークレットキーほど安全ではないため、「Secret_Key」は攻撃者には知られていない必要があり、妥当な長さでなければなりません。「secret_key」は、特定のコンテキストでは安定したままでなければなりません。そうしないと、このアルゴリズムによって生成される数値識別子には目的のプロパティがありません（つまり、特定のコンテキストで単調に増加する）。ほとんどの場合、適切な時間に「Secret_key」をPRNG（秘密の選択に関する推奨事項については[RFC4086]を参照）で選択し、将来の使用のために（必要に応じて）安定または揮発性の保管に保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that, since this algorithm uses a global counter (&#34;counter&#34;) for selecting identifiers (i.e., all counters share the same increment space), this algorithm results in an information leakage (as described in Section 8.2). For example, if this algorithm was used for selecting TCP ephemeral ports and an attacker could force a client to periodically establish a new TCP connection to an attacker-controlled system (or through an attacker-observable routing path), the attacker could subtract consecutive Source Port values to obtain the number of outgoing TCP connections established globally by the victim host within that time period (up to wrap-around issues and five-tuple collisions, of course). This information leakage could be partially mitigated by employing small random values for the increments (i.e., increment() function), instead of having increment() return the constant &#34;1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、識別子を選択するためにグローバルカウンター（「カウンター」）を使用するため（つまり、すべてのカウンターが同じ増分空間を共有する）、このアルゴリズムは情報漏れになります（セクション8.2で説明されています）。たとえば、このアルゴリズムがTCP Ephemeral Portsを選択するために使用され、攻撃者がクライアントに攻撃者制御システムへの新しいTCP接続を定期的に確立するように強制する場合（または攻撃者に夢中なルーティングパスを介して）、攻撃者は連続したソースを差し引くことができます。ポート値は、その期間内に被害者のホストによってグローバルに確立された発信TCP接続の数を取得します（もちろん、ラップアラウンドの問題と5タプルの衝突まで）。この情報の漏れは、increment() に定数「1」を返すのではなく、増分（つまり、increment() 関数）に対して小さなランダム値を使用することで部分的に軽減できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We nevertheless note that an improved mitigation of this information leakage could be more successfully achieved by employing the algorithm from Section 7.4.3, instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、この情報漏れの改善された緩和は、代わりにセクション7.4.3からアルゴリズムを採用することにより、より正常に達成できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4-3--Double-PRF-Algorithm">
7.4.3. Double-PRF Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. ダブル-PRFアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A trade-off between maintaining a single global &#34;counter&#34; variable and maintaining 2**N &#34;counter&#34; variables (where N is the width of the result of F()) could be achieved as follows. The system would keep an array of TABLE_LENGTH values, which would provide a separation of the increment space into multiple buckets. This improvement could be incorporated into the algorithm from Section 7.4.2 as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のグローバルな「カウンター」変数を維持し、2 ** n「カウンター」変数を維持することとのトレードオフ（nはF()の結果の幅）を次のように達成できます。システムは、一連のtable_length値を保持し、増分空間を複数のバケツに分離します。この改善は、次のようにセクション7.4.2からアルゴリズムに組み込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Initialization code */

       for(i = 0; i &lt; TABLE_LENGTH; i++) {
           table[i] = random();
       }

       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       id_inc = increment() % id_range;
       offset = F(CONTEXT, secret_key1);
       index = G(CONTEXT, secret_key2) % TABLE_LENGTH;
       retry = id_range;

       do {
           next_id = min_id + (offset + table[index]) % id_range;
           table[index] = table[index] + id_inc;

           if (suitable_id(next_id)) {
               return next_id;
           }

          retry = retry - id_inc;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 increment() has the same properties and requirements as those specified for increment() in Section 7.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
increment() には、セクション7.4.1で increment() に指定されたプロパティと同じプロパティと要件があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Both F() and G() are PRFs, with the same properties as those required for F() in Section 7.3. The results of F() and G() are no more secure than their respective secret keys (&#34;secret_key1&#34; and &#34;secret_key2&#34;, respectively), and therefore, both secret keys must be unknown to the attacker and must be of a reasonable length. Both secret keys must remain stable for the given CONTEXT, since otherwise, the transient numeric identifiers generated by this algorithm would not have the desired properties (i.e., monotonically increasing for a given CONTEXT). In most cases, both secret keys should be selected with a PRNG (see [RFC4086] for recommendations on choosing secrets) at an appropriate time and stored in stable or volatile storage (as necessary) for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F() と G() の両方はPRFであり、セクション7.3の F() に必要なプロパティと同じプロパティがあります。F() と G() の結果は、それぞれのシークレットキー（それぞれ &#34;Secret_key1&#34;と &#34;Secret_key2&#34;）よりも安全ではないため、両方の秘密のキーは攻撃者には不明であり、妥当な長さでなければなりません。どちらの秘密のキーも、指定されたコンテキストでは安定したままでなければなりません。そうしないと、このアルゴリズムによって生成された一時的な数値識別子には目的のプロパティがありません（つまり、特定のコンテキストでは単調に増加します）。ほとんどの場合、両方の秘密のキーは、適切な時期にPRNG（秘密の選択に関する推奨事項については[RFC4086]を参照）で選択し、将来の使用のために（必要に応じて）安定または揮発性の保管に保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 &#34;table[]&#34; could be initialized with random values, as indicated by the initialization code in the pseudocode above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「table[]」は、上記の擬似コードの初期化コードで示されるように、ランダム値で初期化できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;table[]&#34; array assures that successive transient numeric identifiers for a given context will be monotonically increasing. Since the increment space is separated into TABLE_LENGTH different spaces, the identifier reuse frequency will be (probabilistically) lower than that of the algorithm in Section 7.4.2. That is, the generation of an identifier for one given context will not necessarily result in increments in the identifier sequence of other contexts. It is interesting to note that the size of &#34;table[]&#34; does not limit the number of different identifier sequences but rather separates the *increment space* into TABLE_LENGTH different spaces. The selected transient numeric identifier sequence will be obtained by adding the corresponding entry from &#34;table[]&#34; to the value in the &#34;offset&#34; variable, which selects the actual identifier sequence space (as in the algorithm from Section 7.4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「テーブル[]」アレイは、特定のコンテキストの連続した一時的な数値識別子が単調に増加することを保証します。増分空間はtable_lengthの異なる空間に分離されるため、識別子の再利用頻度は、セクション7.4.2のアルゴリズムの識別頻度よりも（確率的に）低くなります。つまり、1つの指定されたコンテキストの識別子の生成は、必ずしも他のコンテキストの識別子シーケンスの増加をもたらすわけではありません。「テーブル[]」のサイズは、異なる識別子シーケンスの数を制限するのではなく、 *増分空間*をテーブル_Lengthの異なるスペースに分離することに注意してください。選択された一時的な数値識別子シーケンスは、「table[]」から「offset」変数の値に対応するエントリを追加することで取得されます。これは、実際の識別子シーケンス空間を選択します（セクション7.4.2のアルゴリズムのように）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker can perform traffic analysis for any &#34;increment space&#34; (i.e., context) into which the attacker has &#34;visibility&#34; -- namely, the attacker can force a system to generate identifiers for G(CONTEXT, secret_key2), where the result of G() identifies the target &#34;increment space&#34;. However, the attacker&#39;s ability to perform traffic analysis is very reduced when compared to the simple PRF-based identifiers (described in Section 7.4.2) and the predictable linear identifiers (described in Appendix A.1). Additionally, an implementation can further limit the attacker&#39;s ability to perform traffic analysis by further separating the increment space (that is, using a larger value for TABLE_LENGTH) and/or by randomizing the increments (i.e., increment() returning a small random number as opposed to the constant &#34;1&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、攻撃者が「可視性」を持っている「インクリメントスペース」（つまり、コンテキスト）のトラフィック分析を実行できます。つまり、攻撃者はシステムにG（Context、Secret_Key2）の識別子を生成するように強制できます。G() ターゲット「増分スペース」を識別します。ただし、トラフィック分析を実行する攻撃者の能力は、単純なPRFベースの識別子（セクション7.4.2で説明）および予測可能な線形識別子（付録A.1で説明）と比較すると非常に削減されます。さらに、実装は、増分空間をさらに分離することでトラフィック分析を実行する攻撃者の能力をさらに制限することができます（つまり、table_lengthに大きな値を使用）、および/または増分をランダム化することで（つまり、increment()、少量の乱数を返すようにします。定数「1」に反対）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, this algorithm does not suffer from the issues discussed in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合、このアルゴリズムはセクション8で説明した問題に悩まされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--Common-Vulnerabilities-Associated-with-Transient-Numeric-Identifiers">
8. Common Vulnerabilities Associated with Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 一時的な数値識別子に関連する一般的な脆弱性
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-1--Network-Activity-Correlation">
8.1. Network Activity Correlation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. ネットワークアクティビティの相関
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An identifier that is predictable within a given context allows for network activity correlation within that context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のコンテキスト内で予測可能な識別子は、そのコンテキスト内でネットワークアクティビティの相関を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a stable IPv6 Interface Identifier allows for network activity to be correlated within the context in which the Interface Identifier is stable [RFC7721]. A stable per-network IPv6 Interface Identifier (as in [RFC7217]) allows for network activity correlation within a network, whereas a constant IPv6 Interface Identifier (which remains constant across networks) allows not only network activity correlation within the same network but also across networks (&#34;host-tracking&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、安定したIPv6インターフェイス識別子により、インターフェイス識別子が安定しているコンテキスト内でネットワークアクティビティを相関させることができます[RFC7721]。安定したネットワークごとのIPv6インターフェイス識別子（[RFC7217]のように）はネットワーク内のネットワークアクティビティ相関を可能にしますが、一定のIPv6インターフェイス識別子（ネットワーク全体で一定のままです）は、同じネットワーク内でのネットワークアクティビティ相関を可能にしますが、ネットワーク（「ホストトラッキング」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, an implementation that generates TCP ISNs with a global counter could allow for fingerprinting and network activity correlation across networks, since an attacker could passively infer the identity of the victim based on the TCP ISNs employed for subsequent communication instances. Similarly, an implementation that generates predictable IPv6 Identification values could be subject to fingerprinting attacks (see, e.g., [Bellovin2002]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、攻撃者は後続の通信インスタンスに使用されたTCP ISNに基づいて被害者の身元を受動的に推測できるため、グローバルカウンターを使用してTCP ISNを生成する実装により、ネットワーク全体でネットワーク全体でネットワークアクティビティの相関が可能になります。同様に、予測可能なIPv6識別値を生成する実装には、フィンガープリント攻撃の対象となる可能性があります（[Bellovin2002]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-2--Information-Leakage">
8.2. Information Leakage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 情報の漏れ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transient numeric identifiers that result in specific patterns can produce an information leakage to other communicating entities. For example, it is common to generate transient numeric identifiers with an algorithm such as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のパターンをもたらす一時的な数値識別子は、他の通信エンティティへの情報漏れを生成する可能性があります。たとえば、次のようなアルゴリズムで一時的な数値識別子を生成することが一般的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              ID = offset(CONTEXT) + mono(CONTEXT);
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This generic expression generates identifiers by adding a monotonically increasing function (e.g., linear) to a randomized offset. offset() is constant within a given context, whereas mono() produces a monotonically increasing sequence for the given context. Identifiers generated with this expression will generally be predictable within CONTEXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この汎用式は、単調に増加する関数（リニア）をランダム化オフセットに追加することにより、識別子を生成します。offset() は特定のコンテキスト内で一定ですが、mono() は特定のコンテキストの単調に増加するシーケンスを生成します。この式で生成された識別子は、一般にコンテキスト内で予測可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The predictability of mono(), irrespective of the predictability of offset(), can leak information that may be of use to attackers. For example, a node that selects transport-protocol ephemeral port numbers, as in:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
offset() の予測可能性に関係なく、mono() の予測可能性は、攻撃者に使用される可能性のある情報をリークできます。たとえば、次のように、トランスポートプロトコルのはかないポート番号を選択するノード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              ephemeral_port = offset(IP_Dst_Addr) + mono()
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
that is, with a per-destination offset but a global mono() function (e.g., a global counter), will leak information about the total number of outgoing connections that have been issued by the vulnerable implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、設定ごとのオフセットがありますが、グローバル mono() 関数（グローバルカウンターなど）は、脆弱な実装によって発行された発信接続の総数に関する情報を漏らします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a node that generates IPv6 Identification values as in:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、次のようにIPv6識別値を生成するノード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              ID = offset(IP_Src_Addr, IP_Dst_Addr) + mono()
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
will leak out information about the total number of fragmented packets that have been transmitted by the vulnerable implementation. The vulnerabilities described in [Sanfilippo1998a], [Sanfilippo1998b], and [Sanfilippo1999] are all associated with the use of a global mono() function (i.e., with a global and constant &#34;CONTEXT&#34;) -- particularly when it is a linear function (constant increments of 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
脆弱な実装によって送信された断片化されたパケットの総数に関する情報が漏れます。[sanfilippo1998a]、[sanfilippo1998b]、および[sanfilippo1999]に記載されている脆弱性はすべて、グローバル mono() 関数（すなわち、グローバルおよび一定の「コンテキスト」を使用）の使用に関連しています。（1の一定の増分）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Predicting transient numeric identifiers can be of help for other types of attacks. For example, predictable TCP ISNs can open the door to trivial connection-reset and data injection attacks (see Section 8.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的な数値識別子を予測することは、他のタイプの攻撃に役立ちます。たとえば、予測可能なTCP ISNは、些細な接続レスセットおよびデータインジェクション攻撃への扉を開くことができます（セクション8.6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-3--Fingerprinting">
8.3. Fingerprinting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. フィンガープリント
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fingerprinting is the capability of an attacker to identify or reidentify a visiting user, user agent, or device via configuration settings or other observable characteristics. Observable protocol objects and characteristics can be employed to identify/reidentify various entities. These entities can range from the underlying hardware or operating system (OS) (vendor, type, and version) to the user. [EFF] illustrates web-browser-based fingerprinting, but similar techniques can be applied at other layers and protocols, whether alternatively or in conjunction with it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィンガープリントとは、攻撃者が訪問者、ユーザーエージェント、またはデバイスを構成設定またはその他の観察可能な特性を介して識別または再識別する機能です。観察可能なプロトコルオブジェクトと特性を使用して、さまざまなエンティティを識別/再識別できます。これらのエンティティは、基礎となるハードウェアまたはオペレーティングシステム（OS）（ベンダー、タイプ、およびバージョン）からユーザーまでの範囲です。[EFF]は、Webブラウザーベースのフィンガープリントを示していますが、同様の手法を他のレイヤーやプロトコルに、またはそれと併せて適用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transient numeric identifiers are one of the observable protocol components that could be leveraged for fingerprinting purposes. That is, an attacker could sample transient numeric identifiers to infer the algorithm (and its associated parameters, if any) for generating such identifiers, possibly revealing the underlying OS vendor, type, and version. This information could possibly be further leveraged in conjunction with other fingerprinting techniques and sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一時的な数値識別子は、指紋の目的で活用できる観察可能なプロトコルコンポーネントの1つです。つまり、攻撃者は一時的な数値識別子をサンプリングして、そのような識別子を生成するためにアルゴリズム（およびそれに関連するパラメーター（存在する場合）を推測し、基礎となるOSベンダー、タイプ、およびバージョンを明らかにする可能性があります。この情報は、他のフィンガープリント技術やソースと組み合わせてさらに活用される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Evasion of protocol-stack fingerprinting can prove to be a very difficult task, i.e., most systems make use of a wide variety of protocols, each of which have a large number of parameters that can be set to arbitrary values or generated with a variety of algorithms with multiple parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルスタックのフィンガープリントの回避は非常に困難なタスクであることが証明できます。つまり、ほとんどのシステムはさまざまなプロトコルを利用しています。複数のパラメーターを持つアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: General protocol-based fingerprinting is discussed in [RFC6973], along with guidelines to mitigate the associated vulnerability. [Fyodor1998] and [Fyodor2006] are classic references on OS detection via TCP/IP stack fingerprinting. Network Mapper [nmap] is probably the most popular tool for remote OS identification via active TCP/IP stack fingerprinting. p0f [Zalewski2012], on the other hand, is a tool for performing remote OS detection via passive TCP/IP stack fingerprinting. Finally, [TBIT] is a TCP fingerprinting tool that aims at characterizing the behavior of a remote TCP peer based on active probes, which has been widely used in the research community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：一般的なプロトコルベースのフィンガープリントについては、[RFC6973]で説明されており、関連する脆弱性を軽減するためのガイドラインです。[fyodor1998]および[fyodor2006]は、TCP/IPスタックフィンガープリンティングを介したOS検出に関する古典的な参照です。ネットワークマッパー[NMAP]は、おそらくアクティブなTCP/IPスタックフィンガープリントを介したリモートOS識別のための最も人気のあるツールです。一方、P0F [Zalewski2012]は、パッシブTCP/IPスタックフィンガープリントを介してリモートOS検出を実行するためのツールです。最後に、[TBIT]は、研究コミュニティで広く使用されているアクティブプローブに基づいて、リモートTCPピアの動作を特徴付けることを目的とするTCPフィンガープリントツールです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Algorithms that, from the perspective of an observer (e.g., the legitimate communicating peer), result in specific values or patterns will allow for at least some level of fingerprinting. For example, the algorithm from Section 7.3 will typically allow fingerprinting within the context where the resulting identifiers are stable. Similarly, the algorithms from Section 7.4 will result in monotonically increasing sequences within a given context, thus allowing for at least some level of fingerprinting (when the other communicating entity can correlate different sampled identifiers as belonging to the same monotonically increasing sequence).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバーの観点から（たとえば、合法的なコミュニケーションピア）、特定の値またはパターンをもたらすアルゴリズムは、少なくともある程度のフィンガープリントを可能にします。たとえば、セクション7.3のアルゴリズムは、通常、結果の識別子が安定しているコンテキスト内でフィンガープリントを許可します。同様に、セクション7.4のアルゴリズムは、特定のコンテキスト内で単調に増加するシーケンスをもたらし、したがって、少なくともある程度のフィンガープリントを可能にします（他の通信エンティティが同じ単調に増加するシーケンスに属するものとして異なるサンプリングされた識別子を相関させることができる場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, where possible, algorithms from Section 7.1 should be preferred over algorithms that result in specific values or patterns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、可能であれば、特定の値またはパターンをもたらすアルゴリズムよりも、セクション7.1のアルゴリズムを優先する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-4--Exploitation-of-the-Semantics-of-Transient-Numeric-Identifiers">
8.4. Exploitation of the Semantics of Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. 一時的な数値識別子のセマンティクスの利用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Identifiers that are not semantically opaque tend to be more predictable than semantically opaque identifiers. For example, a Media Access Control (MAC) address contains an Organizationally Unique Identifier (OUI), which may identify the vendor that manufactured the corresponding network interface card. This can be leveraged by an attacker trying to &#34;guess&#34; MAC addresses, who has some knowledge about the possible Network Interface Card (NIC) vendor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意味的に不透明ではない識別子は、意味的に不透明な識別子よりも予測可能である傾向があります。たとえば、メディアアクセスコントロール（MAC）アドレスには、対応するネットワークインターフェイスカードを製造したベンダーを識別する組織的に一意の識別子（OUI）が含まれています。これは、Macアドレスを「推測」しようとする攻撃者が活用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7707] discusses a number of techniques to reduce the search space when performing IPv6 address-scanning attacks by leveraging the semantics of IPv6 IIDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7707]は、IPv6 IIDのセマンティクスを活用することにより、IPv6アドレススカニング攻撃を実行するときに検索スペースを減らすための多くの手法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-5--Exploitation-of-Collisions-of-Transient-Numeric-Identifiers">
8.5. Exploitation of Collisions of Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. 一時的な数値識別子の衝突の活用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In many cases, the collision of transient network identifiers can have a hard failure severity (or result in a hard failure severity if an attacker can cause multiple collisions deterministically, one after another). For example, predictable IP Identification values open the door to Denial of Service (DoS) attacks (see, e.g., [RFC5722].).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの場合、一時的なネットワーク識別子の衝突は、攻撃者が複数の衝突を決定的に次々と引き起こす可能性がある場合、困難な障害の重大度を持つ可能性があります（または、困難な障害の重症度をもたらす可能性があります）。たとえば、予測可能なIP識別値は、サービス拒否（DOS）攻撃の扉を開きます（例えば[RFC5722]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-6--Exploitation-of-Predictable-Transient-Numeric-Identifiers-forInjection-Attacks">
8.6. Exploitation of Predictable Transient Numeric Identifiers for Injection Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. 注射攻撃に対する予測可能な一時的な数値識別子の活用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some protocols rely on &#34;sequence numbers&#34; for the validation of incoming packets. For example, TCP employs sequence numbers for reassembling TCP segments, while IPv4 and IPv6 employ Identification values for reassembling IPv4 and IPv6 fragments (respectively). Lacking built-in cryptographic mechanisms for validating packets, these protocols are therefore vulnerable to on-path data (see, e.g., [Joncheray1995]) and/or control-information (see, e.g., [RFC4953] and [RFC5927]) injection attacks. The extent to which these protocols may resist off-path (i.e., &#34;blind&#34;) injection attacks depends on whether the associated &#34;sequence numbers&#34; are predictable and the effort required to successfully predict a valid &#34;sequence number&#34; (see, e.g., [RFC4953] and [RFC5927]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のプロトコルは、着信パケットの検証のために「シーケンス番号」に依存しています。たとえば、TCPはTCPセグメントを再構築するためにシーケンス番号を採用し、IPv4とIPv6はIPv4およびIPv6フラグメントを再組み立てするために識別値を使用します（それぞれ）。したがって、これらのプロトコルは、パケットを検証するための内蔵の暗号化メカニズムを欠いているため、オンパスデータ（たとえば[Joncheray1995]を参照）および/または制御情報（例えば[RFC4953]および[RFC5927]を参照）に対して脆弱です。。これらのプロトコルがオフパス（つまり、「ブラインド」）噴射攻撃に抵抗する可能性のある程度は、関連する「シーケンス番号」が予測可能かどうかによって異なり、有効な「シーケンス番号」を正常に予測するために必要な努力に依存します（例えば、[参照]RFC4953]および[RFC5927]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that the use of unpredictable &#34;sequence numbers&#34; is a completely ineffective mitigation for on-path injection attacks and also a mostly ineffective mitigation for off-path (i.e., &#34;blind&#34;) injection attacks. However, many legacy protocols (such as TCP) do not incorporate cryptographic mitigations as part of the core protocol but rather as optional features (see, e.g., [RFC5925]), if available at all. Additionally, ad hoc use of cryptographic mitigations might not be sufficient to relieve a protocol implementation of generating appropriate transient numeric identifiers. For example, use of the Transport Layer Security (TLS) protocol [RFC8446] with TCP will protect the application protocol but will not help to mitigate, e.g., TCP-based connection-reset attacks (see, e.g., [RFC4953]). Similarly, use of SEcure Neighbor Discovery (SEND) [RFC3971] will still imply reliance on the successful reassembly of IPv6 fragments in those cases where SEND packets do not fit into the link Maximum Transmission Unit (MTU) (see [RFC6980]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予測不可能な「シーケンス番号」の使用は、パス上の注入攻撃のための完全に効果のない緩和であり、また、オフパス（すなわち、「ブラインド」）注射攻撃に対するほとんど効果のない緩和であることに注意してください。ただし、多くのレガシープロトコル（TCPなど）には、コアプロトコルの一部として暗号化緩和を組み込むのではなく、オプションの機能として組み込まれています（[RFC5925]を参照）。さらに、適切な一時的な数値識別子を生成するプロトコルの実装を緩和するには、暗号化緩和のアドホック使用では十分ではないかもしれません。たとえば、TCPを使用してトランスポートレイヤーセキュリティ（TLS）プロトコル[RFC8446]を使用すると、アプリケーションプロトコルが保護されますが、たとえばTCPベースの接続リセット攻撃を緩和するのに役立ちません（[RFC4953]を参照）。同様に、セキュアネイバーディスカバリー（送信）[RFC3971]の使用は、送信パケットがリンク最大透過ユニット（MTU）に収まらない場合のIPv6フラグメントの成功した再組み立てに依存することを意味します（[RFC6980を参照]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8-7--Cryptanalysis">
8.7. Cryptanalysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. 暗号化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of algorithms discussed in this document (such as those described in Sections 7.4.2 and 7.4.3) rely on PRFs. Implementations that employ weak PRFs or keys of inappropriate size can be subject to cryptanalysis, where an attacker can obtain the secret key employed for the PRF, predict numeric identifiers, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントで説明されている多くのアルゴリズム（セクション7.4.2および7.4.3で説明されているなど）は、PRFSに依存しています。不適切なサイズの弱いPRFまたはキーを使用する実装は、攻撃者がPRFに使用される秘密キーを取得したり、数値識別子を予測するなどで暗号化の対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, an implementation that overloads the semantics of the secret key can result in more trivial cryptanalysis, possibly resulting in the leakage of the value employed for the secret key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、シークレットキーのセマンティクスを過負荷にする実装は、より些細な暗号化をもたらす可能性があり、おそらくシークレットキーに採用された値の漏れをもたらす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: [IPID-DEV] describes two vulnerable transient numeric identifier generators that employ cryptographically weak hash functions. Additionally, one of such implementations employs 32 bits of a kernel address as the secret key for a hash function, and therefore, successful cryptanalysis leaks the aforementioned kernel address, allowing for Kernel Address Space Layout Randomization (KASLR) [KASLR] bypass.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：[IPID-DEV]は、暗号化的に弱いハッシュ関数を使用する2つの脆弱な一時的な数値識別子ジェネレーターを説明しています。さらに、このような実装の1つは、ハッシュ関数の秘密キーとして32ビットのカーネルアドレスを採用しているため、成功した暗号化は前述のカーネルアドレスを漏らし、カーネルアドレススペースレイアウトランダム化（KASLR）[KASLR]バイパスを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--Vulnerability-Assessment-of-Transient-Numeric-Identifiers">
9. Vulnerability Assessment of Transient Numeric Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 一時的な数値識別子の脆弱性評価
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections analyze possible vulnerabilities associated with the algorithms described in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のサブセクションは、セクション7で説明されているアルゴリズムに関連する可能性のある脆弱性を分析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Category-1-Uniqueness-Soft-Failure">
9.1. Category #1: Uniqueness (Soft Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. カテゴリ＃1：一意性（ソフト障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Possible vulnerabilities associated with the algorithms from Section 7.1 include the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1のアルゴリズムに関連する可能性のある脆弱性には、以下が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* use of flawed PRNGs (please see, e.g., [Zalewski2001], [Zalewski2002], [Klein2007], and [CVEs])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 欠陥のあるPRNGの使用（例えば、[Zalewski2001]、[Zalewski2002]、[klein2007]、および[cves]を参照））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* inadvertently affecting the distribution of an otherwise suitable PRNG (please see, e.g., [Romailler2020])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* そうでなければ適切なPRNGの分布に誤って影響を与えます（例えば[romailler2020]を参照））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where available, CSPRNGs should be preferred over regular PRNGs, such as, e.g., POSIX random(3) implementations. In scenarios where a CSPRNG is not readily available, a security and privacy assessment of employing a regular PRNG should be performed, supporting the implementation decision.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
利用可能な場合は、POSIXランダム（3）の実装など、通常のPRNGよりもCSPRNGを優先する必要があります。CSPRNGが容易に利用できないシナリオでは、通常のPRNGを採用するセキュリティとプライバシーの評価を実行し、実装決定をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: Please see [RFC4086] regarding randomness requirements for security. [Aumasson2018], [Press1992], and [Knuth1983] discuss theoretical and practical aspects of random number generation and provide guidance on how to evaluate PRNGs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：セキュリティのランダム性要件については、[RFC4086]を参照してください。[Aumasson2018]、[Press1992]、および[Knuth1983]は、乱数生成の理論的および実用的な側面について議論し、PRNGを評価する方法に関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When employing a PRNG, many implementations &#34;adapt&#34; the length of its output with a modulo operator (e.g., C language&#39;s &#34;%&#34;), possibly changing the distribution of the output of the PRNG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRNGを採用する場合、多くの実装は、Moduloオペレーター（C Languageの「％」など）で出力の長さを「適応」し、PRNGの出力の分布を変更する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider an implementation that employs the following code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、次のコードを使用する実装を検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              id = random() % 50000;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This example implementation means to obtain a transient numeric identifier in the range 0-49999. If random() produces, e.g., a pseudorandom number of 16 bits (with uniform distribution), the selected transient numeric identifier will have a nonuniform distribution with the numbers in the range 0-15535 having double frequency than the numbers in the range 15536-49999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この例の実装は、範囲0-49999で一時的な数値識別子を取得することを意味します。random() が16ビットの擬似ランダム数（均一な分布）を生成する場合、選択された一時的な数値識別子は、範囲の範囲15536の数よりも2倍の周波数を持つ範囲0-15535の数値を持つ不均一な分布を持ちます。49999。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: For example, in our sample code, both an output of 10 and output of 50010 from the random() function will result in an &#34;id&#34; value of 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：たとえば、サンプルコードでは、random() 関数からの10の出力と50010の出力の両方が10の「ID」値になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This effect is reduced if the PRNG produces an output that is much longer than the length implied by the modulo operation. We note that to preserve a uniform distribution, the rejection sampling technique [Romailler2020] can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この効果は、PRNGがModulo操作によって暗示される長さよりもはるかに長い出力を生成すると減少します。均一な分布を保持するために、拒絶サンプリング手法[Romailler2020]を使用できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of algorithms other than PRNGs for generating identifiers of this category is discouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このカテゴリの識別子を生成するためのPRNG以外のアルゴリズムの使用は落胆します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Category-2-Uniqueness-Hard-Failure">
9.2. Category #2: Uniqueness (Hard Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. カテゴリ＃2：ユニークさ（困難な障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As noted in Section 7.2, this category can employ the same algorithms as Category #4, since a monotonically increasing sequence tends to minimize the transient numeric identifier reuse frequency. Therefore, the vulnerability analysis in Section 9.4 also applies to this category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.2で述べたように、このカテゴリは、単調に増加するシーケンスが一時的な数値識別子再利用周波数を最小限に抑える傾向があるため、カテゴリ＃4と同じアルゴリズムを使用できます。したがって、セクション9.4の脆弱性分析もこのカテゴリに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, as noted in Section 7.2, some transient numeric identifiers of this category might be able to use the algorithms from Section 7.1, in which case the same considerations as in Section 9.1 would apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、セクション7.2で述べたように、このカテゴリの一時的な数値識別子は、セクション7.1のアルゴリズムを使用できる場合があります。この場合、セクション9.1と同じ考慮事項が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-3--Category-3-Uniqueness-Stable-within-Context-Soft-Failure">
9.3. Category #3: Uniqueness, Stable within Context (Soft Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. カテゴリ＃3：一意性、コンテキスト内の安定（ソフト障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Possible vulnerabilities associated with the algorithms from Section 7.3 are the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.3のアルゴリズムに関連する可能性のある脆弱性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Use of weak PRFs or inappropriate secret keys (whether inappropriate selection or inappropriate size) could allow for cryptanalysis, which could eventually be exploited by an attacker to predict future transient numeric identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 弱いPRFまたは不適切な秘密キー（不適切な選択または不適切なサイズであろうと）の使用により、攻撃者が最終的に搾取して将来の一時的な数値識別子を予測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Since the algorithm generates a unique and stable identifier within a specified context, it may allow for network activity correlation and fingerprinting within the specified context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* アルゴリズムは、指定されたコンテキスト内で一意で安定した識別子を生成するため、指定されたコンテキスト内でネットワークアクティビティの相関とフィンガープリントを可能にする場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-4--Category-4-Uniqueness-Monotonically-Increasing-within-ContextHard-Failure">
9.4. Category #4: Uniqueness, Monotonically Increasing within Context (Hard Failure)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. カテゴリ＃4：一意性、コンテキスト内で単調に増加する（困難な障害）
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm described in Section 7.4.1 for generating identifiers of Category #4 will result in an identifiable pattern (i.e., a monotonically increasing sequence) for the transient numeric identifiers generated for each CONTEXT, and thus will allow for fingerprinting and network activity correlation within each CONTEXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カテゴリ＃4の識別子を生成するためのセクション7.4.1で説明されているアルゴリズムは、各コンテキストで生成された一時的な数値識別子の識別可能なパターン（つまり、単調に増加するシーケンス）になり、したがって、したがって、したがって、したがって、したがって、フィンガープリントとネットワークアクティビティの相関が可能になります。各コンテキスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, a simple way to generalize and analyze the algorithms described in Sections 7.4.2 and 7.4.3 for generating identifiers of Category #4 is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、カテゴリ＃4の識別子を生成するためにセクション7.4.2および7.4.3で説明したアルゴリズムを一般化および分析する簡単な方法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       retry = id_range;
       id_inc = increment() % id_range;

       do {
           update_mono(CONTEXT, id_inc);
           next_id = min_id + (offset(CONTEXT) + \
                               mono(CONTEXT)) % id_range;

           if (suitable_id(next_id)) {
               return next_id;
           }

           retry = retry - id_inc;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 increment() returns a small integer that is employed to generate a monotonically increasing function. Most implementations employ a constant value for &#34;increment()&#34; (usually 1). The value returned by increment() must be much smaller than the value computed for &#34;id_range&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
increment()は、単調に増加する機能を生成するために使用される小整数を返します。ほとんどの実装は、「increment()」（通常1）の一定の値を採用しています。increment()によって返される値は、「id_range」に対して計算された値よりもはるかに小さい必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 update_mono(CONTEXT, id_inc) increments the counter corresponding to CONTEXT by &#34;id_inc&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
update_mono（context、id_inc）は、「id_inc」によってコンテキストに対応するカウンターを増分します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 mono(CONTEXT) reads the counter corresponding to CONTEXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モノ（コンテキスト）は、コンテキストに対応するカウンターを読み取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Essentially, an identifier (next_id) is generated by adding a monotonically increasing function (mono()) to an offset value, which is unknown to the attacker and stable for given context (CONTEXT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的に、識別子（next_id）は、単調に増加する関数（mono()）をオフセット値に追加することによって生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following aspects of the algorithm should be considered:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムの次の側面を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* For the most part, it is the offset() function that results in identifiers that are unpredictable by an off-patch attacker. While the resulting sequence is known to be monotonically increasing, the use of a randomized offset value makes the resulting values unknown to the attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ほとんどの場合、それは offset()関数であり、オフパッチの攻撃者が予測不可能な識別子になります。結果のシーケンスは単調に増加することが知られていますが、ランダム化されたオフセット値を使用すると、結果の値が攻撃者に不明になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The most straightforward &#34;stateless&#34; implementation of offset() is with a PRF that takes the values that identify the context and a secret key (not shown in the figure above) as arguments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* offset()の最も単純な「ステートレス」実装は、コンテキストと秘密の鍵（上の図には示されていない）を引数として識別する値を取るPRFを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* One possible implementation of mono() would be to have mono() internally employ a single counter (as in the algorithm from Section 7.4.2) or map the increments for different contexts into a number of counters/buckets, such that the number of counters that need to be maintained in memory is reduced (as in the &#34;Double-PRF Algorithm&#34; from Section 7.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mono() の可能な実装の1つは、mono() を単一のカウンター（セクション7.4.2のアルゴリズムのように）を内部的に使用するか、さまざまなコンテキストの増分を多数のカウンター/バケツにマッピングすることです。メモリ内で維持する必要があるカウンターは減少します（セクション7.4.3の「Double-PRFアルゴリズム」のように）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* In all cases, a monotonically increasing function is implemented by incrementing the previous value of a counter by increment() units. In the most trivial case, increment() could return the constant &#34;1&#34;. But increment() could also be implemented to return small random integers such that the increments are unpredictable (see Appendix A.2 of this document). This represents a trade-off between the unpredictability of the resulting transient numeric identifiers and the transient numeric identifier reuse frequency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* すべての場合において、単調に増加する関数は、increment()ユニットごとにカウンターの以前の値を増分することにより実装されます。最も些細な場合、increment()は定数「1」を返すことができます。ただし、increment()を実装して、小さなランダム整数を返して、増分が予測不可能になるようにすることもできます（このドキュメントの付録A.2を参照）。これは、結果の一時的な数値識別子の予測不可能性と一時的な数値識別子の再利用周波数のトレードオフを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the generic algorithm illustrated above, we can identify the following possible vulnerabilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の一般的なアルゴリズムを考慮すると、次の脆弱性を特定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Since the algorithms for this category are similar to those of Section 9.3, with the addition of a monotonically increasing function, all the issues discussed in Section 9.3 (&#34;Category #3: Uniqueness, Stable within Context (Soft Failure)&#34;) also apply to this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* このカテゴリのアルゴリズムはセクション9.3のアルゴリズムと類似しているため、単調に増加する機能が追加されているため、セクション9.3で説明されているすべての問題（「カテゴリ＃3：一意性、コンテキスト内の安定」）も適用されます。この場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mono() can be correlated to the number of identifiers generated for a given context (CONTEXT). Thus, if mono() spans more than the necessary context, the &#34;increments&#34; could be leaked to other parties, thus disclosing information about the number of identifiers that have been generated by the algorithm for all contexts. This information disclosure becomes more evident when an implementation employs a constant increment of 1. For example, an implementation where mono() is actually a single global counter will unnecessarily leak information about the number of identifiers that have been generated by the algorithm (globally, for all contexts). [Fyodor2003] describes one example of how such information leakages can be exploited. We note that limiting the span of the increment space will require a larger number of counters to be stored in memory (i.e., a larger value for the TABLE_LENGTH parameter of the algorithm in Section 7.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* mono() は、特定のコンテキスト（コンテキスト）に対して生成された識別子の数と相関することができます。したがって、mono()が必要なコンテキストよりも多く及ぶ場合、「増分」を他の関係者に漏らせる可能性があるため、すべてのコンテキストでアルゴリズムによって生成された識別子の数に関する情報を開示します。この情報開示は、実装が1の一定の増分を使用するとより明確になります。たとえば、mono()が実際に単一のグローバルカウンターである実装が、アルゴリズムによって生成された識別子の数に関する不必要に漏れている情報（グローバルに、すべてのコンテキストに対して）。[Fyodor2003]は、そのような情報漏れがどのように活用されるかの一例を説明しています。増分空間のスパンを制限するには、メモリにより多くのカウンターを保存する必要があることに注意してください（つまり、セクション7.4.3のアルゴリズムのtable_lengthパラメーターの値が大きくなります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Transient numeric identifiers generated with the algorithms described in Sections 7.4.2 and 7.4.3 will normally allow for fingerprinting within CONTEXT since, for such context, the resulting identifiers will have an identifiable pattern (i.e., a monotonically increasing sequence).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* セクション7.4.2および7.4.3で説明されているアルゴリズムで生成された一時的な数値識別子は、通常、コンテキスト内でフィンガープリントを可能にします。なぜなら、そのようなコンテキストでは、結果の識別子に識別可能なパターン（つまり、単調に増加するシーケンス）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="10--IANA-Considerations">
10. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. IANAの考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントにはIANAアクションがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="11--Security-Considerations">
11. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This entire document is about the security and privacy implications of transient numeric identifiers. [RFC9416] recommends that protocol specifications specify the interoperability requirements of their transient numeric identifiers, perform a vulnerability assessment of their transient numeric identifiers, and recommend an algorithm for generating each of their transient numeric identifiers. This document analyzes possible algorithms (and their implications) that could be employed to comply with the interoperability requirements of the most common categories of transient numeric identifiers while minimizing the associated negative security and privacy implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント全体は、一時的な数値識別子のセキュリティとプライバシーへの影響に関するものです。[RFC9416]は、プロトコル仕様が一時的な数値識別子の相互運用性要件を指定し、一時的な数値識別子の脆弱性評価を実行し、各一時的な数値識別子を生成するためのアルゴリズムを推奨することを推奨しています。このドキュメントは、関連する負のセキュリティとプライバシーへの影響を最小限に抑えながら、一時的な数値識別子の最も一般的なカテゴリの相互運用性要件に準拠するために使用できる可能性のあるアルゴリズム（およびその意味）を分析します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12--References">
12. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-1--Normative-References">
12.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC0791]  Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              &lt;https://www.rfc-editor.org/info/rfc791&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC0793]  Postel, J., &#34;Transmission Control Protocol&#34;, RFC 793,
              DOI 10.17487/RFC0793, September 1981,
              &lt;https://www.rfc-editor.org/info/rfc793&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC1035]  Mockapetris, P., &#34;Domain names - implementation and
              specification&#34;, STD 13, RFC 1035, DOI 10.17487/RFC1035,
              November 1987, &lt;https://www.rfc-editor.org/info/rfc1035&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC1321]  Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321,
              DOI 10.17487/RFC1321, April 1992,
              &lt;https://www.rfc-editor.org/info/rfc1321&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC2460]  Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6
              (IPv6) Specification&#34;, RFC 2460, DOI 10.17487/RFC2460,
              December 1998, &lt;https://www.rfc-editor.org/info/rfc2460&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              &lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC4291]  Hinden, R. and S. Deering, &#34;IP Version 6 Addressing
              Architecture&#34;, RFC 4291, DOI 10.17487/RFC4291, February
              2006, &lt;https://www.rfc-editor.org/info/rfc4291&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC4862]  Thomson, S., Narten, T., and T. Jinmei, &#34;IPv6 Stateless
              Address Autoconfiguration&#34;, RFC 4862,
              DOI 10.17487/RFC4862, September 2007,
              &lt;https://www.rfc-editor.org/info/rfc4862&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC5722]  Krishnan, S., &#34;Handling of Overlapping IPv6 Fragments&#34;,
              RFC 5722, DOI 10.17487/RFC5722, December 2009,
              &lt;https://www.rfc-editor.org/info/rfc5722&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &#34;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&#34;, RFC 5905, DOI 10.17487/RFC5905, June 2010,
              &lt;https://www.rfc-editor.org/info/rfc5905&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC5925]  Touch, J., Mankin, A., and R. Bonica, &#34;The TCP
              Authentication Option&#34;, RFC 5925, DOI 10.17487/RFC5925,
              June 2010, &lt;https://www.rfc-editor.org/info/rfc5925&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6056]  Larsen, M. and F. Gont, &#34;Recommendations for Transport-
              Protocol Port Randomization&#34;, BCP 156, RFC 6056,
              DOI 10.17487/RFC6056, January 2011,
              &lt;https://www.rfc-editor.org/info/rfc6056&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6151]  Turner, S. and L. Chen, &#34;Updated Security Considerations
              for the MD5 Message-Digest and the HMAC-MD5 Algorithms&#34;,
              RFC 6151, DOI 10.17487/RFC6151, March 2011,
              &lt;https://www.rfc-editor.org/info/rfc6151&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6191]  Gont, F., &#34;Reducing the TIME-WAIT State Using TCP
              Timestamps&#34;, BCP 159, RFC 6191, DOI 10.17487/RFC6191,
              April 2011, &lt;https://www.rfc-editor.org/info/rfc6191&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6437]  Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme,
              &#34;IPv6 Flow Label Specification&#34;, RFC 6437,
              DOI 10.17487/RFC6437, November 2011,
              &lt;https://www.rfc-editor.org/info/rfc6437&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6528]  Gont, F. and S. Bellovin, &#34;Defending against Sequence
              Number Attacks&#34;, RFC 6528, DOI 10.17487/RFC6528, February
              2012, &lt;https://www.rfc-editor.org/info/rfc6528&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7217]  Gont, F., &#34;A Method for Generating Semantically Opaque
              Interface Identifiers with IPv6 Stateless Address
              Autoconfiguration (SLAAC)&#34;, RFC 7217,
              DOI 10.17487/RFC7217, April 2014,
              &lt;https://www.rfc-editor.org/info/rfc7217&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7323]  Borman, D., Braden, B., Jacobson, V., and R.
              Scheffenegger, Ed., &#34;TCP Extensions for High Performance&#34;,
              RFC 7323, DOI 10.17487/RFC7323, September 2014,
              &lt;https://www.rfc-editor.org/info/rfc7323&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8064]  Gont, F., Cooper, A., Thaler, D., and W. Liu,
              &#34;Recommendation on Stable IPv6 Interface Identifiers&#34;,
              RFC 8064, DOI 10.17487/RFC8064, February 2017,
              &lt;https://www.rfc-editor.org/info/rfc8064&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8200]  Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6
              (IPv6) Specification&#34;, STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              &lt;https://www.rfc-editor.org/info/rfc8200&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8981]  Gont, F., Krishnan, S., Narten, T., and R. Draves,
              &#34;Temporary Address Extensions for Stateless Address
              Autoconfiguration in IPv6&#34;, RFC 8981,
              DOI 10.17487/RFC8981, February 2021,
              &lt;https://www.rfc-editor.org/info/rfc8981&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC9293]  Eddy, W., Ed., &#34;Transmission Control Protocol (TCP)&#34;,
              STD 7, RFC 9293, DOI 10.17487/RFC9293, August 2022,
              &lt;https://www.rfc-editor.org/info/rfc9293&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="12-2--Informative-References">
12.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 参考引用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [ARC4RANDOM]
              OpenBSD, &#34;arc4random(3)&#34;, Library Functions Manual,
              September 2019, &lt;https://man.openbsd.org/arc4random&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Aumasson2018]
              Aumasson, J-P., &#34;Serious Cryptography: A Practical
              Introduction to Modern Encryption&#34;, No Starch Press, Inc.,
              ISBN-10 1-59327-826-8, November 2017.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Bellovin1989]
              Bellovin, S., &#34;Security Problems in the TCP/IP Protocol
              Suite&#34;, Computer Communications Review, Vol. 19, No. 2,
              pp. 32-48, April 1989,
              &lt;https://www.cs.columbia.edu/~smb/papers/ipext.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Bellovin2002]
              Bellovin, S., &#34;A Technique for Counting NATted Hosts&#34;,
              IMW&#39;02, Marseille, France, ISBN 1-58113-603-X/02/0011,
              November 2002,
              &lt;https://www.cs.columbia.edu/~smb/papers/fnat.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [BLAKE3]   &#34;BLAKE3: one function, fast everywhere&#34;, September 2022,
              &lt;https://blake3.io/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [C11]      ISO/IEC, &#34;Information technology - Programming languages -
              C&#34;, ISO/IEC 9899:2018, June 2018.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [CPNI-TCP] Centre for the Protection of National Infrastructure
              (CPNI), &#34;Security Assessment of the Transmission Control
              Protocol (TCP)&#34;, CPNI Technical Note 3/2009, February
              2009, &lt;https://www.si6networks.com/files/publications/tn-
              03-09-security-assessment-TCP.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [CVEs]     NVD, &#34;Vulnerability Advisories for PRNGs&#34;,
              &lt;https://www.gont.com.ar/miscellanea/prng-cves/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [EFF]      EFF, &#34;Cover your tracks: See how trackers view your
              browser&#34;, &lt;https://coveryourtracks.eff.org/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [FIPS-SHS] NIST, &#34;Secure Hash Standard (SHS)&#34;, FIPS PUB 180-4,
              DOI 10.6028/NIST.FIPS.180-4, August 2015,
              &lt;https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.180-4.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Fyodor1998]
              Fyodor, &#34;Remote OS detection via TCP/IP Stack
              FingerPrinting&#34;, Phrack Magazine, Volume 8, Issue 54,
              December 1998,
              &lt;http://www.phrack.org/archives/issues/54/9.txt&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Fyodor2003]
              Fyodor, &#34;Idle Scanning and related IPID games&#34;, 2003,
              &lt;https://nmap.org/presentations/CanSecWest03/CD_Content/
              idlescan_paper/idlescan.html&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Fyodor2006]
              Lyon, G., &#34;Chapter 8. Remote OS Detection&#34;, January 2009,
              &lt;https://nmap.org/book/osdetect.html&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [GETENTROPY]
              Linux, &#34;getentropy(3)&#34;, Linux Programmer&#39;s Manual, March
              2021,
              &lt;https://man7.org/linux/man-pages/man3/getentropy.3.html&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [IANA-PROT]
              IANA, &#34;Protocol Registries&#34;,
              &lt;https://www.iana.org/protocols&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [IPID-DEV] Klein, A. and B. Pinkas, &#34;From IP ID to Device ID and
              KASLR Bypass (Extended Version)&#34;,
              DOI 10.48550/arXiv.1906.10478, October 2019,
              &lt;https://arxiv.org/pdf/1906.10478.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Joncheray1995]
              Joncheray, L., &#34;Simple Active Attack Against TCP&#34;,
              Proceedings of the Fifth USENIX UNIX Security Symposium,
              June 1995, &lt;https://www.usenix.org/legacy/publications/lib
              rary/proceedings/security95/full_papers/joncheray.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [KASLR]    PaX Team, &#34;Address Space Layout Randomization&#34;,
              &lt;https://pax.grsecurity.net/docs/aslr.txt&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Klein2007]
              Klein, A., &#34;OpenBSD DNS Cache Poisoning and Multiple O/S
              Predictable IP ID Vulnerability&#34;, November 2007,
              &lt;https://dl.packetstormsecurity.net/papers/attack/OpenBSD_
              DNS_Cache_Poisoning_and_Multiple_OS_Predictable_IP_ID_Vuln
              erability.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Knuth1983]
              Knuth, D., &#34;The Art of Computer Programming&#34;, Volume 2
              (Seminumerical Algorithms), 2nd Ed., Reading,
              Massachusetts, Addison-Wesley Publishing Company, January
              1981.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Morris1985]
              Morris, R., &#34;A Weakness in the 4.2BSD UNIX TCP/IP
              Software&#34;, CSTR 117, AT&amp;T Bell Laboratories, Murray Hill,
              NJ, February 1985,
              &lt;https://pdos.csail.mit.edu/~rtm/papers/117.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [nmap]     nmap, &#34;Nmap: Free Security Scanner For Network Exploration
              and Audit&#34;, 2020, &lt;https://nmap.org/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [POSIX]    IEEE, &#34;IEEE Standard for Information Technology --
              Portable Operating System Interface (POSIX(TM)) Base
              Specifications, Issue 7&#34;, IEEE Std 1003.1-2017,
              DOI 10.1109/IEEESTD.2018.8277153, January 2018,
              &lt;https://doi.org/10.1109/IEEESTD.2018.8277153&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Press1992]
              Press, W., Teukolsky, S., Vetterling, W., and B. Flannery,
              &#34;Numerical Recipes in C: The Art of Scientific Computing&#34;,
              2nd Ed., Cambridge University Press, ISBN 0-521-43108-5,
              December 1992.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-
              Hashing for Message Authentication&#34;, RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              &lt;https://www.rfc-editor.org/info/rfc2104&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC3971]  Arkko, J., Ed., Kempf, J., Zill, B., and P. Nikander,
              &#34;SEcure Neighbor Discovery (SEND)&#34;, RFC 3971,
              DOI 10.17487/RFC3971, March 2005,
              &lt;https://www.rfc-editor.org/info/rfc3971&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC4953]  Touch, J., &#34;Defending TCP Against Spoofing Attacks&#34;,
              RFC 4953, DOI 10.17487/RFC4953, July 2007,
              &lt;https://www.rfc-editor.org/info/rfc4953&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, &#34;IPv4 Reassembly
              Errors at High Data Rates&#34;, RFC 4963,
              DOI 10.17487/RFC4963, July 2007,
              &lt;https://www.rfc-editor.org/info/rfc4963&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC5927]  Gont, F., &#34;ICMP Attacks against TCP&#34;, RFC 5927,
              DOI 10.17487/RFC5927, July 2010,
              &lt;https://www.rfc-editor.org/info/rfc5927&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6194]  Polk, T., Chen, L., Turner, S., and P. Hoffman, &#34;Security
              Considerations for the SHA-0 and SHA-1 Message-Digest
              Algorithms&#34;, RFC 6194, DOI 10.17487/RFC6194, March 2011,
              &lt;https://www.rfc-editor.org/info/rfc6194&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6274]  Gont, F., &#34;Security Assessment of the Internet Protocol
              Version 4&#34;, RFC 6274, DOI 10.17487/RFC6274, July 2011,
              &lt;https://www.rfc-editor.org/info/rfc6274&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6973]  Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,
              Morris, J., Hansen, M., and R. Smith, &#34;Privacy
              Considerations for Internet Protocols&#34;, RFC 6973,
              DOI 10.17487/RFC6973, July 2013,
              &lt;https://www.rfc-editor.org/info/rfc6973&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC6980]  Gont, F., &#34;Security Implications of IPv6 Fragmentation
              with IPv6 Neighbor Discovery&#34;, RFC 6980,
              DOI 10.17487/RFC6980, August 2013,
              &lt;https://www.rfc-editor.org/info/rfc6980&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7098]  Carpenter, B., Jiang, S., and W. Tarreau, &#34;Using the IPv6
              Flow Label for Load Balancing in Server Farms&#34;, RFC 7098,
              DOI 10.17487/RFC7098, January 2014,
              &lt;https://www.rfc-editor.org/info/rfc7098&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7258]  Farrell, S. and H. Tschofenig, &#34;Pervasive Monitoring Is an
              Attack&#34;, BCP 188, RFC 7258, DOI 10.17487/RFC7258, May
              2014, &lt;https://www.rfc-editor.org/info/rfc7258&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7707]  Gont, F. and T. Chown, &#34;Network Reconnaissance in IPv6
              Networks&#34;, RFC 7707, DOI 10.17487/RFC7707, March 2016,
              &lt;https://www.rfc-editor.org/info/rfc7707&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7721]  Cooper, A., Gont, F., and D. Thaler, &#34;Security and Privacy
              Considerations for IPv6 Address Generation Mechanisms&#34;,
              RFC 7721, DOI 10.17487/RFC7721, March 2016,
              &lt;https://www.rfc-editor.org/info/rfc7721&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7739]  Gont, F., &#34;Security Implications of Predictable Fragment
              Identification Values&#34;, RFC 7739, DOI 10.17487/RFC7739,
              February 2016, &lt;https://www.rfc-editor.org/info/rfc7739&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8446]  Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol
              Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018,
              &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8937]  Cremers, C., Garratt, L., Smyshlyaev, S., Sullivan, N.,
              and C. Wood, &#34;Randomness Improvements for Security
              Protocols&#34;, RFC 8937, DOI 10.17487/RFC8937, October 2020,
              &lt;https://www.rfc-editor.org/info/rfc8937&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC9414]  Gont, F. and I. Arce, &#34;Unfortunate History of Transient
              Numeric Identifiers&#34;, RFC 9414, DOI 10.17487/RFC9414, July
              2023, &lt;https://www.rfc-editor.org/info/rfc9414&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC9416]  Gont, F. and I. Arce, &#34;Security Considerations for
              Transient Numeric Identifiers Employed in Network
              Protocols&#34;, BCP 72, RFC 9416, DOI 10.17487/RFC9416, July
              2023, &lt;https://www.rfc-editor.org/info/rfc9416&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Romailler2020]
              Romailler, Y., &#34;The Definitive Guide to &#34;Modulo Bias and
              How to Avoid It&#34;!&#34;, Kudelski Security Research, July 2020,
              &lt;https://research.kudelskisecurity.com/2020/07/28/the-
              definitive-guide-to-modulo-bias-and-how-to-avoid-it/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Sanfilippo1998a]
              Sanfilippo, S., &#34;about the ip header id&#34;, message to the
              Bugtraq mailing list, December 1998,
              &lt;http://seclists.org/bugtraq/1998/Dec/48&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Sanfilippo1998b]
              Sanfilippo, S., &#34;new tcp scan method&#34;, message to the
              Bugtraq mailing list, 18 December 1998,
              &lt;https://seclists.org/bugtraq/1998/Dec/79&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Sanfilippo1999]
              Sanfilippo, S., &#34;more ip id&#34;, message to the Bugtraq
              mailing list, November 1999,
              &lt;https://github.com/antirez/hping/raw/master/docs/MORE-
              FUN-WITH-IPID&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Schuba1993]
              Schuba, C., &#34;Addressing Weakness in the Domain Name System
              Protocol&#34;, August 1993,
              &lt;http://ftp.cerias.purdue.edu/pub/papers/christoph-schuba/
              schuba-DNS-msthesis.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Shimomura1995]
              Shimomura, T., &#34;Technical details of the attack described
              by Markoff in NYT&#34;, message to the USENET
              comp.security.misc newsgroup, 25 January 1995,
              &lt;https://www.gont.com.ar/files/post-shimomura-usenet.txt&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Silbersack2005]
              Silbersack, M., &#34;Improving TCP/IP security through
              randomization without sacrificing interoperability&#34;,
              EuroBSDCon 2005 Conference,
              &lt;https://www.silby.com/eurobsdcon05/
              eurobsdcon_silbersack.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [SipHash]  &#34;SipHash: a fast short-input PRF&#34;, February 2023,
              &lt;https://github.com/veorq/SipHash&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [TBIT]     TBIT, &#34;TBIT, the TCP Behavior Inference Tool&#34;, 2001,
              &lt;https://www.icir.org/tbit/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [TCPT-uptime]
              McDanel, B., &#34;TCP Timestamping - Obtaining System Uptime
              Remotely&#34;, message to the Bugtraq mailing list, March
              2001, &lt;https://seclists.org/bugtraq/2001/Mar/182&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Zalewski2001]
              Zalewski, M., &#34;Strange Attractors and TCP/IP Sequence
              Number Analysis&#34;, April 2001,
              &lt;https://lcamtuf.coredump.cx/oldtcp/tcpseq.html&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Zalewski2002]
              Zalewski, M., &#34;Strange Attractors and TCP/IP Sequence
              Number Analysis - One Year Later (2002)&#34;,
              &lt;https://lcamtuf.coredump.cx/newtcp/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Zalewski2012]
              Zalewski, M., &#34;p0f v3 (3.09b)&#34;,
              &lt;https://lcamtuf.coredump.cx/p0f.shtml&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Algorithms-and-Techniques-with-Known-Issues">
Appendix A. Algorithms and Techniques with Known Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. 既知の問題を伴うアルゴリズムと手法
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections discuss algorithms and techniques with known negative security and privacy implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のサブセクションでは、既知の否定的なセキュリティとプライバシーへの影響を伴うアルゴリズムと手法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
NOTE: As discussed in Section 1, the use of cryptographic techniques might allow for the safe use of some of these algorithms and techniques. However, this should be evaluated on a case-by-case basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
注：セクション1で説明したように、暗号化技術の使用により、これらのアルゴリズムと手法の一部を安全に使用できる場合があります。ただし、これはケースバイケースで評価する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-1--Predictable-Linear-Identifiers-Algorithm">
A.1. Predictable Linear Identifiers Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 予測可能な線形識別子アルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the most trivial ways to achieve uniqueness with a low identifier reuse frequency is to produce a linear sequence. This type of algorithm has been employed in the past to generate identifiers of Categories #1, #2, and #4 (please see Section 6 for an analysis of these categories).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子の再利用頻度が低いために一意性を達成する最も些細な方法の1つは、線形シーケンスを生成することです。このタイプのアルゴリズムは、カテゴリ＃1、＃2、および＃4の識別子を生成するために過去に採用されてきました（これらのカテゴリの分析については、セクション6を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the following algorithm has been employed (see, e.g., [Morris1985], [Shimomura1995], [Silbersack2005], and [CPNI-TCP]) in a number of operating systems for selecting IP IDs, TCP ephemeral port numbers, etc.:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、次のアルゴリズムが採用されています（たとえば、[Morris1985]、[Shimomura1995]、[Silbersack2005]、および[CPNI-TCP]）は、IP ID、TCP Ephemeral Port Numbersなどを選択するための多くのオペレーティングシステムで採用しています。。：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Initialization code */

       next_id = min_id;
       id_inc= 1;


       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       retry = id_range;

       do {
           if (next_id == max_id) {
               next_id = min_id;
           }
           else {
               next_id = next_id + id_inc;
           }

           if (suitable_id(next_id)) {
               return next_id;
           }

           retry--;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() checks whether a candidate numeric identifier is suitable (e.g., whether it is unique or not).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
satable_id() は候補数値識別子が適切かどうかをチェックします（例：それが一意かどうか）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For obvious reasons, this algorithm results in predictable sequences. Since a global counter is used to generate the transient numeric identifiers (&#34;next_id&#34; in the example above), an entity that learns one numeric identifier can infer past numeric identifiers and predict future values to be generated by the same algorithm. Since the value employed for the increments is known (such as &#34;1&#34; in this case), an attacker can sample two values and learn the number of identifiers that were generated in between the two sampled values. Furthermore, if the counter is initialized, to some known value (e.g., when the system is bootstrapped), the algorithm will leak additional information, such as the number of transmitted fragmented datagrams in the case of an IP ID generator [Sanfilippo1998a] or the system uptime in the case of TCP timestamps [TCPT-uptime].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明らかな理由で、このアルゴリズムは予測可能なシーケンスになります。グローバルカウンターを使用して一時的な数値識別子（上記の例で「next_id」）を生成するために使用されるため、1つの数値識別子を学習するエンティティは、過去の数値識別子を推測し、同じアルゴリズムによって生成される将来の値を予測できます。増分に使用される値（この場合は「1」など）が既知であるため、攻撃者は2つの値をサンプリングし、2つのサンプリングされた値の間に生成された識別子の数を学習できます。さらに、カウンターが初期化されている場合、ある程度の既知の値（たとえば、システムがブートストラップされている場合）に、アルゴリズムは、IP IDジェネレーター[sanfilippo1998a]または送信された断片化されたデータグラムの数などの追加情報をリークします。TCPタイムスタンプの場合のシステムアップタイム[TCPT-uptime]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-2--Random-Increments-Algorithm">
A.2. Random-Increments Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. ランダムインクレメントアルゴリズム
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm offers a middle ground between the algorithms that generate randomized transient numeric identifiers (such as those described in Sections 7.1.1 and 7.1.2) and those that generate identifiers with a predictable monotonically increasing function (see Appendix A.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、ランダム化された一過性数値識別子（セクション7.1.1および7.1.2で説明されているものなど）と、予測可能な単調に増加する機能を持つ識別子を生成するアルゴリズムとの間の中間基盤を提供します（付録A.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /* Initialization code */

       next_id = random();        /* Initialization value */
       id_rinc = 500;             /* Determines the trade-off */


       /* Transient Numeric ID selection function */

       id_range = max_id - min_id + 1;
       retry = id_range;


       do {
           /* Random increment */
           id_inc = (random() % id_rinc) + 1;

           if ( (max_id - next_id) &gt;= id_inc){
               next_id = next_id + id_inc;
           }
           else {
               next_id = min_id + id_inc - (max_id - next_id);
           }

           if (suitable_id(next_id)) {
              return next_id;
           }

           retry = retry - id_inc;

       } while (retry &gt; 0);

       return ERROR;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注記：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 random() is a PRNG that returns a pseudorandom unsigned integer number of appropriate size. Beware that &#34;adapting&#34; the length of the output of random() with a modulo operator (e.g., C language&#39;s &#34;%&#34;) may change the distribution of the PRNG. To preserve a uniform distribution, the rejection sampling technique [Romailler2020] can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random()は、適切なサイズの擬似ランダム整数整数数を返すPRNGです。random()の出力の長さをModulo演算子（C Languageの「％」など）に「適応」すると、PRNGの分布が変更される可能性があることに注意してください。均一な分布を保持するために、拒絶サンプリング手法[Romailler2020]を使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 suitable_id() is a function that checks whether a candidate identifier is suitable (e.g., whether it is unique or not).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
satable_id()は、候補識別子が適切かどうかをチェックする関数です（例：それが一意かどうか）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm aims at producing a global monotonically increasing sequence of transient numeric identifiers while avoiding the use of fixed increments, which would lead to trivially predictable sequences. The value &#34;id_rinc&#34; allows for direct control of the trade-off between unpredictability and identifier reuse frequency. The smaller the value of &#34;id_rinc&#34;, the more similar this algorithm is to a predicable, global linear identifier generation algorithm (as the one in Appendix A.1). The larger the value of &#34;id_rinc&#34;, the more similar this algorithm is to the algorithm described in Section 7.1.1 of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、固定増分の使用を回避しながら、一時的な数値識別子のグローバルな単調に増加するシーケンスを生成することを目的としています。値「id_rinc」により、予測不可能性と識別子の再利用頻度との間のトレードオフを直接制御できます。「id_rinc」の値が小さいほど、このアルゴリズムはより類似しています。「id_rinc」の値が大きいほど、このドキュメントのセクション7.1.1で説明されているアルゴリズムにこのアルゴリズムが類似しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the identifiers wrap, there is a risk of collisions of transient numeric identifiers (i.e., identifier reuse). Therefore, &#34;id_rinc&#34; should be selected according to the following criteria:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
識別子がラップすると、一時的な数値識別子（つまり、識別子の再利用）の衝突のリスクがあります。したがって、「id_rinc」は、次の基準に従って選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* It should maximize the wrapping time of the identifier space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 識別子スペースのラッピング時間を最大化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* It should minimize identifier reuse frequency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 識別子の再利用頻度を最小限に抑える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* It should maximize unpredictability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 予測不可能性を最大化する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clearly, these are competing goals, and the decision of which value of &#34;id_rinc&#34; to use is a trade-off. Therefore, the value of &#34;id_rinc&#34; is at times a configurable parameter so that system administrators can make the trade-off for themselves. We note that the alternative algorithms discussed throughout this document offer better interoperability, security, and privacy properties than this algorithm, and hence, implementation of this algorithm is discouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明らかに、これらは競合する目標であり、使用する「id_rinc」の価値の決定はトレードオフです。したがって、「id_rinc」の値は、システム管理者が自分自身のトレードオフを作成できるように、時には構成可能なパラメーターです。このドキュメント全体で説明した代替アルゴリズムは、このアルゴリズムよりも優れた相互運用性、セキュリティ、プライバシープロパティを提供するため、このアルゴリズムの実装が推奨されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="A-3--Reusing-Identifiers-Across-Different-Contexts">
A.3. Reusing Identifiers Across Different Contexts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. 異なるコンテキストにわたって識別子を再利用します
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Employing the same identifier across contexts in which stability is not required (i.e., overloading the semantics of transient numeric identifiers) usually has negative security and privacy implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定性が不要なコンテキスト間で同じ識別子を使用すると（つまり、一時的な数値識別子のセマンティクスを過負荷にする）、通常、セキュリティとプライバシーの意味合いが否定的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, in order to generate transient numeric identifiers of Category #2 or #3, an implementation or specification might be tempted to employ a source for the numeric identifiers that is known to provide unique values but that may also be predictable or leak information related to the entity generating the identifier. This technique has been employed in the past for, e.g., generating IPv6 IIDs by reusing the MAC address of the underlying network interface card. However, as noted in [RFC7721] and [RFC7707], embedding link-layer addresses in IPv6 IIDs not only results in predictable values but also leaks information about the manufacturer of the underlying network interface card, allows for network activity correlation, and makes address-based scanning attacks feasible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、カテゴリ＃2または＃3の一時的な数値識別子を生成するために、実装または仕様は、一意の値を提供することが知られているが、予測可能またはリーク情報に関連する数値識別子のソースを使用するように誘惑される場合があります。識別子を生成するエンティティに。この手法は、基礎となるネットワークインターフェイスカードのMACアドレスを再利用することにより、たとえばIPv6 IIDを生成するために、過去に採用されてきました。ただし、[RFC7721]および[RFC7707]で説明されているように、リンク層アドレスをIPv6 IIDに埋め込むと、予測可能な値になるだけでなく、基盤となるネットワーク インターフェイス カードの製造元に関する情報が漏洩し、ネットワーク アクティビティの相関関係が明らかになり、アドレスベースのスキャン攻撃が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Acknowledgements">
Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank (in alphabetical order) Bernard Aboba, Jean-Philippe Aumasson, Steven Bellovin, Luis León Cárdenas Graide, Spencer Dawkins, Theo de Raadt, Guillermo Gont, Joseph Lorenzo Hall, Gre Norcie, Colin Perkins, Vincent Roca, Shivan Sahib, Rich Salz, Martin Thomson, and Michael Tüxen for providing valuable comments on earlier draft versions of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は（アルファベット順）バーナード・アボバ、ジャン・フィリップ・オマッソン、スティーブン・ベロビン、ルイス・レオン・カルデナス・グレイデ、テオ・デ・ラード、ギレルモ・ゴント、ジョセフ・ローレンツォ・ホールShivan Sahib、Rich Salz、Martin Thomson、MichaelTüxenは、このドキュメントの以前のドラフトバージョンに関する貴重なコメントを提供してくれたことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Shivan Sahib and Christopher Wood for their guidance during the publication process of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、この文書の公開プロセス中のガイダンスについて、シヴァン・サヒブとクリストファー・ウッドに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Jean-Philippe Aumasson and Mathew D. Green (John Hopkins University) for kindly answering a number of questions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、Jean-Philippe AumassonとMathew D. Green（John Hopkins University）に、多くの質問に答えてくれたことに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Diego Armando Maradona for his magic and inspiration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者は、ディエゴ・アルマンド・マラドーナの魔法とインスピレーションに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Authors-Addresses">
Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
著者のアドレス
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Fernando Gont
   SI6 Networks
   Segurola y Habana 4310 7mo piso
   Ciudad Autonoma de Buenos Aires
   Argentina
   Email: fgont@si6networks.com
   URI:   https://www.si6networks.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Ivan Arce
   Quarkslab
   Segurola y Habana 4310 7mo piso
   Ciudad Autonoma de Buenos Aires
   Argentina
   Email: iarce@quarkslab.com
   URI:   https://www.quarkslab.com
        </pre>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
