<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 9591 - The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two‑Round Schnorr Signatures 日本語訳</title>
  <meta name="description" content="この文書は、FROST署名プロトコルを指定しています。FROST署名は、複数のエンティティが協力して署名を計算した後に発行され、秘密鍵に関する信頼と冗長性の分散が向上します。FROSTは素数次数群と暗号ハッシュ関数にのみ依存します。CFRG（Crypto Forum Research Group）によるこの文書は、異なる素数次数群とハッシュ関数を使用してFROSTを具体化するためのいくつかの暗号スイートを指定しています。">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://tex2e.github.io/rfc-translater/favicon.ico" />
  <link rel="stylesheet" href="./bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="./master.css">
  <script src="./index.js"></script>

</head>
<body>
  
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="draft/index.html">Draft</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">9591</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc9591.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div>
      <div class="alert alert-info" role="alert">
        <h4 class="alert-heading">RFC 9591 - The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two‑Round Schnorr Signatures 日本語訳</h4>
        <span class="URL">原文URL :
          <a href="https://www.rfc-editor.org/rfc/rfc9591.html">
            https://www.rfc-editor.org/rfc/rfc9591.html
          </a>
        </span><br>
        <span class="title_ja">
          タイトル : <strong>RFC 9591 - 2 ラウンド Schnorr 署名用の柔軟な Round-Optimized Schnorr Threshold (FROST) プロトコル</strong></span><br>
        <span class="updated_by">翻訳編集 : 自動生成</span><span id="rfc_status"></span><span id="rfc_wg"></span><br>
      </div>
      <div id="rfc_alert" class="hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div id="rfc_summary">
      <div class="card mb-3">
        <div class="card-body">
          <p class="card-text">[要約] この文書は、FROST署名プロトコルを指定しています。FROST署名は、複数のエンティティが協力して署名を計算した後に発行され、秘密鍵に関する信頼と冗長性の分散が向上します。FROSTは素数次数群と暗号ハッシュ関数にのみ依存します。CFRG（Crypto Forum Research Group）によるこの文書は、異なる素数次数群とハッシュ関数を使用してFROSTを具体化するためのいくつかの暗号スイートを指定しています。</p>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Research Task Force (IRTF)                          D. Connolly
Request for Comments: 9591                              Zcash Foundation
Category: Informational                                         C. Komlo
ISSN: 2070-1721                 University of Waterloo, Zcash Foundation
                                                             I. Goldberg
                                                  University of Waterloo
                                                              C. A. Wood
                                                              Cloudflare
                                                               June 2024
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="The-Flexible-Round-Optimized-Schnorr-Threshold-FROST-Protocol-for-Two-Round-Schnorr-Signatures">
The Flexible Round-Optimized Schnorr Threshold (FROST) Protocol for Two-Round Schnorr Signatures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2 ラウンド Schnorr 署名用の柔軟な Round-Optimized Schnorr Threshold (FROST) プロトコル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Abstract">
Abstract
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
概要
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol. FROST signatures can be issued after a threshold number of entities cooperate to compute a signature, allowing for improved distribution of trust and redundancy with respect to a secret key. FROST depends only on a prime-order group and cryptographic hash function. This document specifies a number of ciphersuites to instantiate FROST using different prime-order groups and hash functions. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、Flexible Round-Optimized Schnorr Threshold (FROST) 署名プロトコルを指定します。FROST 署名は、しきい値数のエンティティが協力して署名を計算した後に発行できるため、秘密キーに関する信頼性と冗長性の分散が改善されます。FROST は、素数順序群と暗号化ハッシュ関数のみに依存します。この文書では、さまざまな素数グループとハッシュ関数を使用して FROST をインスタンス化するためのいくつかの暗号スイートを指定します。この文書は、IRTF の暗号フォーラム研究グループ (CFRG) の成果物です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Status-of-This-Memo">
Status of This Memo
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
本文書の位置付け
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は Internet Standards Track 仕様ではありません。情報提供を目的として公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は Internet Research Task Force (IRTF) の成果物です。IRTF は、インターネット関連の研究開発活動の結果を公開しています。これらの結果は、展開には適していない可能性があります。この RFC は、インターネット研究タスクフォース (IRTF) の暗号フォーラム研究グループの合意を表しています。IRSG によって公開が承認された文書は、どのレベルのインターネット標準の候補でもありません。RFC 7841 のセクション 2 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9591.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書の現在のステータス、正誤表、およびそれに対するフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc9591 で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Copyright-Notice">
Copyright Notice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
著作権表示
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2024 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2024 IETF Trust および文書の著者として特定された人物。無断転載を禁じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78 およびこの文書の発行日に有効な IETF 文書に関する IETF トラストの法的規定 (https://trustee.ietf.org/license-info) の対象となります。これらの文書には、この文書に関するお客様の権利と制限が記載されているため、注意深くお読みください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Table-of-Contents">
Table of Contents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
目次
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace toc">
   1.  Introduction
   2.  Conventions and Definitions
   3.  Cryptographic Dependencies
     3.1.  Prime-Order Group
     3.2.  Cryptographic Hash Function
   4.  Helper Functions
     4.1.  Nonce Generation
     4.2.  Polynomials
     4.3.  List Operations
     4.4.  Binding Factors Computation
     4.5.  Group Commitment Computation
     4.6.  Signature Challenge Computation
   5.  Two-Round FROST Signing Protocol
     5.1.  Round One - Commitment
     5.2.  Round Two - Signature Share Generation
     5.3.  Signature Share Aggregation
     5.4.  Identifiable Abort
   6.  Ciphersuites
     6.1.  FROST(Ed25519, SHA-512)
     6.2.  FROST(ristretto255, SHA-512)
     6.3.  FROST(Ed448, SHAKE256)
     6.4.  FROST(P-256, SHA-256)
     6.5.  FROST(secp256k1, SHA-256)
     6.6.  Ciphersuite Requirements
   7.  Security Considerations
     7.1.  Side-Channel Mitigations
     7.2.  Optimizations
     7.3.  Nonce Reuse Attacks
     7.4.  Protocol Failures
     7.5.  Removing the Coordinator Role
     7.6.  Input Message Hashing
     7.7.  Input Message Validation
   8.  IANA Considerations
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Schnorr Signature Encoding
   Appendix B.  Schnorr Signature Generation and Verification for
           Prime-Order Groups
   Appendix C.  Trusted Dealer Key Generation
     C.1.  Shamir Secret Sharing
       C.1.1.  Additional Polynomial Operations
     C.2.  Verifiable Secret Sharing
   Appendix D.  Random Scalar Generation
     D.1.  Rejection Sampling
     D.2.  Wide Reduction
   Appendix E.  Test Vectors
     E.1.  FROST(Ed25519, SHA-512)
     E.2.  FROST(Ed448, SHAKE256)
     E.3.  FROST(ristretto255, SHA-512)
     E.4.  FROST(P-256, SHA-256)
     E.5.  FROST(secp256k1, SHA-256)
   Acknowledgments
   Authors&#39; Addresses
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="1--Introduction">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike signatures in a single-party setting, threshold signatures require cooperation among a threshold number of signing participants, each holding a share of a common private key. The security of threshold schemes in general assumes that an adversary can corrupt strictly fewer than a threshold number of signer participants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一当事者設定での署名とは異なり、しきい値署名では、共通の秘密鍵の共有を保持するしきい値数の署名参加者間の協力が必要です。しきい値スキームのセキュリティは、一般に、敵対者が不正にアクセスできる署名者参加者の数がしきい値よりも厳密に少ないことを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies the Flexible Round-Optimized Schnorr Threshold (FROST) signing protocol based on the original work in [FROST20]. FROST reduces network overhead during threshold signing operations while employing a novel technique to protect against forgery attacks applicable to prior Schnorr-based threshold signature constructions. FROST requires two rounds to compute a signature. Single-round signing variants based on [FROST20] are out of scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、[FROST20] のオリジナルの作業に基づいた Flexible Round-Optimized Schnorr Threshold (FROST) 署名プロトコルを指定します。FROST は、以前の Schnorr ベースのしきい値署名構造に適用できる偽造攻撃から保護する新しい技術を採用しながら、しきい値署名操作中のネットワーク オーバーヘッドを削減します。FROST では、署名の計算に 2 ラウンドが必要です。[FROST20] に基づくシングルラウンド署名のバリアントは範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST depends only on a prime-order group and cryptographic hash function. This document specifies a number of ciphersuites to instantiate FROST using different prime-order groups and hash functions. Two ciphersuites can be used to produce signatures that are compatible with Edwards-Curve Digital Signature Algorithm (EdDSA) variants Ed25519 and Ed448 as specified in [RFC8032], i.e., the signatures can be verified with a verifier that is compliant with [RFC8032]. However, unlike EdDSA, the signatures produced by FROST are not deterministic, since deriving nonces deterministically allows for a complete key-recovery attack in multi-party, discrete logarithm-based signatures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、素数順序群と暗号化ハッシュ関数のみに依存します。この文書では、さまざまな素数順序グループとハッシュ関数を使用して FROST をインスタンス化するためのいくつかの暗号スイートを指定します。2 つの暗号スイートを使用して、[RFC8032] で指定されている Edwards-Curve Digital Signature Algorithm (EdDSA) バリアント Ed25519 および Ed448 と互換性のある署名を生成できます。つまり、署名は [RFC8032] に準拠した検証器で検証できます。ただし、EdDSA とは異なり、FROST によって生成される署名は決定論的ではありません。ノンスを決定論的に導出することにより、マルチパーティの離散対数ベースの署名での完全なキー回復攻撃が可能になるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key generation for FROST signing is out of scope for this document. However, for completeness, key generation with a trusted dealer is specified in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST 署名のための鍵の生成は、このドキュメントの範囲外です。ただし、完全を期すため、信頼できるディーラーによる鍵の生成については付録 C に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document represents the consensus of the Crypto Forum Research Group (CFRG). It is not an IETF product and is not a standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、Crypto Forum Research Group (CFRG) の総意を表しています。これは IETF 製品ではなく、標準でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="2--Conventions-and-Definitions">
2. Conventions and Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 規則と定義
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメント内のキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」は、ここに示すようにすべて大文字で表示されている場合にのみ、BCP 14 [RFC2119] [RFC8174] で説明されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following notation is used throughout the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書全体で次の表記が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
byte:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイト：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
A sequence of eight bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
8 ビットのシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random_bytes(n):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダムバイト(n):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs n bytes, sampled uniformly at random using a cryptographically secure pseudorandom number generator (CSPRNG).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
暗号的に安全な擬似乱数生成器 (CSPRNG) を使用して、均一にランダムにサンプリングされた n バイトを出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
count(i, L):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カウント(i, L):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the number of times the element i is represented in the list L.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
要素 i がリスト L 内で表現される回数を出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
len(l):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レン(l):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the length of list l, e.g., len([1,2,3]) = 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
リスト l の長さを出力します (例: len([1,2,3]) = 3)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reverse(l):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆(l):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the list l in reverse order, e.g., reverse([1,2,3]) = [3,2,1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
リスト l を逆順で出力します (例: reverse([1,2,3]) = [3,2,1])。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
range(a, b):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲(a, b):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs a list of integers from a to b-1 in ascending order, e.g., range(1, 4) = [1,2,3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
a から b-1 までの整数のリストを昇順で出力します (例: range(1, 4) = [1,2,3])。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pow(a, b):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pow(a, b):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the result, a Scalar, of a to the power of b, e.g., pow(2, 3) = 8 modulo the relevant group order p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
a の b 乗の結果、スカラーを出力します。たとえば、関連するグループ次数 p を法とする pow(2, 3) = 8 です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
||:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
||:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Denotes concatenation of byte strings, i.e., x || y denotes the byte string x, immediately followed by the byte string y, with no extra separator, yielding xy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
バイト文字列の連結を示します。つまり、x ||y はバイト文字列 x を表し、その直後に余分な区切り文字なしでバイト文字列 y が続き、xy が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nil:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nil:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Denotes an empty byte string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
空のバイト列を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless otherwise stated, we assume that secrets are sampled uniformly at random using a CSPRNG; see [RFC4086] for additional guidance on the generation of random numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に明記されていない限り、シークレットは CSPRNG を使用して均一にランダムにサンプリングされると想定します。乱数の生成に関する追加のガイダンスについては、[RFC4086] を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3--Cryptographic-Dependencies">
3. Cryptographic Dependencies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 暗号化の依存関係
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST signing depends on the following cryptographic constructs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST 署名は、次の暗号構造に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Prime-order group (Section 3.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 素数グループ (セクション 3.1)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Cryptographic hash function (Section 3.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 暗号化ハッシュ関数 (セクション 3.2)
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe these constructs in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、これらの構造について詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-1--Prime-Order-Group">
3.1. Prime-Order Group
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. プライムオーダーグループ
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST depends on an abelian group of prime order p. We represent this group as the object G that additionally defines helper functions described below. The group operation for G is addition + with identity element I. For any elements A and B of the group G, A + B = B + A is also a member of G. Also, for any A in G, there exists an element -A such that A + (-A) = (-A) + A = I. For convenience, we use - to denote subtraction, e.g., A - B = A + (-B). Integers, taken modulo the group order p, are called &#34;Scalars&#34;; arithmetic operations on Scalars are implicitly performed modulo p. Since p is prime, Scalars form a finite field. Scalar multiplication is equivalent to the repeated application of the group operation on an element A with itself r-1 times, denoted as ScalarMult(A, r). We denote the sum, difference, and product of two Scalars using the +, -, and * operators, respectively. (Note that this means + may refer to group element addition or Scalar addition, depending on the type of the operands.) For any element A, ScalarMult(A, p) = I. We denote B as a fixed generator of the group. Scalar base multiplication is equivalent to the repeated application of the group operation on B with itself r-1 times, denoted as ScalarBaseMult(r). The set of Scalars corresponds to GF(p), which we refer to as the Scalar field. It is assumed that group element addition, negation, and equality comparison can be efficiently computed for arbitrary group elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は素数次数 p のアーベル群に依存します。このグループを、以下で説明するヘルパー関数を追加定義するオブジェクト G として表します。G の群演算は、恒等要素 I を伴う加算 + です。群 G の要素 A および B については、A + B = B + A も G のメンバーです。また、G 内の任意の A については、A + (-A) = (-A) + A = I となる要素 -A が存在します。便宜上、減算を示すために - を使用します (例: A - B = A + (-B))。群次数 p を法として取得される整数は、「スカラー」と呼ばれます。スカラーの算術演算は、p を法として暗黙的に実行されます。p は素数であるため、スカラーは有限体を形成します。スカラー乗算は、ScalarMult(A, r) として示される、要素 A に対するグループ演算をそれ自体を r-1 回繰り返し適用することと等価です。2 つのスカラーの和、差、積をそれぞれ +、-、および * 演算子を使用して表します。(これは、オペランドのタイプに応じて、+ がグループ要素の加算またはスカラー加算を参照する可能性があることを意味します。) 任意の要素 A について、ScalarMult(A, p) = I。B をグループの固定ジェネレータとして示します。スカラー基底乗算は、ScalarBaseMult(r) として示される、B に対するグループ演算をそれ自体で r-1 回繰り返し適用することと等価です。スカラーのセットは GF(p) に対応し、これをスカラー フィールドと呼びます。グループ要素の加算、否定、等価比較は、任意のグループ要素に対して効率的に計算できると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses types Element and Scalar to denote elements of the group G and its set of Scalars, respectively. We denote Scalar(x) as the conversion of integer input x to the corresponding Scalar value with the same numeric value. For example, Scalar(1) yields a Scalar representing the value 1. Moreover, we use the type NonZeroScalar to denote a Scalar value that is not equal to zero, i.e., Scalar(0). We denote equality comparison of these types as == and assignment of values by =. When comparing Scalar values, e.g., for the purposes of sorting lists of Scalar values, the least nonnegative representation mod p is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、Element 型と Scalar 型を使用して、グループ G の要素とそのスカラーのセットをそれぞれ示します。Scalar(x) は、整数入力 x を、同じ数値を持つ対応するスカラー値に変換することとして表します。たとえば、Scalar(1) は値 1 を表す Scalar を生成します。さらに、NonZeroScalar 型を使用して、ゼロに等しくない Scalar 値、つまり Scalar(0) を示します。これらのタイプの等価比較を == で表し、値の割り当てを = で表します。スカラー値を比較する場合、たとえばスカラー値のリストをソートする目的で、最小の非負表現 mod p が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now detail a number of member functions that can be invoked on G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、G で呼び出すことができる多数のメンバー関数について詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Order():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注文（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the order of G (i.e., p).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
G (つまり p) の次数を出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Identity():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
身元（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the identity Element of the group (i.e., I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
グループのアイデンティティ要素 (つまり、I) を出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RandomScalar():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RandomScalar():
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs a random Scalar element in GF(p), i.e., a random Scalar in [0, p - 1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
GF(p) のランダムなスカラー要素、つまり [0, p - 1] のランダムなスカラー要素を出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ScalarMult(A, k):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ScalarMult(A, k):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the Scalar multiplication between Element A and Scalar k.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
要素 A とスカラー k の間のスカラー乗算を出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ScalarBaseMult(k):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ScalarBaseMult(k):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Outputs the Scalar multiplication between Scalar k and the group generator B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
スカラー k とグループ ジェネレーター B の間のスカラー乗算を出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SerializeElement(A):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SerializeElement(A):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Maps an Element A to a canonical byte array buf of fixed length Ne. This function raises an error if A is the identity element of the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
要素 A を固定長 Ne の正規バイト配列 buf にマップします。A がグループの単位要素である場合、この関数はエラーを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DeserializeElement(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要素の逆シリアル化 (バグ):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Attempts to map a byte array buf to an Element A and fails if the input is not the valid canonical byte representation of an element of the group. This function raises an error if deserialization fails or if A is the identity element of the group; see Section 6 for group-specific input validation steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
バイト配列 buf を要素 A にマップしようとしますが、入力がグループの要素の有効な正規バイト表現でない場合は失敗します。逆シリアル化が失敗した場合、または A がグループの ID 要素である場合、この関数はエラーを生成します。グループ固有の入力検証手順については、セクション 6 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SerializeScalar(s):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SerializeScalar:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Maps a Scalar s to a canonical byte array buf of fixed length Ns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Scalar s を固定長 Ns の標準バイト配列 buf にマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DeserializeScalar(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DeserializeScalar(buf):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Attempts to map a byte array buf to a Scalar s. This function raises an error if deserialization fails; see Section 6 for group-specific input validation steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
バイト配列 buf を Scalar にマップしようとします。逆シリアル化が失敗した場合、この関数はエラーを生成します。グループ固有の入力検証手順については、セクション 6 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="3-2--Cryptographic-Hash-Function">
3.2. Cryptographic Hash Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 暗号化ハッシュ関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST requires the use of a cryptographically secure hash function, generically written as H, which is modeled as a random oracle in security proofs for the protocol (see [FROST20] and [StrongerSec22]). For concrete recommendations on hash functions that SHOULD be used in practice, see Section 6. Using H, we introduce distinct domain-separated hashes H1, H2, H3, H4, and H5:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、暗号的に安全なハッシュ関数 (一般に H と書かれます) の使用を必要とします。これは、プロトコルのセキュリティ証明におけるランダム オラクルとしてモデル化されています ([FROST20] および [StrongerSec22] を参照)。実際に使用すべきハッシュ関数に関する具体的な推奨事項については、セクション 6 を参照してください。 H を使用して、ドメインで区切られた個別のハッシュ H1、H2、H3、H4、および H5 を導入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* H1, H2, and H3 map arbitrary byte strings to Scalar elements associated with the prime-order group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* H1、H2、および H3 は、任意のバイト文字列を素数順序グループに関連付けられたスカラー要素にマップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* H4 and H5 are aliases for H with distinct domain separators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* H4 と H5 は、異なるドメイン区切り文字を持つ H のエイリアスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details of H1, H2, H3, H4, and H5 vary based on the ciphersuite used. See Section 6 for more details about each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
H1、H2、H3、H4、および H5 の詳細は、使用される暗号スイートによって異なります。それぞれの詳細については、セクション 6 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4--Helper-Functions">
4. Helper Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. ヘルパー関数
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Beyond the core dependencies, the protocol in this document depends on the following helper operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コアの依存関係を超えて、このドキュメントのプロトコルは次のヘルパー操作に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Nonce generation (Section 4.1);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ノンスの生成 (セクション 4.1)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Polynomials (Section 4.2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 多項式 (セクション 4.2);
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* List operations (Section 4.3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* リスト操作 (セクション 4.3)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Binding factors computation (Section 4.4);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 結合因子の計算 (セクション 4.4)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Group commitment computation (Section 4.5); and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* グループコミットメントの計算 (セクション 4.5)。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Signature challenge computation (Section 4.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 署名チャレンジの計算 (セクション 4.6)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe these operations in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、これらの操作について詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-1--Nonce-Generation">
4.1. Nonce Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. ノンス生成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To hedge against a bad random number generator (RNG) that outputs predictable values, nonces are generated with the nonce_generate function by combining fresh randomness with the secret key as input to a domain-separated hash function built from the ciphersuite hash function H. This domain-separated hash function is denoted as H3. This function always samples 32 bytes of fresh randomness to ensure that the probability of nonce reuse is at most 2^-128 as long as no more than 2^64 signatures are computed by a given signing participant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予測可能な値を出力する不正な乱数生成器 (RNG) を回避するために、nonce_generate 関数を使用して、暗号スイート ハッシュ関数 H から構築されたドメイン分離ハッシュ関数への入力として新鮮なランダム性と秘密キーを組み合わせてノンスが生成されます。このドメイン分離ハッシュ関数は H3 として示されます。この関数は常に 32 バイトの新しいランダム性をサンプリングして、特定の署名参加者によって 2^64 以下の署名が計算される限り、ノンス再利用の確率が最大 2^-128 であることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - secret, a Scalar.

   Outputs:
   - nonce, a Scalar.

   def nonce_generate(secret):
     random_bytes = random_bytes(32)
     secret_enc = G.SerializeScalar(secret)
     return H3(random_bytes || secret_enc)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-2--Polynomials">
4.2. Polynomials
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 多項式
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines polynomials over Scalars that are used in the main protocol. A polynomial of maximum degree t is represented as a list of t+1 coefficients, where the constant term of the polynomial is in the first position and the highest-degree coefficient is in the last position. For example, the polynomial x^2 + 2x + 3 has degree 2 and is represented as a list of three coefficients [3, 2, 1]. A point on the polynomial f is a tuple (x, y), where y = f(x).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、メイン プロトコルで使用されるスカラー上の多項式を定義します。最大次数 t の多項式は、t+1 個の係数のリストとして表されます。多項式の定数項が最初の位置にあり、最高次数の係数が最後の位置にあります。たとえば、多項式 x^2 + 2x + 3 は次数 2 を持ち、3 つの係数 [3, 2, 1] のリストとして表されます。多項式 f 上の点はタプル (x, y) であり、y = f(x) となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function derive_interpolating_value derives a value that is used for polynomial interpolation. It is provided a list of x-coordinates as input, each of which cannot equal 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数derive_interpolating_valueは、多項式補間に使用される値を導出します。入力として x 座標のリストが提供されますが、それぞれを 0 に等しくすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - L, the list of x-coordinates, each a NonZeroScalar.
   - x_i, an x-coordinate contained in L, a NonZeroScalar.

   Outputs:
   - value, a Scalar.

   Errors:
   - &#34;invalid parameters&#34;, if 1) x_i is not in L, or if 2) any
     x-coordinate is represented more than once in L.

   def derive_interpolating_value(L, x_i):
     if x_i not in L:
       raise &#34;invalid parameters&#34;
     for x_j in L:
       if count(x_j, L) &gt; 1:
         raise &#34;invalid parameters&#34;

     numerator = Scalar(1)
     denominator = Scalar(1)
     for x_j in L:
       if x_j == x_i: continue
       numerator *= x_j
       denominator *= x_j - x_i

     value = numerator / denominator
     return value
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-3--List-Operations">
4.3. List Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. リスト操作
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes helper functions that work on lists of values produced during the FROST protocol. The following function encodes a list of participant commitments into a byte string for use in the FROST protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、FROST プロトコル中に生成される値のリストに対して動作するヘルパー関数について説明します。次の関数は、FROST プロトコルで使用できるように、参加者のコミットメントのリストをバイト文字列にエンコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.

   Outputs:
   - encoded_group_commitment, the serialized representation of
     commitment_list, a byte string.

   def encode_group_commitment_list(commitment_list):
     encoded_group_commitment = nil
     for (identifier, hiding_nonce_commitment,
          binding_nonce_commitment) in commitment_list:
       encoded_commitment = (
           G.SerializeScalar(identifier) ||
           G.SerializeElement(hiding_nonce_commitment) ||
           G.SerializeElement(binding_nonce_commitment))
       encoded_group_commitment = (
           encoded_group_commitment ||
           encoded_commitment)
     return encoded_group_commitment
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following function is used to extract identifiers from a commitment list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の関数は、コミットメント リストから識別子を抽出するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.

   Outputs:
   - identifiers, a list of NonZeroScalar values.

   def participants_from_commitment_list(commitment_list):
     identifiers = []
     for (identifier, _, _) in commitment_list:
       identifiers.append(identifier)
     return identifiers
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following function is used to extract a binding factor from a list of binding factors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の関数は、結合因子のリストから結合因子を抽出するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - binding_factor_list = [(i, binding_factor), ...],
     a list of binding factors for each participant, where each element
     in the list indicates a NonZeroScalar identifier i and Scalar
     binding factor.
   - identifier, participant identifier, a NonZeroScalar.

   Outputs:
   - binding_factor, a Scalar.

   Errors:
   - &#34;invalid participant&#34;, when the designated participant is
     not known.

   def binding_factor_for_participant(binding_factor_list, identifier):
     for (i, binding_factor) in binding_factor_list:
       if identifier == i:
         return binding_factor
     raise &#34;invalid participant&#34;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-4--Binding-Factors-Computation">
4.4. Binding Factors Computation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 結合因子の計算
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the subroutine for computing binding factors based on the participant commitment list, message to be signed, and group public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、参加者コミットメント リスト、署名されるメッセージ、およびグループ公開鍵に基づいて結合係数を計算するサブルーチンについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - group_public_key, the public key corresponding to the group signing
     key, an Element.
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.
   - msg, the message to be signed.

   Outputs:
   - binding_factor_list, a list of (NonZeroScalar, Scalar) tuples
     representing the binding factors.

   def compute_binding_factors(group_public_key, commitment_list, msg):
     group_public_key_enc = G.SerializeElement(group_public_key)
     // Hashed to a fixed length.
     msg_hash = H4(msg)
     // Hashed to a fixed length.
     encoded_commitment_hash =
         H5(encode_group_commitment_list(commitment_list))
     // The encoding of the group public key is a fixed length
     // within a ciphersuite.
     rho_input_prefix = group_public_key_enc || msg_hash ||
      encoded_commitment_hash

     binding_factor_list = []
     for (identifier, hiding_nonce_commitment,
          binding_nonce_commitment) in commitment_list:
       rho_input = rho_input_prefix || G.SerializeScalar(identifier)
       binding_factor = H1(rho_input)
       binding_factor_list.append((identifier, binding_factor))
     return binding_factor_list
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-5--Group-Commitment-Computation">
4.5. Group Commitment Computation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. グループコミットメントの計算
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the subroutine for creating the group commitment from a commitment list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、コミットメント リストからグループ コミットメントを作成するサブルーチンについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.
   - binding_factor_list = [(i, binding_factor), ...],
     a list of (NonZeroScalar, Scalar) tuples representing the binding
     factor Scalar for the given identifier.

   Outputs:
   - group_commitment, an Element.

   def compute_group_commitment(commitment_list, binding_factor_list):
     group_commitment = G.Identity()
     for (identifier, hiding_nonce_commitment,
          binding_nonce_commitment) in commitment_list:
       binding_factor = binding_factor_for_participant(
           binding_factor_list, identifier)
       binding_nonce = G.ScalarMult(
           binding_nonce_commitment,
           binding_factor)
       group_commitment = (
           group_commitment +
           hiding_nonce_commitment +
           binding_nonce)
     return group_commitment
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the performance of this algorithm is defined naively and scales linearly relative to the number of signers. For improved performance, the group commitment can be computed using multi-exponentiation techniques such as Pippinger&#39;s algorithm; see [MultExp] for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムのパフォーマンスは素朴に定義されており、署名者の数に対して線形にスケールすることに注意してください。パフォーマンスを向上させるために、Pippinger のアルゴリズムなどの多重累乗手法を使用してグループ コミットメントを計算できます。詳細については、[MultExp] を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="4-6--Signature-Challenge-Computation">
4.6. Signature Challenge Computation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 署名チャレンジの計算
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the subroutine for creating the per-message challenge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、メッセージごとのチャレンジを作成するためのサブルーチンについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - group_commitment, the group commitment, an Element.
   - group_public_key, the public key corresponding to the group signing
     key, an Element.
   - msg, the message to be signed, a byte string.

   Outputs:
   - challenge, a Scalar.

   def compute_challenge(group_commitment, group_public_key, msg):
     group_comm_enc = G.SerializeElement(group_commitment)
     group_public_key_enc = G.SerializeElement(group_public_key)
     challenge_input = group_comm_enc || group_public_key_enc || msg
     challenge = H2(challenge_input)
     return challenge
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5--Two-Round-FROST-Signing-Protocol">
5. Two-Round FROST Signing Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 2 ラウンドの FROST 署名プロトコル
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the two-round FROST signing protocol for producing Schnorr signatures. The protocol is configured to run with a selection of NUM_PARTICIPANTS signer participants and a Coordinator. NUM_PARTICIPANTS is a positive and non-zero integer that MUST be at least MIN_PARTICIPANTS, but MUST NOT be larger than MAX_PARTICIPANTS, where MIN_PARTICIPANTS &lt;= MAX_PARTICIPANTS and MIN_PARTICIPANTS is a positive and non-zero integer. Additionally, MAX_PARTICIPANTS MUST be a positive integer less than the group order. A signer participant, or simply &#34;participant&#34;, is an entity that is trusted to hold and use a signing key share. The Coordinator is an entity with the following responsibilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Schnorr 署名を生成するための 2 ラウンドの FROST 署名プロトコルについて説明します。このプロトコルは、選択した NUM_PARTICIPANTS の署名者参加者とコーディネーターで実行されるように構成されています。NUM_PARTICIPANTS はゼロ以外の正の整数であり、少なくとも MIN_PARTICIPANTS である必要がありますが、MAX_PARTICIPANTS より大きくてはなりません。MIN_PARTICIPANTS &lt;= MAX_PARTICIPANTS であり、MIN_PARTICIPANTS は正のゼロ以外の整数です。さらに、MAX_PARTICIPANTS はグループの順序より小さい正の整数でなければなりません。署名者参加者、または単に「参加者」は、署名鍵共有を保持および使用することが信頼されているエンティティです。コーディネーターは次の責任を持つ組織です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1. Determining the participants that will participate (at least MIN_PARTICIPANTS in number);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1. 参加する参加者を決定します (少なくとも MIN_PARTICIPANTS 人の数)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2. Coordinating rounds (receiving and forwarding inputs among participants);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2. ラウンドの調整（参加者間でのインプットの受信と転送）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
3. Aggregating signature shares output by each participant; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
3. 各参加者が出力した署名シェアを集約する。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
4. Publishing the resulting signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
4. 結果の署名を公開します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST assumes that the Coordinator and the set of signer participants are chosen externally to the protocol. Note that it is possible to deploy the protocol without designating a single Coordinator; see Section 7.5 for more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、コーディネーターと署名者参加者のセットがプロトコルの外部で選択されることを前提としています。単一のコーディネーターを指定せずにプロトコルを展開できることに注意してください。詳細については、セクション 7.5 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST produces signatures that can be verified as if they were produced from a single signer using a signing key s with corresponding public key PK, where s is a Scalar value and PK = G.ScalarBaseMult(s). As a threshold signing protocol, the group signing key s is Shamir secret-shared amongst each of the MAX_PARTICIPANTS participants and is used to produce signatures; see Appendix C.1 for more information about Shamir secret sharing. In particular, FROST assumes each participant is configured with the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、署名鍵 s と対応する公開鍵 PK を使用して、単一の署名者から生成されたかのように検証できる署名を生成します。ここで、s はスカラー値、PK = G.ScalarBaseMult(s) です。しきい値署名プロトコルとして、グループ署名鍵 s は MAX_PARTICIPANTS の各参加者間でシャミール秘密共有され、署名の生成に使用されます。Shamir 秘密共有の詳細については、付録 C.1 を参照してください。特に、FROST は、各参加者が次の情報を使用して構成されていることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* An identifier, which is a NonZeroScalar value denoted as i in the range [1, MAX_PARTICIPANTS] and MUST be distinct from the identifier of every other participant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 識別子は、範囲 [1, MAX_PARTICIPANTS] 内の i として示される NonZeroScalar 値であり、他のすべての参加者の識別子とは区別されなければなりません (MUST)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* A signing key sk_i, which is a Scalar value representing the i-th Shamir secret share of the group signing key s. In particular, sk_i is the value f(i) on a secret polynomial f of degree (MIN_PARTICIPANTS - 1), where s is f(0). The public key corresponding to this signing key share is PK_i = G.ScalarBaseMult(sk_i).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 署名鍵 sk_i。グループ署名鍵 s の i 番目のシャミア秘密共有を表すスカラー値です。特に、sk_i は、次数 (MIN_PARTICIPANTS - 1) の秘密多項式 f の値 f(i) であり、s は f(0) です。この署名鍵共有に対応する公開鍵は、PK_i = G.ScalarBaseMult(sk_i) です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, the Coordinator and each participant are configured with common group information, denoted as &#34;group info,&#34; which consists of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、コーディネーターと各参加者は、「グループ情報」と呼ばれる共通のグループ情報を使用して構成されます。これは次の内容で構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Group public key, which is an Element in G denoted as PK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* グループ公開キー。PK として示される G の要素です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Public keys PK_i for each participant, which are Element values in G denoted as PK_i for each i in [1, MAX_PARTICIPANTS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 各参加者の公開鍵 PK_i。これは、[1, MAX_PARTICIPANTS] の各 i の PK_i として示される G の要素値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not specify how this information, including the signing key shares, are configured and distributed to participants. In general, two configuration mechanisms are possible: one that requires a single trusted dealer and one that requires performing a distributed key generation protocol. We highlight the key generation mechanism by a trusted dealer in Appendix C for reference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、署名鍵共有を含むこの情報がどのように構成され、参加者に配布されるかについては規定されていません。一般に、2 つの構成メカニズムが可能です。1 つは単一の信頼できるディーラーを必要とするもの、もう 1 つは分散キー生成プロトコルの実行を必要とするものです。付録 C では、参考として信頼できるディーラーによる鍵生成メカニズムを強調表示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST requires two rounds to complete. In the first round, participants generate and publish one-time-use commitments to be used in the second round. In the second round, each participant produces a share of the signature over the Coordinator-chosen message and the other participant commitments. After the second round is completed, the Coordinator aggregates the signature shares to produce a final signature. The Coordinator SHOULD abort the protocol if the signature is invalid; see Section 5.4 for more information about dealing with invalid signatures and misbehaving participants. This complete interaction (without being aborted) is shown in Figure 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST を完了するには 2 ラウンドが必要です。最初のラウンドでは、参加者は第 2 ラウンドで使用する 1 回限りの利用コミットメントを生成して公開します。第 2 ラウンドでは、各参加者は、コーディネーターが選択したメッセージと他の参加者のコミットメントに対する署名のシェアを作成します。第 2 ラウンドが完了すると、コーディネーターは署名シェアを集約して最終署名を生成します。署名が無効な場合、コーディネーターはプロトコルを中止すべきです(SHOULD)。無効な署名や不正行為を行う参加者への対処の詳細については、セクション 5.4 を参照してください。この完全な対話 (中断なし) を図 1 に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           (group info)            (group info,     (group info,
               |               signing key share)   signing key share)
               |                         |                |
               v                         v                v
           Coordinator               Signer-1   ...   Signer-n
       ------------------------------------------------------------
      signing request
   ------------&gt;
               |
         == Round 1 (Commitment) ==
               | participant commitment |                 |
               |&lt;-----------------------+                 |
               |          ...                             |
               | participant commitment            (commit state) ==\
               |&lt;-----------------------------------------+         |
                                                                    |
         == Round 2 (Signature Share Generation) ==                 |
      message
   ------------&gt;
               |                                                    |
               |   participant input    |                 |         |
               +------------------------&gt;                 |         |
               |     signature share    |                 |         |
               |&lt;-----------------------+                 |         |
               |          ...                             |         |
               |    participant input                     |         |
               +------------------------------------------&gt;         /
               |     signature share                      |&lt;=======/
               &lt;------------------------------------------+
               |
         == Aggregation ==
               |
     signature |
   &lt;-----------+
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 1: FROST Protocol Overview
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
図 1: FROST プロトコルの概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Details for round one are described in Section 5.1 and details for round two are described in Section 5.2. Note that each participant persists some state between the two rounds; this state is deleted as described in Section 5.2. The final Aggregation step is described in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラウンド 1 の詳細はセクション 5.1 で説明され、ラウンド 2 の詳細はセクション 5.2 で説明されます。各参加者は 2 つのラウンドの間で何らかの状態を保持することに注意してください。この状態はセクション 5.2 で説明されているように削除されます。最後の集計ステップについては、セクション 5.3 で説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST assumes that all inputs to each round, especially those that are received over the network, are validated before use. In particular, this means that any value of type Element or Scalar received over the network MUST be deserialized using DeserializeElement and DeserializeScalar, respectively, as these functions perform the necessary input validation steps. Additionally, all messages sent over the wire MUST be encoded using their respective functions, e.g., Scalars and Elements are encoded using SerializeScalar and SerializeElement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、各ラウンドへのすべての入力、特にネットワーク経由で受信した入力が使用前に検証されることを前提としています。特に、これは、ネットワーク経由で受信したタイプ Element または Scalar の値は、それぞれ DeserializeElement および DeserializeScalar を使用して逆シリアル化する必要があることを意味します。これらの関数は、必要な入力検証手順を実行するためです。さらに、ネットワーク経由で送信されるすべてのメッセージは、それぞれの関数を使用してエンコードされなければなりません (MUST)。たとえば、スカラーと要素は SerializeScalar と SerializeElement を使用してエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST assumes reliable message delivery between the Coordinator and participants in order for the protocol to complete. An attacker masquerading as another participant will result only in an invalid signature; see Section 7. However, in order to identify misbehaving participants, we assume that the network channel is additionally authenticated; confidentiality is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、プロトコルを完了するために、コーディネーターと参加者の間で信頼性の高いメッセージ配信が行われることを前提としています。攻撃者が別の参加者になりすましても、無効な署名が生成されるだけです。セクション 7 を参照してください。ただし、不正行為を行っている参加者を特定するために、ネットワーク チャネルが追加で認証されていると仮定します。秘密保持は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-1--Round-One---Commitment">
5.1. Round One - Commitment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. ラウンド 1 - コミットメント
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Round one involves each participant generating nonces and their corresponding public commitments. A nonce is a pair of Scalar values, and a commitment is a pair of Element values. Each participant&#39;s behavior in this round is described by the commit function below. Note that this function invokes nonce_generate twice, once for each type of nonce produced. The output of this function is a pair of secret nonces (hiding_nonce, binding_nonce) and their corresponding public commitments (hiding_nonce_commitment, binding_nonce_commitment).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラウンド 1 では、各参加者がナンスとそれに対応するパブリック コミットメントを生成します。ノンスはスカラー値のペアであり、コミットメントは要素値のペアです。このラウンドにおける各参加者の行動は、以下の commit 関数によって記述されます。この関数は、生成される nonce のタイプごとに 1 回ずつ、nonce_generate を 2 回呼び出します。この関数の出力は、秘密のノンス (hiding_nonce、binding_nonce) のペアと、それらに対応するパブリック コミットメント (hiding_nonce_commitment、binding_nonce_commitment) です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - sk_i, the secret key share, a Scalar.

   Outputs:
   - (nonce, comm), a tuple of nonce and nonce commitment pairs,
     where each value in the nonce pair is a Scalar and each value in
     the nonce commitment pair is an Element.

   def commit(sk_i):
     hiding_nonce = nonce_generate(sk_i)
     binding_nonce = nonce_generate(sk_i)
     hiding_nonce_commitment = G.ScalarBaseMult(hiding_nonce)
     binding_nonce_commitment = G.ScalarBaseMult(binding_nonce)
     nonces = (hiding_nonce, binding_nonce)
     comms = (hiding_nonce_commitment, binding_nonce_commitment)
     return (nonces, comms)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The outputs nonce and comm from participant P_i are both stored locally and kept for use in the second round. The nonce value is secret and MUST NOT be shared, whereas the public output comm is sent to the Coordinator. The nonce values produced by this function MUST NOT be used in more than one invocation of sign, and the nonces MUST be generated from a source of secure randomness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者 P_i からの出力 nonce と comm は両方ともローカルに保存され、第 2 ラウンドで使用するために保持されます。nonce 値は秘密であり、共有してはなりませんが、パブリック出力通信はコーディネーターに送信されます。この関数によって生成された nonce 値は、sign の複数の呼び出しで使用されてはならず、安全なランダム性のソースから nonce が生成されなければなりません (MUST)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-2--Round-Two---Signature-Share-Generation">
5.2. Round Two - Signature Share Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ラウンド 2 - 署名シェアの生成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In round two, the Coordinator is responsible for sending the message to be signed and choosing the participants that will participate (a number of at least MIN_PARTICIPANTS). Signers additionally require locally held data, specifically their private key and the nonces corresponding to their commitment issued in round one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラウンド 2 では、コーディネーターは、署名されるメッセージを送信し、参加する参加者 (少なくとも MIN_PARTICIPANTS の数) を選択する責任があります。署名者はさらに、ローカルに保持されているデータ、特に秘密鍵とラウンド 1 で発行されたコミットメントに対応するノンスを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Coordinator begins by sending each participant the message to be signed along with the set of signing commitments for all participants in the participant list. Each participant MUST validate the inputs before processing the Coordinator&#39;s request. In particular, the signer MUST validate commitment_list, deserializing each group Element in the list using DeserializeElement from Section 3.1. If deserialization fails, the signer MUST abort the protocol. Moreover, each participant MUST ensure that its identifier and commitments (from the first round) appear in commitment_list. Applications that restrict participants from processing arbitrary input messages are also required to perform relevant application-layer input validation checks; see Section 7.7 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーディネーターは、参加者リスト内のすべての参加者に対する一連の署名コミットメントとともに、署名されるメッセージを各参加者に送信することから始めます。各参加者は、コーディネーターのリクエストを処理する前に入力を検証しなければなりません。特に、署名者は、セクション 3.1 の DeserializeElement を使用して、リスト内の各グループ要素を逆シリアル化し、commitment_list を検証しなければなりません (MUST)。逆シリアル化が失敗した場合、署名者はプロトコルを中止しなければなりません (MUST)。さらに、各参加者は、その識別子と（最初のラウンドからの）コミットメントが commit_list に表示されていることを確認しなければなりません（MUST）。参加者による任意の入力メッセージの処理を制限するアプリケーションは、関連するアプリケーション層の入力検証チェックを実行することも必要です。詳細については、セクション 7.7 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt and successful input validation, each signer then runs the following procedure to produce its own signature share.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信して入力検証が成功すると、各署名者は次の手順を実行して独自の署名共有を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - identifier, identifier i of the participant, a NonZeroScalar.
   - sk_i, signer secret key share, a Scalar.
   - group_public_key, public key corresponding to the group signing
     key, an Element.
   - nonce_i, pair of Scalar values (hiding_nonce, binding_nonce)
     generated in round one.
   - msg, the message to be signed, a byte string.
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.


   Outputs:
   - sig_share, a signature share, a Scalar.

   def sign(identifier, sk_i, group_public_key,
            nonce_i, msg, commitment_list):
     # Compute the binding factor(s)
     binding_factor_list = compute_binding_factors(group_public_key,
      commitment_list, msg)
     binding_factor = binding_factor_for_participant(
         binding_factor_list, identifier)

     # Compute the group commitment
     group_commitment = compute_group_commitment(
         commitment_list, binding_factor_list)

     # Compute the interpolating value
     participant_list = participants_from_commitment_list(
         commitment_list)
     lambda_i = derive_interpolating_value(participant_list, identifier)

     # Compute the per-message challenge
     challenge = compute_challenge(
         group_commitment, group_public_key, msg)

     # Compute the signature share
     (hiding_nonce, binding_nonce) = nonce_i
     sig_share = hiding_nonce + (binding_nonce * binding_factor) +
         (lambda_i * sk_i * challenge)

     return sig_share
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The output of this procedure is a signature share. Each participant sends these shares back to the Coordinator. Each participant MUST delete the nonce and corresponding commitment after completing sign and MUST NOT use the nonce as input more than once to sign.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この手順の出力は署名共有です。各参加者はこれらの共有をコーディネーターに送り返します。各参加者は、署名を完了した後、ノンスと対応するコミットメントを削除しなければならず (MUST)、署名のための入力としてノンスを複数回使用してはなりません (MUST NOT)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the lambda_i value derived during this procedure does not change across FROST signing operations for the same signing group. As such, participants can compute it once and store it for reuse across signing sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この手順中に導出された lambda_i 値は、同じ署名グループに対する FROST 署名操作全体で変更されないことに注意してください。そのため、参加者はそれを一度計算して保存し、署名セッション全体で再利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-3--Signature-Share-Aggregation">
5.3. Signature Share Aggregation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 署名共有の集約
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After participants perform round two and send their signature shares to the Coordinator, the Coordinator aggregates each share to produce a final signature. Before aggregating, the Coordinator MUST validate each signature share using DeserializeScalar. If validation fails, the Coordinator MUST abort the protocol, as the resulting signature will be invalid. If all signature shares are valid, the Coordinator aggregates them to produce the final signature using the following procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者がラウンド 2 を実行し、署名シェアをコーディネーターに送信した後、コーディネーターは各シェアを集約して最終署名を作成します。集約する前に、コーディネーターは DeserializeScalar を使用して各署名共有を検証しなければなりません (MUST)。検証が失敗した場合、結果として得られる署名は無効になるため、コーディネーターはプロトコルを中止しなければなりません(MUST)。すべての署名共有が有効な場合、コーディネーターは次の手順を使用してそれらを集約し、最終的な署名を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.
   - msg, the message to be signed, a byte string.
   - group_public_key, public key corresponding to the group signing
     key, an Element.
   - sig_shares, a set of signature shares z_i, Scalar values, for each
     participant, of length NUM_PARTICIPANTS, where
     MIN_PARTICIPANTS &lt;= NUM_PARTICIPANTS &lt;= MAX_PARTICIPANTS.

   Outputs:
   - (R, z), a Schnorr signature consisting of an Element R and
     Scalar z.

   def aggregate(commitment_list, msg, group_public_key, sig_shares):
     # Compute the binding factors
     binding_factor_list = compute_binding_factors(group_public_key,
      commitment_list, msg)

     # Compute the group commitment
     group_commitment = compute_group_commitment(
         commitment_list, binding_factor_list)

     # Compute aggregated signature
     z = Scalar(0)
     for z_i in sig_shares:
       z = z + z_i
     return (group_commitment, z)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The output from the aggregation step is the output signature (R, z). The canonical encoding of this signature is specified in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集約ステップからの出力は、出力署名 (R, z) です。この署名の正規のエンコーディングはセクション 6 で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Coordinator SHOULD verify this signature using the group public key before publishing or releasing the signature. Signature verification is as specified for the corresponding ciphersuite; see Section 6 for details. The aggregate signature will verify successfully if all signature shares are valid. Moreover, subsets of valid signature shares will not yield a valid aggregate signature themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーディネーターは、署名を公開または解放する前に、グループ公開鍵を使用してこの署名を検証する必要があります (SHOULD)。署名検証は、対応する暗号スイートに指定されているとおりです。詳細についてはセクション 6 を参照してください。すべての署名共有が有効であれば、集約署名は正常に検証されます。さらに、有効な署名共有のサブセット自体は、有効な集約署名を生成しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the aggregate signature verification fails, the Coordinator MAY verify each signature share individually to identify and act on misbehaving participants. The mechanism for acting on a misbehaving participant is out of scope for this specification; see Section 5.4 for more information about dealing with invalid signatures and misbehaving participants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集約された署名検証が失敗した場合、コーディネーターは、不正行為を行っている参加者を特定し、対処するために各署名共有を個別に検証してもよい(MAY)。不正行為を行う参加者に対処するメカニズムは、この仕様の範囲外です。無効な署名や不正行為を行う参加者への対処の詳細については、セクション 5.4 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function for verifying a signature share, denoted as verify_signature_share, is described below. Recall that the Coordinator is configured with &#34;group info&#34; that contains the group public key PK and public keys PK_i for each participant. The group_public_key and PK_i function arguments MUST come from that previously stored group info.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
verify_signature_share として示される署名共有を検証する関数については、以下で説明します。コーディネーターは、グループ公開鍵 PK と各参加者の公開鍵 PK_i を含む「グループ情報」を使用して構成されていることを思い出してください。group_public_key および PK_i 関数の引数は、以前に保存されたグループ情報から取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - identifier, identifier i of the participant, a NonZeroScalar.
   - PK_i, the public key for the i-th participant, where
     PK_i = G.ScalarBaseMult(sk_i), an Element.
   - comm_i, pair of Element values in G
     (hiding_nonce_commitment, binding_nonce_commitment) generated in
     round one from the i-th participant.
   - sig_share_i, a Scalar value indicating the signature share as
     produced in round two from the i-th participant.
   - commitment_list = [(i, hiding_nonce_commitment_i,
     binding_nonce_commitment_i), ...], a list of commitments issued by
     each participant, where each element in the list indicates a
     NonZeroScalar identifier i and two commitment Element values
     (hiding_nonce_commitment_i, binding_nonce_commitment_i). This list
     MUST be sorted in ascending order by identifier.
   - group_public_key, public key corresponding to the group signing
     key, an Element.
   - msg, the message to be signed, a byte string.

   Outputs:
   - True if the signature share is valid, and False otherwise.

   def verify_signature_share(
           identifier, PK_i, comm_i, sig_share_i, commitment_list,
           group_public_key, msg):
     # Compute the binding factors
     binding_factor_list = compute_binding_factors(group_public_key,
      commitment_list, msg)
     binding_factor = binding_factor_for_participant(
         binding_factor_list, identifier)

     # Compute the group commitment
     group_commitment = compute_group_commitment(
         commitment_list, binding_factor_list)

     # Compute the commitment share
     (hiding_nonce_commitment, binding_nonce_commitment) = comm_i
     comm_share = hiding_nonce_commitment + G.ScalarMult(
         binding_nonce_commitment, binding_factor)

     # Compute the challenge
     challenge = compute_challenge(
         group_commitment, group_public_key, msg)

     # Compute the interpolating value
     participant_list = participants_from_commitment_list(
         commitment_list)
     lambda_i = derive_interpolating_value(participant_list, identifier)

     # Compute relation values
     l = G.ScalarBaseMult(sig_share_i)
     r = comm_share + G.ScalarMult(PK_i, challenge * lambda_i)

     return l == r
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Coordinator can verify each signature share before aggregating and verifying the signature under the group public key. However, since the aggregate signature is valid if all signature shares are valid, this order of operations is more expensive if the signature is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーディネーターは、グループ公開鍵の下で署名を集約して検証する前に、各署名共有を検証できます。ただし、すべての署名共有が有効であれば集約署名も有効であるため、署名が有効であればこの順序の操作のコストが高くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="5-4--Identifiable-Abort">
5.4. Identifiable Abort
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 識別可能なアボート
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST does not provide robustness; i.e, all participants are required to complete the protocol honestly in order to generate a valid signature. When the signing protocol does not produce a valid signature, the Coordinator SHOULD abort; see Section 7 for more information about FROST&#39;s security properties and the threat model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は堅牢性を提供しません。つまり、有効な署名を生成するには、すべての参加者が正直にプロトコルを完了する必要があります。署名プロトコルが有効な署名を生成しない場合、コーディネーターは中止すべきである(SHOULD)。FROST のセキュリティ特性と脅威モデルの詳細については、セクション 7 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a result of this property, a misbehaving participant can cause a denial of service (DoS) on the signing protocol by contributing malformed signature shares or refusing to participate. Identifying misbehaving participants that produce invalid shares can be done by checking signature shares from each participant using verify_signature_share as described in Section 5.3. FROST assumes the network channel is authenticated to identify the signer that misbehaved. FROST allows for identifying misbehaving participants that produce invalid signature shares as described in Section 5.3. FROST does not provide accommodations for identifying participants that refuse to participate, though applications are assumed to detect when participants fail to engage in the signing protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この特性の結果、不正行為を行う参加者は、不正な形式の署名共有を提供したり、参加を拒否したりすることで、署名プロトコル上でサービス拒否 (DoS) を引き起こす可能性があります。無効な共有を生成する不正な参加者を特定するには、セクション 5.3 で説明されている verify_signature_share を使用して各参加者からの署名共有を確認します。FROST は、不正行為を行った署名者を識別するためにネットワーク チャネルが認証されていると想定します。FROST を使用すると、セクション 5.3 で説明されているように、無効な署名共有を生成する不正な参加者を特定できます。FROST は、参加を拒否する参加者を特定するための機能を提供しませんが、参加者が署名プロトコルに参加しなかった場合はアプリケーションが検出すると想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In both cases, preventing this type of attack requires the Coordinator to identify misbehaving participants such that applications can take corrective action. The mechanism for acting on misbehaving participants is out of scope for this specification. However, one reasonable approach would be to remove the misbehaving participant from the set of allowed participants in future runs of FROST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの場合も、このタイプの攻撃を防ぐには、コーディネーターが不正行為を行っている参加者を特定し、アプリケーションが修正措置を講じることができるようにする必要があります。不正行為を行う参加者に対処するメカニズムは、この仕様の範囲外です。ただし、合理的なアプローチの 1 つは、今後の FROST の実行で、不正行為を行った参加者を許可された参加者のセットから削除することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6--Ciphersuites">
6. Ciphersuites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 暗号スイート
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A FROST ciphersuite must specify the underlying prime-order group details and cryptographic hash function. Each ciphersuite is denoted as (Group, Hash), e.g., (ristretto255, SHA-512). This section contains some ciphersuites. Each ciphersuite also includes a context string, denoted as contextString, which is an ASCII string literal (with no terminating NUL character).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST 暗号スイートでは、基礎となる素数順序グループの詳細と暗号化ハッシュ関数を指定する必要があります。各暗号スイートは、(グループ、ハッシュ) (例: (ristretto255、SHA-512)) として示されます。このセクションにはいくつかの暗号スイートが含まれています。各暗号スイートには、contextString として示されるコンテキスト文字列も含まれています。これは、ASCII 文字列リテラル (終端 NUL 文字なし) です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED ciphersuite is (ristretto255, SHA-512) as described in Section 6.2. The (Ed25519, SHA-512) and (Ed448, SHAKE256) ciphersuites are included for compatibility with Ed25519 and Ed448 as defined in [RFC8032].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション 6.2 で説明されているように、推奨される暗号スイートは (ristretto255、SHA-512) です。(Ed25519、SHA-512) および (Ed448、SHAKE256) 暗号スイートは、[RFC8032] で定義されている Ed25519 および Ed448 との互換性のために含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DeserializeElement and DeserializeScalar functions instantiated for a particular prime-order group corresponding to a ciphersuite MUST adhere to the description in Section 3.1. Validation steps for these functions are described for each of the ciphersuites below. Future ciphersuites MUST describe how input validation is done for DeserializeElement and DeserializeScalar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号スイートに対応する特定の素数順序グループに対してインスタンス化された DeserializeElement 関数と DeserializeScalar 関数は、セクション 3.1 の説明に従わなければなりません (MUST)。これらの関数の検証手順は、以下の暗号スイートごとに説明されています。将来の暗号スイートでは、DeserializeElement と DeserializeScalar の入力検証がどのように行われるかを記述しなければなりません (MUST)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ciphersuite includes explicit instructions for verifying signatures produced by FROST. Note that these instructions are equivalent to those produced by a single participant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各暗号スイートには、FROST によって生成された署名を検証するための明示的な命令が含まれています。これらの指示は 1 人の参加者によって作成された指示と同等であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ciphersuite adheres to the requirements in Section 6.6. Future ciphersuites MUST also adhere to these requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各暗号スイートはセクション 6.6 の要件に準拠しています。将来の暗号スイートもこれらの要件に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-1--FROSTEd25519-SHA-512">
6.1. FROST(Ed25519, SHA-512)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. フロスト(Ed25519、SHA-512)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This ciphersuite uses edwards25519 for the Group and SHA-512 for the hash function H meant to produce Ed25519-compliant signatures as specified in Section 5.1 of [RFC8032]. The value of the contextString parameter is &#34;FROST-ED25519-SHA512-v1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この暗号スイートは、グループに edwards25519 を使用し、[RFC8032] のセクション 5.1 で指定されているように Ed25519 準拠の署名を生成することを目的としたハッシュ関数 H に SHA-512 を使用します。contextString パラメータの値は「FROST-ED25519-SHA512-v1」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
edwards25519 [RFC8032], where Ne = 32 and Ns = 32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
edwards25519 [RFC 8032]、Ne = 32 番目、Ns = 32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Order():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注文（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Return 2^252 + 27742317777372353535851937790883648493 (see [RFC7748]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
2^252 + 27742317777372353535851937790883648493 を返します ([RFC7748] を参照)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identity():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
身元（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
As defined in [RFC7748].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RFC7748]で定義されているとおり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as specified in [RFC8032], Section 5.1.2. Additionally, this function validates that the input element is not the group identity element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RFC8032]、セクション 5.1.2 の規定に従って実装されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeElement(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要素の逆シリアル化 (バグ):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as specified in [RFC8032], Section 5.1.3. Additionally, this function validates that the resulting element is not the group identity element and is in the prime-order subgroup. If any of these checks fail, deserialization returns an error. The latter check can be implemented by multiplying the resulting point by the order of the group and checking that the result is the identity element. Note that optimizations for this check exist; see [Pornin22].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RFC8032]、セクション 5.1.3 の規定に従って実装されます。さらに、この関数は、結果の要素がグループ単位要素ではなく、素数順序サブグループ内にあることを検証します。これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。後者のチェックは、結果の点にグループの次数を乗算し、その結果が単位要素であることをチェックすることによって実装できます。このチェックには最適化が存在することに注意してください。[Pornin22] を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar(s):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by outputting the little-endian 32-byte encoding of the Scalar value with the top three bits set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
上位 3 ビットを 0 に設定して、スカラー値のリトル エンディアン 32 バイト エンコードを出力することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a Scalar from a little-endian 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
リトルエンディアンの 32 バイト文字列からスカラーを逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。これは、入力の上位 3 ビットがゼロでなければならないことを意味することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hash (H):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ(H):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-512, which has an output of 64 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-512。64 バイトの出力があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;rho&#34; || m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;rho&#34; || m) を計算し、64 バイトのダイジェストをリトル エンディアン整数として解釈し、結果の整数を 2^252 + 27742317777372353535851937790883648493 で除算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(m) を計算し、64 バイトのダイジェストをリトル エンディアン整数として解釈し、結果の整数を 2^252 + 27742317777372353535851937790883648493 で除算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;nonce&#34; || m), interpreting the 64-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^252 + 27742317777372353535851937790883648493.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;nonce&#34; || m) を計算し、64 バイトのダイジェストをリトル エンディアン整数として解釈し、結果の整数を 2^252 + 27742317777372353535851937790883648493 で除算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H4(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ4(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;msg&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;msg&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H5(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ5(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;com&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;com&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally, H2 would also include a domain separator; however, for compatibility with [RFC8032], it is omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、H2 にはドメイン区切り文字も含まれます。ただし、[RFC8032]との互換性を考慮して省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Signature verification is as specified in Section 5.1.7 of [RFC8032] with the constraint that implementations MUST check the group equation [8][z]B = [8]R + [8][c]PK (changed to use the notation in this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名検証は、[RFC8032] のセクション 5.1.7 に規定されているとおりですが、実装は群方程式 [8][z]B = [8]R + [8][c]PK (この文書での表記を使用するように変更されました) をチェックしなければならないという制約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Canonical signature encoding is as specified in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規の署名エンコーディングは付録 A で指定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-2--FROSTristretto255-SHA-512">
6.2. FROST(ristretto255, SHA-512)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. FROST(リストレット255、SHA-512)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This ciphersuite uses ristretto255 for the Group and SHA-512 for the hash function H. The value of the contextString parameter is &#34;FROST-RISTRETTO255-SHA512-v1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この暗号スイートは、グループに ristretto255 を使用し、ハッシュ関数 H に SHA-512 を使用します。 contextString パラメーターの値は「FROST-RISTRETTO255-SHA512-v1」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ristretto255 [RISTRETTO], where Ne = 32 and Ns = 32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ristretto255 [リストレット]、Ne = 32、Ns = 32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Order():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注文（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Return 2^252 + 27742317777372353535851937790883648493 (see [RISTRETTO]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
2^252 + 27742317777372353535851937790883648493 を返します ([RISTRETTO] を参照)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identity():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
身元（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
As defined in [RISTRETTO].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RISTRETTO]で定義されているとおり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented using the &#34;Encode&#34; function from [RISTRETTO]. Additionally, this function validates that the input element is not the group identity element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RISTRETTO]の「Encode」機能を利用して実装しました。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeElement(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要素の逆シリアル化 (バグ):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented using the &#34;Decode&#34; function from [RISTRETTO]. Additionally, this function validates that the resulting element is not the group identity element. If either the &#34;Decode&#34; function or the check fails, deserialization returns an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RISTRETTO]の「デコード」機能を利用して実装しました。さらに、この関数は、結果の要素がグループ ID 要素ではないことを検証します。「デコード」機能またはチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar(s):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by outputting the little-endian 32-byte encoding of the Scalar value with the top three bits set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
上位 3 ビットを 0 に設定して、スカラー値のリトル エンディアン 32 バイト エンコードを出力することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a Scalar from a little-endian 32-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1]. Note that this means the top three bits of the input MUST be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
リトルエンディアンの 32 バイト文字列からスカラーを逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。これは、入力の上位 3 ビットがゼロでなければならないことを意味することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hash (H):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ(H):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-512, which has 64 bytes of output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-512。64 バイトの出力があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;rho&#34; || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RISTRETTO] セクション 4.4 で説明されているように、H(contextString || &#34;rho&#34; || m) を計算し、出力をスカラーにマッピングすることによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;chal&#34; || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RISTRETTO] セクション 4.4 で説明されているように、H(contextString || &#34;chal&#34; || m) を計算し、出力をスカラーにマッピングすることによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;nonce&#34; || m) and mapping the output to a Scalar as described in [RISTRETTO], Section 4.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RISTRETTO] セクション 4.4 で説明されているように、H(contextString || &#34;nonce&#34; || m) を計算し、出力をスカラーにマッピングすることによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H4(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ4(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;msg&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;msg&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H5(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ5(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;com&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;com&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Signature verification is as specified in Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名検証は付録 B に規定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Canonical signature encoding is as specified in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規の署名エンコーディングは付録 A で指定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-3--FROSTEd448-SHAKE256">
6.3. FROST(Ed448, SHAKE256)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. フロスト(Ed448、SHAKE256)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This ciphersuite uses edwards448 for the Group and SHAKE256 for the hash function H meant to produce Ed448-compliant signatures as specified in Section 5.2 of [RFC8032]. Unlike Ed448 in [RFC8032], this ciphersuite does not allow applications to specify a context string and always sets the context of [RFC8032] to the empty string. Note that this ciphersuite does not allow applications to specify a context string as is allowed for Ed448 in [RFC8032], and always sets the [RFC8032] context string to the empty string. The value of the (internal to FROST) contextString parameter is &#34;FROST-ED448-SHAKE256-v1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この暗号スイートは、[RFC8032] のセクション 5.2 で指定されているように、Ed448 準拠の署名を生成することを目的として、グループに edwards448 を使用し、ハッシュ関数 H に SHAKE256 を使用します。[RFC8032] の Ed448 とは異なり、この暗号スイートではアプリケーションがコンテキスト文字列を指定することはできず、[RFC8032] のコンテキストは常に空の文字列に設定されます。この暗号スイートでは、[RFC8032] の Ed448 で許可されているようにアプリケーションがコンテキスト文字列を指定することはできず、[RFC8032] コンテキスト文字列は常に空の文字列に設定されることに注意してください。(FROST への内部) contextString パラメーターの値は、「FROST-ED448-SHAKE256-v1」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
edwards448 [RFC8032], where Ne = 57 and Ns = 57.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
edwards448 [RFC8032]、Ne = 57、Ns = 57。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Order():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注文（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Return 2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
2^446 - 13818066809895115352007386748515426880336 692474882178609894547503885 を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identity():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
身元（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
As defined in [RFC7748].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RFC7748]で定義されているとおり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as specified in [RFC8032], Section 5.2.2. Additionally, this function validates that the input element is not the group identity element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RFC8032]、セクション 5.2.2 の規定に従って実装されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeElement(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要素の逆シリアル化 (バグ):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as specified in [RFC8032], Section 5.2.3. Additionally, this function validates that the resulting element is not the group identity element and is in the prime-order subgroup. If any of these checks fail, deserialization returns an error. The latter check can be implemented by multiplying the resulting point by the order of the group and checking that the result is the identity element. Note that optimizations for this check exist; see [Pornin22].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[RFC8032]、セクション 5.2.3 の規定に従って実装されます。さらに、この関数は、結果の要素がグループ単位要素ではなく、素数順序サブグループ内にあることを検証します。これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。後者のチェックは、結果の点にグループの次数を乗算し、その結果が単位要素であることをチェックすることによって実装できます。このチェックには最適化が存在することに注意してください。[Pornin22] を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar(s):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by outputting the little-endian 57-byte encoding of the Scalar value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
スカラー値のリトルエンディアン 57 バイト エンコードを出力することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a Scalar from a little-endian 57-byte string. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
リトルエンディアンの 57 バイト文字列からスカラーを逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hash (H):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ(H):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHAKE256 with 114 bytes of output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
114 バイトの出力を持つ SHAKE256。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;rho&#34; || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;rho&#34; || m) を計算し、114 バイトのダイジェストをリトルエンディアン整数として解釈し、結果の整数を 2^446 - 1381806680989 を法として減算することによって実装されます。<br>5115352007386748515426880336692474882178609894547503885。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(&#34;SigEd448&#34; || 0 || 0 || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(&#34;SigEd448&#34; || 0 || 0 || m) を計算し、114 バイトのダイジェストをリトルエンディアン整数として解釈し、結果の整数を 2^446 - 1381806680989 を法として減算することによって実装されます。<br>5115352007386748515426880336692474882178609894547503885。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;nonce&#34; || m), interpreting the 114-byte digest as a little-endian integer, and reducing the resulting integer modulo 2^446 - 1381806680989 5115352007386748515426880336692474882178609894547503885.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;nonce&#34; || m) を計算し、114 バイトのダイジェストをリトルエンディアン整数として解釈し、結果の整数を 2^446 - 1381806680989 を法として減算することによって実装されます。<br>5115352007386748515426880336692474882178609894547503885。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H4(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ4(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;msg&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;msg&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H5(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ5(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;com&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;com&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally, H2 would also include a domain separator. However, it is omitted for compatibility with [RFC8032].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、H2 にはドメイン区切り文字も含まれます。ただし、[RFC8032]との互換性のために省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Signature verification is as specified in Section 5.2.7 of [RFC8032] with the constraint that implementations MUST check the group equation [4][z]B = [4]R + [4][c]PK (changed to use the notation in this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名検証は [RFC8032] のセクション 5.2.7 に規定されているとおりですが、実装は群方程式 [4][z]B = [4]R + [4][c]PK (この文書での表記を使用するように変更されました) をチェックしなければならないという制約があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Canonical signature encoding is as specified in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規の署名エンコーディングは付録 A で指定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-4--FROSTP-256-SHA-256">
6.4. FROST(P-256, SHA-256)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. フロスト(P-256、SHA-256)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This ciphersuite uses P-256 for the Group and SHA-256 for the hash function H. The value of the contextString parameter is &#34;FROST-P256-SHA256-v1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この暗号スイートは、グループに P-256 を使用し、ハッシュ関数 H に SHA-256 を使用します。 contextString パラメータの値は「FROST-P256-SHA256-v1」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
P-256 (secp256r1) [x9.62], where Ne = 33 and Ns = 32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
P-256 (secp256r1) [x9.62]、Ne = 33、Ns = 32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Order():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注文（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Return 0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
0xffffffff00000000ffffffffffffffffbce6faada7179e8 4f3b9cac2fc632551 を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identity():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
身元（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
As defined in [x9.62].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[x9.62] で定義されているとおり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1], yielding a 33-byte output. Additionally, this function validates that the input element is not the group identity element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] に従って圧縮された Elliptic-Curve-Point-to-Octet-String メソッドを使用して実装され、33 バイトの出力が生成されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeElement(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要素の逆シリアル化 (バグ):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing public key validation as defined in Section 3.2.2.1 of [SEC1]. This includes checking that the coordinates of the resulting point are in the correct range, that the point is on the curve, and that the point is not the point at infinity. (As noted in the specification, validation of the point order is not required since the cofactor is 1.) If any of these checks fail, deserialization returns an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] に従って圧縮された Octet-String-to-Elliptic-Curve-Point メソッドを使用して 33 バイトの入力文字列を公開鍵に逆シリアル化することを試み、その後、[SEC1] のセクション 3.2.2.1 で定義されている公開鍵検証を実行することによって実装されます。これには、結果の点の座標が正しい範囲内にあること、点が曲線上にあること、および点が無限遠点ではないことのチェックが含まれます。(仕様に記載されているように、余因子が 1 であるため、ポイント順序の検証は必要ありません。) これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar(s):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented using the Field-Element-to-Octet-String conversion according to [SEC1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] に従ってフィールド要素からオクテット文字列への変換を使用して実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] の Octet-String-to-Field-Element を使用して、32 バイト文字列から Scalar を逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hash (H):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ(H):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-256, which has 32 bytes of output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-256。32 バイトの出力があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || &#34;rho&#34;, F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。&#34;rho&#34;、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || &#34;chal&#34;, F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。&#34;chal&#34;、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || &#34;nonce&#34;, F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。&#34;nonce&#34;、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H4(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ4(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;msg&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;msg&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H5(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ5(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;com&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;com&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Signature verification is as specified in Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名検証は付録 B に規定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Canonical signature encoding is as specified in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規の署名エンコーディングは付録 A で指定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-5--FROSTsecp256k1-SHA-256">
6.5. FROST(secp256k1, SHA-256)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. FROST(secp256k1、SHA-256)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This ciphersuite uses secp256k1 for the Group and SHA-256 for the hash function H. The value of the contextString parameter is &#34;FROST-secp256k1-SHA256-v1&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この暗号スイートは、グループに secp256k1 を使用し、ハッシュ関数 H に SHA-256 を使用します。 contextString パラメーターの値は「FROST-secp256k1-SHA256-v1」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グループ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
secp256k1 [SEC2], where Ne = 33 and Ns = 32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
secp256k1 [SEC2]、Ne = 33、Ns = 32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Order():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注文（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03 bbfd25e8cd0364141.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
0xfffffffffffffffffffffffffffffffffebaaedce6af48a03 bbfd25e8cd0364141 を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identity():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
身元（）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
As defined in [SEC2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC2] で定義されている通り。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RandomScalar():
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by returning a uniformly random Scalar in the range [0, G.Order() - 1]. Refer to Appendix D for implementation guidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[0, G.Order() - 1] の範囲の一様にランダムなスカラーを返すことによって実装されます。実装ガイダンスについては、付録 D を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeElement(A):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented using the compressed Elliptic-Curve-Point-to-Octet-String method according to [SEC1], yielding a 33-byte output. Additionally, this function validates that the input element is not the group identity element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] に従って圧縮された Elliptic-Curve-Point-to-Octet-String メソッドを使用して実装され、33 バイトの出力が生成されます。さらに、この関数は、入力要素がグループ ID 要素ではないことを検証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeElement(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
要素の逆シリアル化 (バグ):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a 33-byte input string to a public key using the compressed Octet-String-to-Elliptic-Curve-Point method according to [SEC1] and then performing public key validation as defined in Section 3.2.2.1 of [SEC1]. This includes checking that the coordinates of the resulting point are in the correct range, the point is on the curve, and the point is not the point at infinity. (As noted in the specification, validation of the point order is not required since the cofactor is 1.) If any of these checks fail, deserialization returns an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] に従って圧縮された Octet-String-to-Elliptic-Curve-Point メソッドを使用して 33 バイトの入力文字列を公開鍵に逆シリアル化することを試み、その後、[SEC1] のセクション 3.2.2.1 で定義されている公開鍵検証を実行することによって実装されます。これには、結果の点の座標が正しい範囲内にあること、点が曲線上にあること、および点が無限遠点ではないことを確認することが含まれます。(仕様に記載されているように、余因子が 1 であるため、ポイント順序の検証は必要ありません。) これらのチェックのいずれかが失敗した場合、逆シリアル化はエラーを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar(s):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SerializeScalar:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented using the Field-Element-to-Octet-String conversion according to [SEC1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] に従ってフィールド要素からオクテット文字列への変換を使用して実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeserializeScalar(buf):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by attempting to deserialize a Scalar from a 32-byte string using Octet-String-to-Field-Element from [SEC1]. This function can fail if the input does not represent a Scalar in the range [0, G.Order() - 1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
[SEC1] の Octet-String-to-Field-Element を使用して、32 バイト文字列から Scalar を逆シリアル化することによって実装されます。入力が [0, G.Order() - 1] の範囲のスカラーを表さない場合、この関数は失敗する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hash (H):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュ(H):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-256, which has 32 bytes of output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
SHA-256。32 バイトの出力があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H1(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || &#34;rho&#34;, F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。&#34;rho&#34;、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H2(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || &#34;chal&#34;, F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。&#34;chal&#34;、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H3(メートル):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented as hash_to_field(m, 1) (see [HASH-TO-CURVE], Section 5.2) using expand_message_xmd with SHA-256 with parameters DST = contextString || &#34;nonce&#34;, F set to the Scalar field, p set to G.Order(), m = 1, and L = 48.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
DST = contextString || パラメータを持つ SHA-256 で Expand_message_xmd を使用して、 hash_to_field(m, 1) ([HASH-TO-CURVE]、セクション 5.2 を参照) として実装されます。&#34;nonce&#34;、F は Scalar フィールドに設定、p は G.Order() に設定、m = 1、L = 48。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H4(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ4(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;msg&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;msg&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
H5(m):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
高さ5(m):
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Implemented by computing H(contextString || &#34;com&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
H(contextString || &#34;com&#34; || m) を計算することによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Signature verification is as specified in Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名検証は付録 B に規定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Canonical signature encoding is as specified in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正規の署名エンコーディングは付録 A で指定されているとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="6-6--Ciphersuite-Requirements">
6.6. Ciphersuite Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. 暗号スイートの要件
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future documents that introduce new ciphersuites MUST adhere to the following requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい暗号スイートを導入する将来の文書は、次の要件に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1. H1, H2, and H3 all have output distributions that are close to (indistinguishable from) the uniform distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1. H1、H2、および H3 はすべて、一様分布に近い (区別できない) 出力分布を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2. All hash functions MUST be domain-separated with a per-suite context string. Note that the FROST(Ed25519, SHA-512) ciphersuite does not adhere to this requirement for H2 alone in order to maintain compatibility with [RFC8032].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2. すべてのハッシュ関数は、スイートごとのコンテキスト文字列を使用してドメインで区切る必要があります。FROST(Ed25519, SHA-512) 暗号スイートは、[RFC8032] との互換性を維持するために、H2 単独についてはこの要件に準拠していないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
3. The group MUST be of prime order and all deserialization functions MUST output elements that belong to their respective sets of Elements or Scalars, or else fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
3. グループは素数順序でなければならず、すべての逆シリアル化関数はそれぞれの要素またはスカラーのセットに属する要素を出力しなければなりません。そうでない場合は失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
4. The canonical signature encoding details are clearly specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
4. 正規の署名エンコーディングの詳細は明確に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7--Security-Considerations">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. セキュリティに関する考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A security analysis of FROST is documented in [FROST20] and [StrongerSec22]. At a high level, FROST provides security against Existential Unforgeability Under Chosen Message Attacks (EUF-CMA) as defined in [StrongerSec22]. To satisfy this requirement, the ciphersuite needs to adhere to the requirements in Section 6.6 and the following assumptions must hold.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST のセキュリティ分析は [FROST20] および [StrongerSec22] に文書化されています。高レベルでは、FROST は [StrongerSec22] で定義されている Existential Unforgeability Under Chosen Message Attacks (EUF-CMA) に対するセキュリティを提供します。この要件を満たすには、暗号スイートはセクション 6.6 の要件に準拠する必要があり、次の前提が当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The signer key shares are generated and distributed securely, e.g., via a trusted dealer that performs key generation (see Appendix C.2) or through a distributed key generation protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 署名者の鍵共有は、鍵生成を実行する信頼できるディーラー (付録 C.2 を参照) または分散鍵生成プロトコルなどを通じて、安全に生成および配布されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The Coordinator and at most (MIN_PARTICIPANTS-1) participants may be corrupted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* コーディネーターと最大 (MIN_PARTICIPANTS-1) 人の参加者が破損している可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the Coordinator is not trusted with any private information, and communication at the time of signing can be performed over a public channel as long as it is authenticated and reliable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コーディネーターはいかなる個人情報も信頼されておらず、認証され信頼できる限り、署名時の通信はパブリック チャネル経由で実行できることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST provides security against DoS attacks under the following assumptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は、次の前提のもとで DoS 攻撃に対するセキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The Coordinator does not perform a DoS attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* コーディネーターは DoS 攻撃を実行しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The Coordinator identifies misbehaving participants such that they can be removed from future invocations of FROST. The Coordinator may also abort upon detecting a misbehaving participant to ensure that invalid signatures are not produced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* コーディネーターは、不正行為を行っている参加者を特定し、今後の FROST の呼び出しから削除できるようにします。コーディネーターは、無効な署名が生成されないようにするために、不正行為を行っている参加者を検出すると中断することもあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST does not aim to achieve the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST は次の目標を達成することを目的としていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Post-quantum security. FROST, like plain Schnorr signatures, requires the hardness of the Discrete Logarithm Problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ポスト量子セキュリティ。FROST は、単純な Schnorr 署名と同様に、離散対数問題の難易度を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Robustness. Preventing DoS attacks against misbehaving participants requires the Coordinator to identify and act on misbehaving participants; see Section 5.4 for more information. While FROST does not provide robustness, [ROAST] is a wrapper protocol around FROST that does.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 堅牢性。不正行為を行う参加者に対する DoS 攻撃を防ぐには、コーディネーターが不正行為を行う参加者を特定し、対処する必要があります。詳細については、セクション 5.4 を参照してください。FROST は堅牢性を提供しませんが、[ROAST] は堅牢性を提供する FROST のラッパー プロトコルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Downgrade prevention. All participants in the protocol are assumed to agree on which algorithms to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ダウングレードの防止。プロトコルの参加者全員が、使用するアルゴリズムに同意するものと想定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Metadata protection. If protection for metadata is desired, a higher-level communication channel can be used to facilitate key generation and signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* メタデータの保護。メタデータの保護が必要な場合は、より高いレベルの通信チャネルを使用してキーの生成と署名を容易にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of this section documents issues particular to implementations or deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの残りの部分では、実装または展開に特有の問題について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-1--Side-Channel-Mitigations">
7.1. Side-Channel Mitigations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. サイドチャネルの軽減策
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several routines process secret values (nonces, signing keys / shares), and depending on the implementation and deployment environment, mitigating side-channels may be pertinent. Mitigating these side-channels requires implementing G.ScalarMult(), G.ScalarBaseMult(), G.SerializeScalar(), and G.DeserializeScalar() in constant (value-independent) time. The various ciphersuites lend themselves differently to specific implementation techniques and ease of achieving side-channel resistance, though ultimately avoiding value-dependent computation or branching is the goal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのルーチンはシークレット値 (ノンス、署名キー/共有) を処理し、実装および展開環境によっては、サイドチャネルの軽減が適切になる場合があります。これらのサイドチャネルを軽減するには、G.ScalarMult()、G.ScalarBaseMult()、G.SerializeScalar()、および G.DeserializeScalar() を一定の (値に依存しない) 時間で実装する必要があります。さまざまな暗号スイートは、特定の実装技術やサイドチャネル耐性の達成の容易さにそれぞれ異なった形で適していますが、最終的には値に依存する計算や分岐を回避することが目標です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-2--Optimizations">
7.2. Optimizations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 最適化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[StrongerSec22] presented an optimization to FROST that reduces the total number of Scalar multiplications from linear in the number of signing participants to a constant. However, as described in [StrongerSec22], this optimization removes the guarantee that the set of signer participants that started round one of the protocol is the same set of signing participants that produced the signature output by round two. As such, the optimization is NOT RECOMMENDED and is not covered in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[StrongerSec22] は、スカラー乗算の総数を署名参加者の数の線形から定数に減らす FROST の最適化を提示しました。ただし、[StrongerSec22] で説明されているように、この最適化により、プロトコルのラウンド 1 で開始した署名参加者のセットが、ラウンド 2 で署名出力を生成した署名参加者のセットと同じであるという保証が削除されます。そのため、最適化は推奨されず、このドキュメントでは取り上げません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-3--Nonce-Reuse-Attacks">
7.3. Nonce Reuse Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. ノンス再利用攻撃
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 4.1 describes the procedure that participants use to produce nonces during the first round of signing. The randomness produced in this procedure MUST be sampled uniformly at random. The resulting nonces produced via nonce_generate are indistinguishable from values sampled uniformly at random. This requirement is necessary to avoid replay attacks initiated by other participants that allow for a complete key-recovery attack. The Coordinator MAY further hedge against nonce reuse attacks by tracking participant nonce commitments used for a given group key at the cost of additional state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション 4.1 では、最初の署名ラウンドで参加者が nonce を生成するために使用する手順について説明します。この手順で生成されるランダム性は、均一にランダムにサンプリングされなければなりません。nonce_generate によって生成されたノンスは、均一にランダムにサンプリングされた値と区別できません。この要件は、完全なキー回復攻撃を可能にする他の参加者によって開始されるリプレイ攻撃を回避するために必要です。コーディネーターは、追加の状態を犠牲にして、特定のグループ鍵に使用される参加者のノンスコミットメントを追跡することによって、ノンス再利用攻撃をさらに回避してもよい(MAY)。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-4--Protocol-Failures">
7.4. Protocol Failures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. プロトコルの失敗
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We do not specify what implementations should do when the protocol fails other than requiring the protocol to abort. Examples of viable failures include when a verification check returns invalid or the underlying transport failed to deliver the required messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルの中止を要求すること以外に、プロトコルが失敗したときに実装が何をすべきかについては指定していません。実行可能な失敗の例には、検証チェックで無効が返された場合や、基礎となるトランスポートが必要なメッセージの配信に失敗した場合などがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-5--Removing-the-Coordinator-Role">
7.5. Removing the Coordinator Role
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. コーディネーターの役割の削除
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some settings, it may be desirable to omit the role of the Coordinator entirely. Doing so does not change the security implications of FROST; instead, it simply requires each participant to communicate with all other participants. We loosely describe how to perform FROST signing among participants without this coordinator role. We assume that every participant receives a message to be signed from an external source as input prior to performing the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定によっては、コーディネーターの役割を完全に省略することが望ましい場合があります。そうしても、FROST のセキュリティへの影響は変わりません。代わりに、各参加者が他のすべての参加者と通信する必要があるだけです。このコーディネーターの役割を持たずに参加者間で FROST 署名を実行する方法を大まかに説明します。すべての参加者は、プロトコルを実行する前に、外部ソースから署名されるメッセージを入力として受信すると想定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every participant begins by performing commit() as is done in the setting where a Coordinator is used. However, instead of sending the commitment to the Coordinator, every participant will publish this commitment to every other participant. In the second round, participants will already have sufficient information to perform signing, and they will directly perform sign(). All participants will then publish their signature shares to one another. After having received all signature shares from all other participants, each participant will then perform verify_signature_share and then aggregate directly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての参加者は、コーディネーターが使用される設定で行われるように commit() を実行することから始まります。ただし、コミットメントをコーディネーターに送信する代わりに、すべての参加者はこのコミットメントを他のすべての参加者に公開します。2 番目のラウンドでは、参加者は署名を実行するのに十分な情報をすでに持っているため、sign() を直接実行します。その後、すべての参加者が自分の署名共有を相互に公開します。他のすべての参加者からすべての署名共有を受信した後、各参加者は verify_signature_share を実行し、直接集約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirements for the underlying network channel remain the same in the setting where all participants play the role of the Coordinator, in that all exchanged messages are public and the channel must be reliable. However, in the setting where a player attempts to split the view of all other players by sending disjoint values to a subset of players, the signing operation will output an invalid signature. To avoid this DoS, implementations may wish to define a mechanism where messages are authenticated so that cheating players can be identified and excluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基礎となるネットワーク チャネルの要件は、すべての参加者がコーディネーターの役割を果たす設定でも同じであり、交換されるメッセージはすべてパブリックであり、チャネルが信頼できる必要があります。ただし、プレーヤーがプレーヤーのサブセットに素の値を送信して他のすべてのプレーヤーのビューを分割しようとする設定では、署名操作により無効な署名が出力されます。この DoS を回避するために、実装では、不正行為を行ったプレイヤーを特定して除外できるように、メッセージが認証されるメカニズムを定義することが必要になる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-6--Input-Message-Hashing">
7.6. Input Message Hashing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6. 入力メッセージのハッシュ化
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST signatures do not pre-hash message inputs. This means that the entire message must be known in advance of invoking the signing protocol. Applications can apply pre-hashing in settings where storing the full message is prohibitively expensive. In such cases, pre-hashing MUST use a collision-resistant hash function with a security level commensurate with the security inherent to the ciphersuite chosen. For applications that choose to apply pre-hashing, it is RECOMMENDED that they use the hash function (H) associated with the chosen ciphersuite in a manner similar to how H4 is defined. In particular, a different prefix SHOULD be used to differentiate this pre-hash from H4. For example, if a fictional protocol Quux decided to pre-hash its input messages, one possible way to do so is via H(contextString || &#34;Quux-pre-hash&#34; || m).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FROST 署名はメッセージ入力を事前ハッシュしません。これは、署名プロトコルを呼び出す前にメッセージ全体を知っておく必要があることを意味します。アプリケーションは、完全なメッセージの保存に法外なコストがかかる設定で事前ハッシュを適用できます。このような場合、事前ハッシュでは、選択した暗号スイートに固有のセキュリティに見合ったセキュリティ レベルを持つ衝突耐性のあるハッシュ関数を使用しなければなりません (MUST)。事前ハッシュの適用を選択したアプリケーションの場合、H4 の定義方法と同様の方法で、選択した暗号スイートに関連付けられたハッシュ関数 (H) を使用することが推奨されます。特に、このプレハッシュを H4 と区別するには、異なるプレフィックスを使用する必要があります (SHOULD)。たとえば、架空のプロトコル Quux が入力メッセージを事前ハッシュすることを決定した場合、考えられる方法の 1 つは H(contextString || &#34;Quux-pre-hash&#34; || m) を使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="7-7--Input-Message-Validation">
7.7. Input Message Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7. 入力メッセージの検証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message validation varies by application. For example, some applications may require that participants only process messages of a certain structure. In digital currency applications, wherein multiple participants may collectively sign a transaction, it is reasonable to require each participant to check that the input message is a syntactically valid transaction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージの検証はアプリケーションによって異なります。たとえば、アプリケーションによっては、参加者が特定の構造のメッセージのみを処理することを要求する場合があります。デジタル通貨アプリケーションでは、複数の参加者が集合的にトランザクションに署名する可能性があるため、各参加者に入力メッセージが構文的に有効なトランザクションであることを確認するよう要求するのが合理的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As another example, some applications may require that participants only process messages with permitted content according to some policy. In digital currency applications, this might mean that a transaction being signed is allowed and intended by the relevant stakeholders. Another instance of this type of message validation is in the context of [TLS], wherein implementations may use threshold signing protocols to produce signatures of transcript hashes. In this setting, signing participants might require the raw TLS handshake messages to validate before computing the transcript hash that is signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の例として、一部のアプリケーションでは、参加者が何らかのポリシーに従って許可されたコンテンツを含むメッセージのみを処理することを要求する場合があります。デジタル通貨アプリケーションでは、これは、署名されるトランザクションが関連する利害関係者によって許可され、意図されていることを意味する場合があります。このタイプのメッセージ検証の別の例は [TLS] のコンテキストにあり、実装ではしきい値署名プロトコルを使用してトランスクリプト ハッシュの署名を生成できます。この設定では、署名参加者は、署名されたトランスクリプト ハッシュを計算する前に、生の TLS ハンドシェイク メッセージを検証する必要がある場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, input message validation is an application-specific consideration that varies based on the use case and threat model. However, it is RECOMMENDED that applications take additional precautions and validate inputs so that participants do not operate as signing oracles for arbitrary messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、入力メッセージの検証はアプリケーション固有の考慮事項であり、ユースケースと脅威モデルに応じて異なります。ただし、参加者が任意のメッセージの署名オラクルとして動作しないように、アプリケーションは追加の予防措置を講じ、入力を検証することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="8--IANA-Considerations">
8. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANAの考慮事項
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書には IANA のアクションはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9--References">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 参考文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-1--Normative-References">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 引用文献
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [HASH-TO-CURVE]
              Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,
              and C. A. Wood, &#34;Hashing to Elliptic Curves&#34;, RFC 9380,
              DOI 10.17487/RFC9380, August 2023,
              &lt;https://www.rfc-editor.org/info/rfc9380&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC2119]  Bradner, S., &#34;Key words for use in RFCs to Indicate
              Requirement Levels&#34;, BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8032]  Josefsson, S. and I. Liusvaara, &#34;Edwards-Curve Digital
              Signature Algorithm (EdDSA)&#34;, RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              &lt;https://www.rfc-editor.org/info/rfc8032&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC8174]  Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RISTRETTO]
              de Valence, H., Grigg, J., Hamburg, M., Lovecruft, I.,
              Tankersley, G., and F. Valsorda, &#34;The ristretto255 and
              decaf448 Groups&#34;, RFC 9496, DOI 10.17487/RFC9496, December
              2023, &lt;https://www.rfc-editor.org/info/rfc9496&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [SEC1]     Standards for Efficient Cryptography, &#34;SEC 1: Elliptic
              Curve Cryptography&#34;, Version 2.0, May 2009,
              &lt;https://secg.org/sec1-v2.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [SEC2]     Standards for Efficient Cryptography, &#34;SEC 2: Recommended
              Elliptic Curve Domain Parameters&#34;, Version 2.0, January
              2010, &lt;https://secg.org/sec2-v2.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [x9.62]    American National Standards Institute, &#34;Public Key
              Cryptography for the Financial Services Industry: the
              Elliptic Curve Digital Signature Algorithm (ECDSA)&#34;,
              ANSI X9.62-2005, November 2005.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="9-2--Informative-References">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 参考引用
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [FeldmanSecretSharing]
              Feldman, P., &#34;A practical scheme for non-interactive
              verifiable secret sharing&#34;, IEEE, 28th Annual Symposium on
              Foundations of Computer Science (sfcs 1987),
              DOI 10.1109/sfcs.1987.4, October 1987,
              &lt;https://doi.org/10.1109/sfcs.1987.4&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [FROST20]  Komlo, C. and I. Goldberg, &#34;FROST: Flexible Round-
              Optimized Schnorr Threshold Signatures&#34;, December 2020,
              &lt;https://eprint.iacr.org/2020/852.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [MultExp]  Connolly, D. and C. Gouvea, &#34;Speeding up FROST with multi-
              scalar multiplication&#34;, June 2023, &lt;https://zfnd.org/
              speeding-up-frost-with-multi-scalar-multiplication/&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [Pornin22] Pornin, T., &#34;Point-Halving and Subgroup Membership in
              Twisted Edwards Curves&#34;, September 2022,
              &lt;https://eprint.iacr.org/2022/1164.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              &lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, &#34;Elliptic Curves
              for Security&#34;, RFC 7748, DOI 10.17487/RFC7748, January
              2016, &lt;https://www.rfc-editor.org/info/rfc7748&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [ROAST]    Ruffing, T., Ronge, V., Jin, E., Schneider-Bensch, J., and
              D. Schröder, &#34;ROAST: Robust Asynchronous Schnorr Threshold
              Signatures&#34;, Paper 2022/550, DOI 10.1145/3548606, November
              2022, &lt;https://eprint.iacr.org/2022/550&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [ShamirSecretSharing]
              Shamir, A., &#34;How to share a secret&#34;, Association for
              Computing Machinery (ACM), Communications of the ACM, Vol.
              22, Issue 11, pp. 612-613, DOI 10.1145/359168.359176,
              November 1979, &lt;https://doi.org/10.1145/359168.359176&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [StrongerSec22]
              Bellare, M., Crites, E., Komlo, C., Maller, M., Tessaro,
              S., and C. Zhu, &#34;Better than Advertised Security for Non-
              interactive Threshold Signatures&#34;,
              DOI 10.1007/978-3-031-15985-5_18, August 2022,
              &lt;https://crypto.iacr.org/2022/
              papers/538806_1_En_18_Chapter_OnlinePDF.pdf&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   [TLS]      Rescorla, E., &#34;The Transport Layer Security (TLS) Protocol
              Version 1.3&#34;, RFC 8446, DOI 10.17487/RFC8446, August 2018,
              &lt;https://www.rfc-editor.org/info/rfc8446&gt;.
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-A--Schnorr-Signature-Encoding">
Appendix A. Schnorr Signature Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録A. Schnorr 署名エンコーディング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes one possible canonical encoding of FROST signatures. Using notation from Section 3 of [TLS], the encoding of a FROST signature (R, z) is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、FROST 署名の可能な正規エンコーディングの 1 つについて説明します。[TLS] のセクション 3 の表記を使用すると、FROST 署名 (R, z) のエンコーディングは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
       opaque R_encoded[Ne];
       opaque z_encoded[Ns];
     } Signature;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where Signature.R_encoded is G.SerializeElement(R), Signature.z_encoded is G.SerializeScalar(z), and G is determined by ciphersuite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、Signature.R_encoded は G.SerializeElement(R)、Signature.z_encoded は G.SerializeScalar(z)、G は暗号スイートによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-B--Schnorr-Signature-Generation-and-Verification-for-Prime--Order-Groups">
Appendix B. Schnorr Signature Generation and Verification for Prime- Order Groups
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録B. Prime-Order グループの Schnorr 署名の生成と検証
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains descriptions of functions for generating and verifying Schnorr signatures. It is included to complement the routines present in [RFC8032] for prime-order groups, including ristretto255, P-256, and secp256k1. The functions for generating and verifying signatures are prime_order_sign and prime_order_verify, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、Schnorr 署名を生成および検証するための関数について説明します。これは、ristretto255、P-256、secp256k1 などの素数順序グループ用の [RFC8032] に存在するルーチンを補完するために含まれています。署名を生成および検証する関数は、それぞれ prime_order_sign および prime_order_verify です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function prime_order_sign produces a Schnorr signature over a message given a full secret signing key as input (as opposed to a key share).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数 prime_order_sign は、(鍵共有ではなく) 入力として完全な秘密署名鍵が与えられたメッセージに対して Schnorr 署名を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - msg, message to sign, a byte string.
   - sk, secret key, a Scalar.

   Outputs:
   - (R, z), a Schnorr signature consisting of an Element R and
     Scalar z.

   def prime_order_sign(msg, sk):
     r = G.RandomScalar()
     R = G.ScalarBaseMult(r)
     PK = G.ScalarBaseMult(sk)
     comm_enc = G.SerializeElement(R)
     pk_enc = G.SerializeElement(PK)
     challenge_input = comm_enc || pk_enc || msg
     c = H2(challenge_input)
     z = r + (c * sk) // Scalar addition and multiplication
     return (R, z)
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function prime_order_verify verifies Schnorr signatures with validated inputs. Specifically, it assumes that the signature R component and public key belong to the prime-order group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数 prime_order_verify は、検証された入力を使用して Schnorr 署名を検証します。具体的には、署名 R コンポーネントと公開鍵が素数群に属すると仮定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - msg, signed message, a byte string.
   - sig, a tuple (R, z) output from signature generation.
   - PK, public key, an Element.

   Outputs:
   - True if signature is valid, and False otherwise.

   def prime_order_verify(msg, sig = (R, z), PK):
     comm_enc = G.SerializeElement(R)
     pk_enc = G.SerializeElement(PK)
     challenge_input = comm_enc || pk_enc || msg
     c = H2(challenge_input)

     l = G.ScalarBaseMult(z)
     r = R + G.ScalarMult(PK, c)
     return l == r
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-C--Trusted-Dealer-Key-Generation">
Appendix C. Trusted Dealer Key Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録C. 信頼できるディーラーのキーの生成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible key generation mechanism is to depend on a trusted dealer, wherein the dealer generates a group secret s uniformly at random and uses Shamir and Verifiable Secret Sharing [ShamirSecretSharing] as described in Appendices C.1 and C.2 to create secret shares of s, denoted as s_i for i = 1, ..., MAX_PARTICIPANTS, to be sent to all MAX_PARTICIPANTS participants. This operation is specified in the trusted_dealer_keygen algorithm. The mathematical relation between the secret key s and the MAX_PARTICIPANTS secret shares is formalized in the secret_share_combine(shares) algorithm, defined in Appendix C.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考えられる鍵生成メカニズムの 1 つは、信頼できるディーラーに依存することです。この場合、ディーラーはグループ秘密 s を均一にランダムに生成し、付録 C.1 および C.2 で説明されているようにシャミアおよび検証可能な秘密共有 [ShamirSecretSharing] を使用して、i = 1, ..., MAX_PARTICIPANTS の場合は s_i として示される s の秘密共有を作成し、すべての MAX_PARTICIPANTS 参加者に送信します。この操作は、trusted_dealer_keygen アルゴリズムで指定されます。秘密鍵 s と MAX_PARTICIPANTS 秘密共有の間の数学的関係は、付録 C.1 で定義されている Secret_share_combine(shares) アルゴリズムで形式化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dealer that performs trusted_dealer_keygen is trusted to 1) generate good randomness, 2) delete secret values after distributing shares to each participant, and 3) keep secret values confidential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trusted_dealer_keygen を実行するディーラーは、1) 適切なランダム性を生成し、2) 各参加者にシェアを配布した後にシークレット値を削除し、3) シークレット値を機密に保つことを信頼されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - secret_key, a group secret, a Scalar, that MUST be derived from at
     least Ns bytes of entropy.
   - MAX_PARTICIPANTS, the number of shares to generate, an integer.
   - MIN_PARTICIPANTS, the threshold of the secret sharing scheme,
     an integer.

   Outputs:
   - participant_private_keys, MAX_PARTICIPANTS shares of the secret
     key s, each a tuple consisting of the participant identifier
     (a NonZeroScalar) and the key share (a Scalar).
   - group_public_key, public key corresponding to the group signing
     key, an Element.
   - vss_commitment, a vector commitment of Elements in G, to each of
     the coefficients in the polynomial defined by secret_key_shares and
     whose first element is G.ScalarBaseMult(s).

   def trusted_dealer_keygen(
           secret_key, MAX_PARTICIPANTS, MIN_PARTICIPANTS):
     # Generate random coefficients for the polynomial
     coefficients = []
     for i in range(0, MIN_PARTICIPANTS - 1):
       coefficients.append(G.RandomScalar())
     participant_private_keys, coefficients = secret_share_shard(
         secret_key, coefficients, MAX_PARTICIPANTS)
     vss_commitment = vss_commit(coefficients):
     return participant_private_keys, vss_commitment[0], vss_commitment
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is assumed that the dealer then sends one secret key share to each of the NUM_PARTICIPANTS participants, along with vss_commitment. After receiving their secret key share and vss_commitment, participants MUST abort if they do not have the same view of vss_commitment. The dealer can use a secure broadcast channel to ensure each participant has a consistent view of this commitment. Furthermore, each participant MUST perform vss_verify(secret_key_share_i, vss_commitment) and abort if the check fails. The trusted dealer MUST delete the secret_key and secret_key_shares upon completion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、ディーラーは、vss_commitment とともに、NUM_PARTICIPANTS 人の参加者のそれぞれに 1 つの秘密鍵共有を送信すると想定されます。秘密鍵の共有と vss_commitment を受け取った後、vss_commitment について同じビューを持っていない場合、参加者は中止しなければなりません (MUST)。ディーラーは安全なブロードキャスト チャネルを使用して、各参加者がこのコミットメントについて一貫した見解を確実に得られるようにすることができます。さらに、各参加者は vss_verify(secret_key_share_i, vss_commitment) を実行し、チェックが失敗した場合は中止しなければなりません (MUST)。信頼できるディーラーは、完了時に Secret_key と Secret_key_shares を削除しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of this method for key generation requires a mutually authenticated secure channel between the dealer and participants to send secret key shares, wherein the channel provides confidentiality and integrity. Mutually authenticated TLS is one possible deployment option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵生成にこの方法を使用するには、秘密鍵共有を送信するためにディーラーと参加者の間で相互認証された安全なチャネルが必要です。このチャネルは機密性と完全性を提供します。相互認証された TLS は、可能な展開オプションの 1 つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-1--Shamir-Secret-Sharing">
C.1. Shamir Secret Sharing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.1. シャミールの秘密の共有
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Shamir secret sharing, a dealer distributes a secret Scalar s to n participants in such a way that any cooperating subset of at least MIN_PARTICIPANTS participants can recover the secret. There are two basic steps in this scheme: 1) splitting a secret into multiple shares and 2) combining shares to reveal the resulting secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Shamir 秘密共有では、ディーラーは、少なくとも MIN_PARTICIPANTS 参加者の協力するサブセットが秘密を回復できるような方法で、秘密のスカラーを n 人の参加者に配布します。このスキームには 2 つの基本的な手順があります。1) シークレットを複数のシェアに分割し、2) シェアを結合して結果のシークレットを明らかにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This secret sharing scheme works over any field F. In this specification, F is the Scalar field of the prime-order group G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この秘密分散スキームは、任意の体 F に対して機能します。この仕様では、F は素数次数群 G のスカラー体です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure for splitting a secret into shares is as follows. The algorithm polynomial_evaluate is defined in Appendix C.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シークレットを株式に分割する手順は次のとおりです。アルゴリズム Polynomial_evaluate は付録 C.1.1 で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - s, secret value to be shared, a Scalar.
   - coefficients, an array of size MIN_PARTICIPANTS - 1 with randomly
     generated Scalars, not including the 0th coefficient of the
     polynomial.
   - MAX_PARTICIPANTS, the number of shares to generate, an integer less
     than the group order.

   Outputs:
   - secret_key_shares, A list of MAX_PARTICIPANTS number of secret
     shares, each a tuple consisting of the participant identifier
     (a NonZeroScalar) and the key share (a Scalar).
   - coefficients, a vector of MIN_PARTICIPANTS coefficients which
     uniquely determine a polynomial f.

   def secret_share_shard(s, coefficients, MAX_PARTICIPANTS):
     # Prepend the secret to the coefficients
     coefficients = [s] + coefficients

     # Evaluate the polynomial for each point x=1,...,n
     secret_key_shares = []
     for x_i in range(1, MAX_PARTICIPANTS + 1):
       y_i = polynomial_evaluate(Scalar(x_i), coefficients)
       secret_key_share_i = (x_i, y_i)
       secret_key_shares.append(secret_key_share_i)
     return secret_key_shares, coefficients
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let points be the output of this function. The i-th element in points is the share for the i-th participant, which is the randomly generated polynomial evaluated at coordinate i. We denote a secret share as the tuple (i, points[i]) and the list of these shares as shares. i MUST never equal 0; recall that f(0) = s, where f is the polynomial defined in a Shamir secret sharing operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポイントをこの関数の出力とします。ポイント単位の i 番目の要素は、i 番目の参加者のシェアであり、座標 i で評価されるランダムに生成された多項式です。秘密共有をタプル (i, Points[i]) として表し、これらの共有のリストを共有として表します。i は決して 0 になってはなりません。f(0) = s であることを思い出してください。ここで、f はシャミア秘密分散演算で定義された多項式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure for combining a shares list of length MIN_PARTICIPANTS to recover the secret s is as follows; the algorithm polynomial_interpolate_constant is defined in Appendix C.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ MIN_PARTICIPANTS の共有リストを結合してシークレット を回復する手順は次のとおりです。アルゴリズム Polynomial_interpolate_constant は付録 C.1.1 で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - shares, a list of at minimum MIN_PARTICIPANTS secret shares, each a
     tuple (i, f(i)) where i and f(i) are Scalars.

   Outputs:
   - s, the resulting secret that was previously split into shares,
     a Scalar.

   Errors:
   - &#34;invalid parameters&#34;, if fewer than MIN_PARTICIPANTS input shares
     are provided.

   def secret_share_combine(shares):
     if len(shares) &lt; MIN_PARTICIPANTS:
       raise &#34;invalid parameters&#34;
     s = polynomial_interpolate_constant(shares)
     return s
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-1-1--Additional-Polynomial-Operations">
C.1.1. Additional Polynomial Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.1.1. 追加の多項式演算
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes two functions. One function, denoted as polynomial_evaluate, is for evaluating a polynomial f(x) at a particular point x using Horner&#39;s method, i.e., computing y = f(x). The other function, polynomial_interpolate_constant, is for recovering the constant term of an interpolating polynomial defined by a set of points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは 2 つの機能について説明します。Polynomial_evaluate として示される 1 つの関数は、ホーナー法を使用して特定の点 x における多項式 f(x) を評価するためのものです。つまり、y = f(x) を計算します。もう 1 つの関数、polynomial_interpolate_constant は、点のセットによって定義される補間多項式の定数項を回復するためのものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function polynomial_evaluate is defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数polynomial_evaluateは次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - x, input at which to evaluate the polynomial, a Scalar
   - coeffs, the polynomial coefficients, a list of Scalars

   Outputs: Scalar result of the polynomial evaluated at input x

   def polynomial_evaluate(x, coeffs):
     value = Scalar(0)
     for coeff in reverse(coeffs):
       value *= x
       value += coeff
     return value
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function polynomial_interpolate_constant is defined as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関数polynomial_interpolate_constantは次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - points, a set of t points with distinct x coordinates on
     a polynomial f, each a tuple of two Scalar values representing the
     x and y coordinates.

   Outputs:
   - f_zero, the constant term of f, i.e., f(0), a Scalar.

   def polynomial_interpolate_constant(points):
     x_coords = []
     for (x, y) in points:
       x_coords.append(x)

     f_zero = Scalar(0)
     for (x, y) in points:
       delta = y * derive_interpolating_value(x_coords, x)
       f_zero += delta

     return f_zero
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="C-2--Verifiable-Secret-Sharing">
C.2. Verifiable Secret Sharing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2. 検証可能な秘密の共有
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feldman&#39;s Verifiable Secret Sharing (VSS) [FeldmanSecretSharing] builds upon Shamir secret sharing, adding a verification step to demonstrate the consistency of a participant&#39;s share with a public commitment to the polynomial f for which the secret s is the constant term. This check ensures that all participants have a point (their share) on the same polynomial, ensuring that they can reconstruct the correct secret later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Feldman の Verifiable Secret Sharing (VSS) [FeldmanSecretSharing] は Shamir 秘密共有に基づいて構築されており、秘密 s が定数項である多項式 f に対する参加者の共有と公開コミットメントとの一貫性を実証するための検証ステップが追加されています。このチェックにより、すべての参加者が同じ多項式上の点 (共有) を持っていることが保証され、後で正しい秘密を再構築できることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure for committing to a polynomial f of degree at most MIN_PARTICIPANTS-1 is as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大 MIN_PARTICIPANTS-1 次の多項式 f にコミットする手順は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - coeffs, a vector of the MIN_PARTICIPANTS coefficients that
     uniquely determine a polynomial f.

   Outputs:
   - vss_commitment, a vector commitment to each of the coefficients in
     coeffs, where each item of the vector commitment is an Element.

   def vss_commit(coeffs):
     vss_commitment = []
     for coeff in coeffs:
       A_i = G.ScalarBaseMult(coeff)
       vss_commitment.append(A_i)
     return vss_commitment
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedure for verification of a participant&#39;s share is as follows. If vss_verify fails, the participant MUST abort the protocol, and the failure should be investigated out of band.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加者の取り分を確認する手順は次のとおりです。vss_verify が失敗した場合、参加者はプロトコルを中止しなければならず、失敗は帯域外で調査される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - share_i: A tuple of the form (i, sk_i), where i indicates the
     participant identifier (a NonZeroScalar), and sk_i the
     participant&#39;s secret key, a secret share of the constant term of f,
     where sk_i is a Scalar.
   - vss_commitment, a VSS commitment to a secret polynomial f, a vector
     commitment to each of the coefficients in coeffs, where each
     element of the vector commitment is an Element.

   Outputs:
   - True if sk_i is valid, and False otherwise.

   def vss_verify(share_i, vss_commitment)
     (i, sk_i) = share_i
     S_i = G.ScalarBaseMult(sk_i)
     S_i&#39; = G.Identity()
     for j in range(0, MIN_PARTICIPANTS):
       S_i&#39; += G.ScalarMult(vss_commitment[j], pow(i, j))
     return S_i == S_i&#39;
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now define how the Coordinator and participants can derive group info, which is an input into the FROST signing protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、コーディネーターと参加者が FROST 署名プロトコルへの入力であるグループ情報を取得する方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Inputs:
   - MAX_PARTICIPANTS, the number of shares to generate, an integer.
   - MIN_PARTICIPANTS, the threshold of the secret sharing scheme,
     an integer.
   - vss_commitment, a VSS commitment to a secret polynomial f, a vector
     commitment to each of the coefficients in coeffs, where each
     element of the vector commitment is an Element.

   Outputs:
   - PK, the public key representing the group, an Element.
   - participant_public_keys, a list of MAX_PARTICIPANTS public keys
     PK_i for i=1,...,MAX_PARTICIPANTS, where each PK_i is the public
     key, an Element, for participant i.

   def derive_group_info(MAX_PARTICIPANTS, MIN_PARTICIPANTS,
    vss_commitment):
     PK = vss_commitment[0]
     participant_public_keys = []
     for i in range(1, MAX_PARTICIPANTS+1):
       PK_i = G.Identity()
       for j in range(0, MIN_PARTICIPANTS):
         PK_i += G.ScalarMult(vss_commitment[j], pow(i, j))
       participant_public_keys.append(PK_i)
     return PK, participant_public_keys
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-D--Random-Scalar-Generation">
Appendix D. Random Scalar Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録D. ランダムなスカラー生成
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two popular algorithms for generating a random integer uniformly distributed in the range [0, G.Order() -1] are described in the sections that follow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[0, G.Order() -1] の範囲に均一に分布するランダムな整数を生成するための 2 つの一般的なアルゴリズムについて、以降のセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="D-1--Rejection-Sampling">
D.1. Rejection Sampling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.1. 拒否サンプリング
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generate a random byte array with Ns bytes and attempt to map to a Scalar by calling DeserializeScalar in constant time. If it succeeds, return the result. If it fails, try again with another random byte array, until the procedure succeeds. Failure to implement DeserializeScalar in constant time can leak information about the underlying corresponding Scalar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ns バイトのランダムなバイト配列を生成し、定数時間で DeserializeScalar を呼び出して Scalar へのマッピングを試みます。成功した場合は結果を返します。失敗した場合は、手順が成功するまで、別のランダムなバイト配列を使用して再試行します。DeserializeScalar を一定時間内に実装できないと、基礎となる対応する Scalar に関する情報が漏洩する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an optimization, if the group order is very close to a power of 2, it is acceptable to omit the rejection test completely. In particular, if the group order is p and there is an integer b such that |p - 2^b| is less than 2^(b/2), then RandomScalar can simply return a uniformly random integer of at most b bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最適化として、グループ次数が 2 の累乗に非常に近い場合は、棄却テストを完全に省略しても問題ありません。特に、グループ次数が p で、|p - 2^b| のような整数 b がある場合、が 2^(b/2) 未満の場合、RandomScalar は単純に最大 b ビットの一様にランダムな整数を返すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="D-2--Wide-Reduction">
D.2. Wide Reduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.2. ワイドリダクション
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generate a random byte array with l = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) bytes and interpret it as an integer; reduce the integer modulo G.Order() and return the result. See Section 5 of [HASH-TO-CURVE] for the underlying derivation of l.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
l = ceil(((3 * ceil(log2(G.Order()))) / 2) / 8) バイトのランダムなバイト配列を生成し、それを整数として解釈します。G.Order() を法とする整数を減算し、結果を返します。l の基礎となる導出については、[HASH-TO-CURVE] のセクション 5 を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Appendix-E--Test-Vectors">
Appendix E. Test Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
付録E. テストベクター
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains test vectors for all ciphersuites listed in Section 6. All Element and Scalar values are represented in serialized form and encoded in hexadecimal strings. Signatures are represented as the concatenation of their constituent parts. The input message to be signed is also encoded as a hexadecimal string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションには、セクション 6 にリストされているすべての暗号スイートのテスト ベクトルが含まれています。すべての要素値とスカラー値はシリアル化された形式で表され、16 進文字列でエンコードされます。署名は、その構成部分の連結として表現されます。署名される入力メッセージも 16 進文字列としてエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each test vector consists of the following information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各テスト ベクトルは次の情報で構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Configuration. This lists the fixed parameters for the particular instantiation of FROST, including MAX_PARTICIPANTS, MIN_PARTICIPANTS, and NUM_PARTICIPANTS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 構成。これには、MAX_PARTICIPANTS、MIN_PARTICIPANTS、NUM_PARTICIPANTS など、FROST の特定のインスタンス化の固定パラメーターがリストされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Group input parameters. This lists the group secret key and shared public key, generated by a trusted dealer as described in Appendix C, as well as the input message to be signed. The randomly generated coefficients produced by the trusted dealer to share the group signing secret are also listed. Each coefficient is identified by its index, e.g., share_polynomial_coefficients[1] is the coefficient of the first term in the polynomial. Note that the 0-th coefficient is omitted, as this is equal to the group secret key. All values are encoded as hexadecimal strings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* グループ入力パラメータ。これには、付録 C で説明されているように信頼できるディーラーによって生成されたグループ秘密鍵と共有公開鍵、および署名される入力メッセージがリストされます。グループ署名秘密を共有するために信頼できるディーラーによって生成されたランダムに生成された係数もリストされます。各係数はインデックスによって識別されます。たとえば、share_polynomial_coefficients[1] は多項式の最初の項の係数です。なお、0番目の係数はグループ秘密鍵と等しいため省略されています。すべての値は 16 進文字列としてエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Signer input parameters. This lists the signing key share for each of the NUM_PARTICIPANTS participants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 署名者の入力パラメータ。これには、NUM_PARTICIPANTS 人の各参加者の署名キーの共有がリストされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Round one parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged in the protocol, identified by their NonZeroScalar identifier, and the following for each participant: the hiding and binding commitment values produced in Section 5.1; the randomness values used to derive the commitment nonces in nonce_generate; the resulting group binding factor input computed in part from the group commitment list encoded as described in Section 4.3; and the group binding factor as computed in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* パラメーターと出力を丸めます。これには、プロトコルに参加している NUM_PARTICIPANTS 人の参加者 (NonZeroScalar 識別子によって識別される) と、各参加者の以下がリストされます。セクション 5.1 で生成された非表示およびバインディングのコミットメント値。nonce_generate でコミットメント nonce を導出するために使用されるランダム値。セクション 4.3 で説明されているようにエンコードされたグループコミットメントリストから部分的に計算された結果のグループ結合因子入力。およびセクション 5.2 で計算されたグループ結合係数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Round two parameters and outputs. This lists the NUM_PARTICIPANTS participants engaged in the protocol, identified by their NonZeroScalar identifier, along with their corresponding output signature share as produced in Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 2 つのパラメーターと出力を丸めます。これには、プロトコルに参加している NUM_PARTICIPANTS 人の参加者 (NonZeroScalar 識別子によって識別される) が、セクション 5.2 で生成された対応する出力署名共有とともにリストされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Final output. This lists the aggregate signature as produced in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 最終出力。これは、セクション 5.3 で生成された集約署名をリストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-1--FROSTEd25519-SHA-512">
E.1. FROST(Ed25519, SHA-512)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. フロスト(Ed25519、SHA-512)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   // Configuration information
   MAX_PARTICIPANTS: 3
   MIN_PARTICIPANTS: 2
   NUM_PARTICIPANTS: 2

   // Group input parameters
   participant_list: 1,3
   group_secret_key: 7b1c33d3f5291d85de664833beb1ad469f7fb6025a0ec78b3a7
   90c6e13a98304
   group_public_key: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3faf66040
   d380fb9738673
   message: 74657374
   share_polynomial_coefficients[1]: 178199860edd8c62f5212ee91eff1295d0d
   670ab4ed4506866bae57e7030b204

   // Signer input parameters
   P1 participant_share: 929dcc590407aae7d388761cddb0c0db6f5627aea8e217f
   4a033f2ec83d93509
   P2 participant_share: a91e66e012e4364ac9aaa405fcafd370402d9859f7b6685
   c07eed76bf409e80d
   P3 participant_share: d3cb090a075eb154e82fdb4b3cb507f110040905468bb9c
   46da8bdea643a9a02

   // Signer round one outputs
   P1 hiding_nonce_randomness: 0fd2e39e111cdc266f6c0f4d0fd45c947761f1f5d
   3cb583dfcb9bbaf8d4c9fec
   P1 binding_nonce_randomness: 69cd85f631d5f7f2721ed5e40519b1366f340a87
   c2f6856363dbdcda348a7501
   P1 hiding_nonce: 812d6104142944d5a55924de6d49940956206909f2acaeedecda
   2b726e630407
   P1 binding_nonce: b1110165fc2334149750b28dd813a39244f315cff14d4e89e61
   42f262ed83301
   P1 hiding_nonce_commitment: b5aa8ab305882a6fc69cbee9327e5a45e54c08af6
   1ae77cb8207be3d2ce13de3
   P1 binding_nonce_commitment: 67e98ab55aa310c3120418e5050c9cf76cf387cb
   20ac9e4b6fdb6f82a469f932
   P1 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f
   af66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c
   6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a
   193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12
   c660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7
   0100000000000000000000000000000000000000000000000000000000000000
   P1 binding_factor: f2cb9d7dd9beff688da6fcc83fa89046b3479417f47f55600b
   106760eb3b5603
   P3 hiding_nonce_randomness: 86d64a260059e495d0fb4fcc17ea3da7452391baa
   494d4b00321098ed2a0062f
   P3 binding_nonce_randomness: 13e6b25afb2eba51716a9a7d44130c0dbae0004a
   9ef8d7b5550c8a0e07c61775
   P3 hiding_nonce: c256de65476204095ebdc01bd11dc10e57b36bc96284595b8215
   222374f99c0e
   P3 binding_nonce: 243d71944d929063bc51205714ae3c2218bd3451d0214dfb5ae
   ec2a90c35180d
   P3 hiding_nonce_commitment: cfbdb165bd8aad6eb79deb8d287bcc0ab6658ae57
   fdcc98ed12c0669e90aec91
   P3 binding_nonce_commitment: 7487bc41a6e712eea2f2af24681b58b1cf1da278
   ea11fe4e8b78398965f13552
   P3 binding_factor_input: 15d21ccd7ee42959562fc8aa63224c8851fb3ec85a3f
   af66040d380fb9738673504df914fa965023fb75c25ded4bb260f417de6d32e5c442c
   6ba313791cc9a4948d6273e8d3511f93348ea7a708a9b862bc73ba2a79cfdfe07729a
   193751cbc973af46d8ac3440e518d4ce440a0e7d4ad5f62ca8940f32de6d8dc00fc12
   c660b817d587d82f856d277ce6473cae6d2f5763f7da2e8b4d799a3f3e725d4522ec7
   0300000000000000000000000000000000000000000000000000000000000000
   P3 binding_factor: b087686bf35a13f3dc78e780a34b0fe8a77fef1b9938c563f5
   573d71d8d7890f

   // Signer round two outputs
   P1 sig_share: 001719ab5a53ee1a12095cd088fd149702c0720ce5fd2f29dbecf24
   b7281b603
   P3 sig_share: bd86125de990acc5e1f13781d8e32c03a9bbd4c53539bbc106058bf
   d14326007

   sig: 36282629c383bb820a88b71cae937d41f2f2adfcc3d02e55507e2fb9e2dd3cbe
   bd9d2b0844e49ae0f3fa935161e1419aab7b47d21a37ebeae1f17d4987b3160b
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-2--FROSTEd448-SHAKE256">
E.2. FROST(Ed448, SHAKE256)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.2. フロスト(Ed448、SHAKE256)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   // Configuration information
   MAX_PARTICIPANTS: 3
   MIN_PARTICIPANTS: 2
   NUM_PARTICIPANTS: 2

   // Group input parameters
   participant_list: 1,3
   group_secret_key: 6298e1eef3c379392caaed061ed8a31033c9e9e3420726f23b4
   04158a401cd9df24632adfe6b418dc942d8a091817dd8bd70e1c72ba52f3c00
   group_public_key: 3832f82fda00ff5365b0376df705675b63d2a93c24c6e81d408
   01ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b000
   message: 74657374
   share_polynomial_coefficients[1]: dbd7a514f7a731976620f0436bd135fe8dd
   dc3fadd6e0d13dbd58a1981e587d377d48e0b7ce4e0092967c5e85884d0275a7a740b
   6abdcd0500

   // Signer input parameters
   P1 participant_share: 4a2b2f5858a932ad3d3b18bd16e76ced3070d72fd79ae44
   02df201f525e754716a1bc1b87a502297f2a99d89ea054e0018eb55d39562fd0100
   P2 participant_share: 2503d56c4f516444a45b080182b8a2ebbe4d9b2ab509f25
   308c88c0ea7ccdc44e2ef4fc4f63403a11b116372438a1e287265cadeff1fcb0700
   P3 participant_share: 00db7a8146f995db0a7cf844ed89d8e94c2b5f259378ff6
   6e39d172828b264185ac4decf7219e4aa4478285b9c0eef4fccdf3eea69dd980d00

   // Signer round one outputs
   P1 hiding_nonce_randomness: 9cda90c98863ef3141b75f09375757286b4bc323d
   d61aeb45c07de45e4937bbd
   P1 binding_nonce_randomness: 781bf4881ffe1aa06f9341a747179f07a49745f8
   cd37d4696f226aa065683c0a
   P1 hiding_nonce: f922beb51a5ac88d1e862278d89e12c05263b945147db04b9566
   acb2b5b0f7422ccea4f9286f4f80e6b646e72143eeaecc0e5988f8b2b93100
   P1 binding_nonce: 1890f16a120cdeac092df29955a29c7cf29c13f6f7be60e63d6
   3f3824f2d37e9c3a002dfefc232972dc08658a8c37c3ec06a0c5dc146150500
   P1 hiding_nonce_commitment: 3518c2246c874569e54ab254cb1da666ca30f7879
   605cc43b4d2c47a521f8b5716080ab723d3a0cd04b7e41f3cc1d3031c94ccf3829b23
   fe80
   P1 binding_nonce_commitment: 11b3d5220c57d02057497de3c4eebab384900206
   592d877059b0a5f1d5250d002682f0e22dff096c46bb81b46d60fcfe7752ed47cea76
   c3900
   P1 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6
   e81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00
   0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35
   4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f
   623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1
   48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f
   4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc
   cc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9
   ef6a4b3b88860b7138ee246034561c7460db0b3fae501000000000000000000000000
   000000000000000000000000000000000000000000000000000000000000000000000
   0000000000000000000
   P1 binding_factor: 71966390dfdbed73cf9b79486f3b70e23b243e6c40638fb559
   98642a60109daecbfcb879eed9fe7dbbed8d9e47317715a5740f772173342e00
   P3 hiding_nonce_randomness: b3adf97ceea770e703ab295babf311d77e956a20d
   3452b4b3344aa89a828e6df
   P3 binding_nonce_randomness: 81dbe7742b0920930299197322b255734e52bbb9
   1f50cfe8ce689f56fadbce31
   P3 hiding_nonce: ccb5c1e82f23e0a4b966b824dbc7b0ef1cc5f56eeac2a4126e2b
   2143c5f3a4d890c52d27803abcf94927faf3fc405c0b2123a57a93cefa3b00
   P3 binding_nonce: e089df9bf311cf711e2a24ea27af53e07b846d09692fe11035a
   1112f04d8b7462a62f34d8c01493a22b57a1cbf1f0a46c77d64d46449a90100
   P3 hiding_nonce_commitment: 1254546d7d104c04e4fbcf29e05747e2edd392f67
   87d05a6216f3713ef859efe573d180d291e48411e5e3006e9f90ee986ccc26b7a4249
   0b80
   P3 binding_nonce_commitment: 3ef0cec20be15e56b3ddcb6f7b956fca0c8f7199
   0f45316b537b4f64c5e8763e6629d7262ff7cd0235d0781f23be97bf8fa8817643ea1
   9cd00
   P3 binding_factor_input: 3832f82fda00ff5365b0376df705675b63d2a93c24c6
   e81d40801ba265632be10f443f95968fadb70d10786827f30dc001c8d0f9b7c1d1b00
   0e9a0f30b97fe77ef751b08d4e252a3719ae9135e7f7926f7e3b7dd6656b27089ca35
   4997fe5a633aa0946c89f022462e7e9d50fd6ef313f72d956ea4571089427daa1862f
   623a41625177d91e4a8f350ce9c8bd3bc7c766515dc1dd3a0eab93777526b616cccb1
   48fe1e5992dc1ae705c8ba2f97ca8983328d41d375ed1e5fde5c9d672121c9e8f177f
   4a1a9b2575961531b33f054451363c8f27618382cd66ce14ad93b68dac6a09f5edcbc
   cc813906b3fc50b8fef1cc09757b06646f38ceed1674cd6ced28a59c93851b325c6a9
   ef6a4b3b88860b7138ee246034561c7460db0b3fae503000000000000000000000000
   000000000000000000000000000000000000000000000000000000000000000000000
   0000000000000000000
   P3 binding_factor: 236a6f7239ac2019334bad21323ec93bef2fead37bd5511435
   6419f3fc1fb59f797f44079f28b1a64f51dd0a113f90f2c3a1c27d2faa4f1300

   // Signer round two outputs
   P1 sig_share: e1eb9bfbef792776b7103891032788406c070c5c315e3bf5d64acd4
   6ea8855e85b53146150a09149665cbfec71626810b575e6f4dbe9ba3700
   P3 sig_share: 815434eb0b9f9242d54b8baf2141fe28976cabe5f441ccfcd5ee7cd
   b4b52185b02b99e6de28e2ab086c7764068c5a01b5300986b9f084f3e00

   sig: cd642cba59c449dad8e896a78a60e8edfcbd9040df524370891ff8077d47ce72
   1d683874483795f0d85efcbd642c4510614328605a19c6ed806ffb773b6956419537c
   dfdb2b2a51948733de192dcc4b82dc31580a536db6d435e0cb3ce322fbcf9ec23362d
   da27092c08767e607bf2093600
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-3--FROSTristretto255-SHA-512">
E.3. FROST(ristretto255, SHA-512)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.3. FROST(リストレット255、SHA-512)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   // Configuration information
   MAX_PARTICIPANTS: 3
   MIN_PARTICIPANTS: 2
   NUM_PARTICIPANTS: 2

   // Group input parameters
   participant_list: 1,3
   group_secret_key: 1b25a55e463cfd15cf14a5d3acc3d15053f08da49c8afcf3ab2
   65f2ebc4f970b
   group_public_key: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3dd9c3c0d
   05083c7254f57
   message: 74657374
   share_polynomial_coefficients[1]: 410f8b744b19325891d73736923525a4f59
   6c805d060dfb9c98009d34e3fec02

   // Signer input parameters
   P1 participant_share: 5c3430d391552f6e60ecdc093ff9f6f4488756aa6cebdba
   d75a768010b8f830e
   P2 participant_share: b06fc5eac20b4f6e1b271d9df2343d843e1e1fb03c4cbb6
   73f2872d459ce6f01
   P3 participant_share: f17e505f0e2581c6acfe54d3846a622834b5e7b50cad9a2
   109a97ba7a80d5c04

   // Signer round one outputs
   P1 hiding_nonce_randomness: f595a133b4d95c6e1f79887220c8b275ce6277e7f
   68a6640e1e7140f9be2fb5c
   P1 binding_nonce_randomness: 34dd1001360e3513cb37bebfabe7be4a32c5bb91
   ba19fbd4360d039111f0fbdc
   P1 hiding_nonce: 214f2cabb86ed71427ea7ad4283b0fae26b6746c801ce824b83c
   eb2b99278c03
   P1 binding_nonce: c9b8f5e16770d15603f744f8694c44e335e8faef00dad182b8d
   7a34a62552f0c
   P1 hiding_nonce_commitment: 965def4d0958398391fc06d8c2d72932608b1e625
   5226de4fb8d972dac15fd57
   P1 binding_nonce_commitment: ec5170920660820007ae9e1d363936659ef622f9
   9879898db86e5bf1d5bf2a14
   P1 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d
   d9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8
   4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4
   b79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f
   795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f
   0100000000000000000000000000000000000000000000000000000000000000
   P1 binding_factor: 8967fd70fa06a58e5912603317fa94c77626395a695a0e4e4e
   fc4476662eba0c
   P3 hiding_nonce_randomness: daa0cf42a32617786d390e0c7edfbf2efbd428037
   069357b5173ae61d6dd5d5e
   P3 binding_nonce_randomness: b4387e72b2e4108ce4168931cc2c7fcce5f345a5
   297368952c18b5fc8473f050
   P3 hiding_nonce: 3f7927872b0f9051dd98dd73eb2b91494173bbe0feb65a3e7e58
   d3e2318fa40f
   P3 binding_nonce: ffd79445fb8030f0a3ddd3861aa4b42b618759282bfe24f1f93
   04c7009728305
   P3 hiding_nonce_commitment: 480e06e3de182bf83489c45d7441879932fd7b434
   a26af41455756264fbd5d6e
   P3 binding_nonce_commitment: 3064746dfd3c1862ef58fc68c706da287dd92506
   6865ceacc816b3a28c7b363b
   P3 binding_factor_input: e2a62f39eede11269e3bd5a7d97554f5ca384f9f6d3d
   d9c3c0d05083c7254f572889dde2854e26377a16caf77dfee5f6be8fe5b4c80318da8
   4698a4161021b033911db5ef8205362701bc9ecd983027814abee94f46d094943a2f4
   b79a6e4d4603e52c435d8344554942a0a472d8ad84320585b8da3ae5b9ce31cd1903f
   795c1af66de22af1a45f652cd05ee446b1b4091aaccc91e2471cd18a85a659cecd11f
   0300000000000000000000000000000000000000000000000000000000000000
   P3 binding_factor: f2c1bb7c33a10511158c2f1766a4a5fadf9f86f2a92692ed33
   3128277cc31006

   // Signer round two outputs
   P1 sig_share: 9285f875923ce7e0c491a592e9ea1865ec1b823ead4854b48c8a462
   87749ee09
   P3 sig_share: 7cb211fe0e3d59d25db6e36b3fb32344794139602a7b24f1ae0dc4e
   26ad7b908

   sig: fc45655fbc66bbffad654ea4ce5fdae253a49a64ace25d9adb62010dd9fb2555
   2164141787162e5b4cab915b4aa45d94655dbb9ed7c378a53b980a0be220a802
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-4--FROSTP-256-SHA-256">
E.4. FROST(P-256, SHA-256)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.4. フロスト(P-256、SHA-256)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   // Configuration information
   MAX_PARTICIPANTS: 3
   MIN_PARTICIPANTS: 2
   NUM_PARTICIPANTS: 2

   // Group input parameters
   participant_list: 1,3
   group_secret_key: 8ba9bba2e0fd8c4767154d35a0b7562244a4aaf6f36c8fb8735
   fa48b301bd8de
   group_public_key: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99cfbd02b4
   dc00585ec45ab70
   message: 74657374
   share_polynomial_coefficients[1]: 80f25e6c0709353e46bfbe882a11bdbb1f8
   097e46340eb8673b7e14556e6c3a4

   // Signer input parameters
   P1 participant_share: 0c9c1a0fe806c184add50bbdcac913dda73e482daf95dcb
   9f35dbb0d8a9f7731
   P2 participant_share: 8d8e787bef0ff6c2f494ca45f4dad198c6bee01212d6c84
   067159c52e1863ad5
   P3 participant_share: 0e80d6e8f6192c003b5488ce1eec8f5429587d48cf00154
   1e713b2d53c09d928

   // Signer round one outputs
   P1 hiding_nonce_randomness: ec4c891c85fee802a9d757a67d1252e7f4e5efb8a
   538991ac18fbd0e06fb6fd3
   P1 binding_nonce_randomness: 9334e29d09061223f69a09421715a347e4e6deba
   77444c8f42b0c833f80f4ef9
   P1 hiding_nonce: 9f0542a5ba879a58f255c09f06da7102ef6a2dec6279700c656d
   58394d8facd4
   P1 binding_nonce: 6513dfe7429aa2fc972c69bb495b27118c45bbc6e654bb9dc9b
   e55385b55c0d7
   P1 hiding_nonce_commitment: 0213b3e6298bf8ad46fd5e9389519a8665d63d98f
   4ec6a1fcca434e809d2d8070e
   P1 binding_nonce_commitment: 02188ff1390bf69374d7b272e454b1878ef10a6b
   6ea3ff36f114b300b4dbd5233b
   P1 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c
   fbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c
   51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6
   ec73d3fc4afd000000000000000000000000000000000000000000000000000000000
   0000001
   P1 binding_factor: 7925f0d4693f204e6e59233e92227c7124664a99739d2c06b8
   1cf64ddf90559e
   P3 hiding_nonce_randomness: c0451c5a0a5480d6c1f860e5db7d655233dca2669
   fd90ff048454b8ce983367b
   P3 binding_nonce_randomness: 2ba5f7793ae700e40e78937a82f407dd35e847e3
   3d1e607b5c7eb6ed2a8ed799
   P3 hiding_nonce: f73444a8972bcda9e506bbca3d2b1c083c10facdf4bb5d47fef7
   c2dc1d9f2a0d
   P3 binding_nonce: 44c6a29075d6e7e4f8b97796205f9e22062e7835141470afe94
   17fd317c1c303
   P3 hiding_nonce_commitment: 033ac9a5fe4a8b57316ba1c34e8a6de453033b750
   e8984924a984eb67a11e73a3f
   P3 binding_nonce_commitment: 03a7a2480ee16199262e648aea3acab628a53e9b
   8c1945078f2ddfbdc98b7df369
   P3 binding_factor_input: 023a309ad94e9fe8a7ba45dfc58f38bf091959d3c99c
   fbd02b4dc00585ec45ab70825371853e974bc30ac5b947b216d70461919666584c70c
   51f9f56f117736c5d178dd0b521ad9c1abe98048419cbdec81504c85e12eb40e3bcb6
   ec73d3fc4afd000000000000000000000000000000000000000000000000000000000
   0000003
   P3 binding_factor: e10d24a8a403723bcb6f9bb4c537f316593683b472f7a89f16
   6630dde11822c4

   // Signer round two outputs
   P1 sig_share: 400308eaed7a2ddee02a265abe6a1cfe04d946ee8720768899619cf
   abe7a3aeb
   P3 sig_share: 561da3c179edbb0502d941bb3e3ace3c37d122aaa46fb54499f15f3
   a3331de44

   sig: 026d8d434874f87bdb7bc0dfd239b2c00639044f9dcb195e9a04426f70bfa4b7
   0d9620acac6767e8e3e3036815fca4eb3a3caa69992b902bcd3352fc34f1ac192f
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="E-5--FROSTsecp256k1-SHA-256">
E.5. FROST(secp256k1, SHA-256)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.5. FROST(secp256k1、SHA-256)
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   // Configuration information
   MAX_PARTICIPANTS: 3
   MIN_PARTICIPANTS: 2
   NUM_PARTICIPANTS: 2

   // Group input parameters
   participant_list: 1,3
   group_secret_key: 0d004150d27c3bf2a42f312683d35fac7394b1e9e318249c1bf
   e7f0795a83114
   group_public_key: 02f37c34b66ced1fb51c34a90bdae006901f10625cc06c4f646
   63b0eae87d87b4f
   message: 74657374
   share_polynomial_coefficients[1]: fbf85eadae3058ea14f19148bb72b45e439
   9c0b16028acaf0395c9b03c823579

   // Signer input parameters
   P1 participant_share: 08f89ffe80ac94dcb920c26f3f46140bfc7f95b493f8310
   f5fc1ea2b01f4254c
   P2 participant_share: 04f0feac2edcedc6ce1253b7fab8c86b856a797f44d83d8
   2a385554e6e401984
   P3 participant_share: 00e95d59dd0d46b0e303e500b62b7ccb0e555d49f5b849f
   5e748c071da8c0dbc

   // Signer round one outputs
   P1 hiding_nonce_randomness: 7ea5ed09af19f6ff21040c07ec2d2adbd35b759da
   5a401d4c99dd26b82391cb2
   P1 binding_nonce_randomness: 47acab018f116020c10cb9b9abdc7ac10aae1b48
   ca6e36dc15acb6ec9be5cdc5
   P1 hiding_nonce: 841d3a6450d7580b4da83c8e618414d0f024391f2aeb511d7579
   224420aa81f0
   P1 binding_nonce: 8d2624f532af631377f33cf44b5ac5f849067cae2eacb88680a
   31e77c79b5a80
   P1 hiding_nonce_commitment: 03c699af97d26bb4d3f05232ec5e1938c12f1e6ae
   97643c8f8f11c9820303f1904
   P1 binding_nonce_commitment: 02fa2aaccd51b948c9dc1a325d77226e98a5a3fe
   65fe9ba213761a60123040a45e
   P1 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0
   6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade
   6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d
   ef941b5d4801000000000000000000000000000000000000000000000000000000000
   0000001
   P1 binding_factor: 3e08fe561e075c653cbfd46908a10e7637c70c74f0a77d5fd4
   5d1a750c739ec6
   P3 hiding_nonce_randomness: e6cc56ccbd0502b3f6f831d91e2ebd01c4de0479e
   0191b66895a4ffd9b68d544
   P3 binding_nonce_randomness: 7203d55eb82a5ca0d7d83674541ab55f6e76f1b8
   5391d2c13706a89a064fd5b9
   P3 hiding_nonce: 2b19b13f193f4ce83a399362a90cdc1e0ddcd83e57089a7af0bd
   ca71d47869b2
   P3 binding_nonce: 7a443bde83dc63ef52dda354005225ba0e553243402a4705ce2
   8ffaafe0f5b98
   P3 hiding_nonce_commitment: 03077507ba327fc074d2793955ef3410ee3f03b82
   b4cdc2370f71d865beb926ef6
   P3 binding_nonce_commitment: 02ad53031ddfbbacfc5fbda3d3b0c2445c8e3e99
   cbc4ca2db2aa283fa68525b135
   P3 binding_factor_input: 02f37c34b66ced1fb51c34a90bdae006901f10625cc0
   6c4f64663b0eae87d87b4fff9b5210ffbb3c07a73a7c8935be4a8c62cf015f6cf7ade
   6efac09a6513540fc3f5a816aaebc2114a811a415d7a55db7c5cbc1cf27183e79dd9d
   ef941b5d4801000000000000000000000000000000000000000000000000000000000
   0000003
   P3 binding_factor: 93f79041bb3fd266105be251adaeb5fd7f8b104fb554a4ba9a
   0becea48ddbfd7

   // Signer round two outputs
   P1 sig_share: c4fce1775a1e141fb579944166eab0d65eefe7b98d480a569bbbfcb
   14f91c197
   P3 sig_share: 0160fd0d388932f4826d2ebcd6b9eaba734f7c71cf25b4279a4ca25
   81e47b18d

   sig: 0205b6d04d3774c8929413e3c76024d54149c372d57aae62574ed74319b5ea14
   d0c65dde8492a7471437e6c2fe3da49b90d23f642b5c6dbe7e36089f096dd97324
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Acknowledgments">
Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
謝辞
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document was improved based on input and contributions by the Zcash Foundation engineering team. In addition, the authors of this document would like to thank Isis Lovecruft, Alden Torres, T. Wilson-Brown, and Conrado Gouvea for their input and contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Zcash Foundation エンジニアリング チームによる入力と貢献に基づいて改良されました。さらに、この文書の著者は、Isis Lovecruft 氏、Alden Torres 氏、T. Wilson-Brown 氏、および Conrado Gouvea 氏の意見と貢献に感謝の意を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2" id="Authors-Addresses">
Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
著者の住所
        </h5>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Deirdre Connolly
   Zcash Foundation
   Email: durumcrustulum@gmail.com
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Chelsea Komlo
   University of Waterloo, Zcash Foundation
   Email: ckomlo@uwaterloo.ca
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Ian Goldberg
   University of Waterloo
   Email: iang@uwaterloo.ca
        </pre>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Christopher A. Wood
   Cloudflare
   Email: caw@heapingbits.net
        </pre>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
